CMBEGIN,,,cd /usr/src/fhttp,,
CMBEGIN,Nov 28 12:08:02,/usr/src/fhttpd,ls,frobnick  index.html  Makefile<HT>webserver  webserver.c,ls
CMBEGIN,Nov 28 12:12:20,/usr/src/fhttpd,sudo ./webserver 8000,^[<NL>^[[A^[[A^C,sudo ./webserver 8000
CMBEGIN,Nov 28 12:12:49,/usr/src/fhttpd,sudo ./webserver 8080,^C,sudo ./webserver 8080
CMBEGIN,Nov 28 12:14:54,/usr/src/fhttpd,ls,frobnick  index.html  Makefile<HT>webserver  webserver.c,ls
CMBEGIN,Nov 28 12:15:06,/usr/src/fhttpd,emacs webserver.c,%=><NL>=-111:----F1  *scratch*      All L1     (Fundamental) ---------------------------<NL>Loading 00debian-vars...done<NL>/etc/emacs/site-start.d/50autoconf.el (source)...<NL>done<NL>Loading /etc/emacs/site-start.d/50autoconf.el (source)...doneFile Edit Options Buffers Tools Lisp-Interaction Help                           <NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL>-111:----F1  *scratch*      All L1     (Lisp Interaction) ----------------------<NL>For information about GNU Emacs and the GNU system%% type C-h C-a.<NL>Note: file is write protected<NL>Note: file is write protectedFile Edit Options Buffers Tools C Help                                          <NL><NL>// webserver.c                                                                  <NL><NL>// FrobozzCo Official Webserver                                                 <NL><NL>// Barbazzo Fernap barbazzo@gue.com                                             <NL><NL>// Gustar Woomax gustar@gue.com                                                 <NL><NL>// Wilbar Memboob wilbar@gue.com                                                <NL><NL><NL>// By the Frobozz Magic Webserver Company                                       <NL><NL>// Released under the Grue Public License                                       <NL><NL>// Frobruary 14th%% 1067 GUE                                                     <NL><NL><NL>// THERE IS NO WARRANTY FOR THE PROGRAM%% TO THE EXTENT PERMITTED                <NL><NL>// BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE               <NL><NL>// COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \u201CAS IS\u201D\<NL><NL>                                                                                <NL><NL>// WITHOUT WARRANTY OF ANY KIND%% EITHER EXPRESSED OR IMPLIED%% INCLUDING%%        <NL><NL>// BUT NOT LIMITED TO%% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND            <NL><NL>// FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY          <NL><NL>// AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE         <NL><NL>// DEFECTIVE%% *AND IT WILL*%% YOU ASSUME THE COST OF ALL NECESSARY               <NL><NL>// SERVICING%% REPAIR OR CORRECTION.                                             <NL><NL><NL>-11U:%%%%--F1  webserver.c    Top L1     (C/l Abbrev) ----------------------------<NL>2<NL><NL>4571139DEFECTIVE%% *AND IT WILL*%% YOU ASSUME THE COST OF ALL NECESSARYSERVICING%% REPAIR OR CORRECTION.<NL><NL>#include <stdio.h><NL>#include <errno.h><NL>#include <string.h><NL>#include <stdlib.h><NL>#include <netdb.h><NL>#include <sys/stat.h><NL>#include <sys/types.h><NL>#include <sys/socket.h><NL>#include <netinet/in.h><NL>#include <arpa/inet.h><NL>#include <unistd.h><NL>#include <fcntl.h><NL>#include <time.h><NL>#include <pthread.h><NL><NL>#define _XOPEN_SOURCE<NL><NL>typedef struct { 6%% L28        char *method;<NL>        char *uri;<NL>        char *version;<NL>        char *headers;<NL>} httpreq_t;<NL><NL><NL>/* NOTE: this function is based on a function provided in the GNU "timegm" man  <NL><NL>   page. timegm is a GNU extension to time.h that returns the given tm struct a\<NL><NL>s                                                                               <NL><NL>   a UNIX timestamp in GMT/UTC%% rather than local time. The man page suggests a8%% L3940395// BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE               <NL>// COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \u201CAS IS\u201D\<NL>                                                                                <NL>// WITHOUT WARRANTY OF ANY KIND%% EITHER EXPRESSED OR IMPLIED%% INCLUDING%%        <NL>// BUT NOT LIMITED TO%% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND            <NL>// FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY          <NL>// AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE         <NL>// DEFECTIVE%% *AND IT WILL*%% YOU ASSUME THE COST OF ALL NECESSARY               <NL>// SERVICING%% REPAIR OR CORRECTION.                                             <NL><NL>#include <stdio.h><NL>#include <errno.h><NL>#include <string.h><NL>#include <stdlib.h><NL>#include <netdb.h><NL>#include <sys/stat.h><NL>#include <sys/types.h><NL>#include <sys/socket.h><NL>#include <netinet/in.h><NL>#include <arpa/inet.h><NL>#include <unistd.h>3%% L22// webserver.c                                                                  <NL><NL>// FrobozzCo Official Webserver                                                 <NL><NL>// Barbazzo Fernap barbazzo@gue.com                                             <NL><NL>// Gustar Woomax gustar@gue.com                                                 <NL><NL>// Wilbar Memboob wilbar@gue.com                                                <NL><NL><NL>// By the Frobozz Magic Webserver Company                                       <NL><NL>// Released under the Grue Public License                                       <NL><NL>// Frobruary 14th%% 1067 GUE                                                     <NL><NL><NL>// THERE IS NO WARRANTY FOR THE PROGRAM%% TO THE EXTENT PERMITTED                <NL>Top L3 Beginning of buffer1<NL>2<NL><NL>616#include <string.h><NL>#include <stdlib.h><NL>#include <netdb.h><NL>#include <sys/stat.h><NL>#include <sys/types.h><NL>#include <sys/socket.h><NL>#include <netinet/in.h><NL>#include <arpa/inet.h><NL>#include <unistd.h><NL>#include <fcntl.h><NL>#include <time.h><NL>#include <pthread.h><NL><NL>#define _XOPEN_SOURCE<NL><NL>typedef struct {<NL>        char *method;<NL>        char *uri;<NL>        char *version;<NL>        char *headers;<NL>} httpreq_t; 7%% L3340<NL><NL>/* NOTE: this function is based on a function provided in the GNU "timegm" man  <NL>   page. timegm is a GNU extension to time.h that returns the given tm struct a\<NL>s                                                                               <NL>   a UNIX timestamp in GMT/UTC%% rather than local time. The man page suggests a<NL>   function similar to the one below as a portable equivalent.                  <NL> */<NL>time_t my_timegm(struct tm *tm) {<NL>        time_t ret;<NL>        char *tz;<NL><NL><HT>tz = getenv("TZ");<NL>        putenv("TZ=GMT");<NL><HT>tzset();<NL>        ret = mktime(tm);<NL><HT>if (tz) {<NL><HT>        char envstr[strlen(tz) + 4];<NL><HT>        envstr[0] = '\0';<NL><HT>        strcat(envstr%% "TZ=");<NL>                strcat(envstr%% tz);10%% L54589623<NL>                putenv(envstr);<NL>        } else {<NL>                putenv("TZ=");<NL>        }<NL><NL>        tzset();<NL><NL>        return ret;<NL>}<NL><NL>char *get_header(const httpreq_t *req%% const char* headername) {3%% L6467874565<NL><NL>4<NL><HT>char *uri;<NL><HT>char *version;<NL><HT>char *headers;<NL>} httpreq_t;<NL><NL><NL>/* NOTE: this function is based on a function provided in the GNU "timegm" man  <NL>   page. timegm is a GNU extension to time.h that returns the given tm struct a\<NL>s                                                                               <NL>   a UNIX timestamp in GMT/UTC%% rather than local time. The man page suggests a<NL>   function similar to the one below as a portable equivalent.                  <NL> */<NL>time_t my_timegm(struct tm *tm) {<NL><HT>time_t ret;<NL><HT>char *tz;<NL><NL><HT>tz = getenv("TZ");<NL><HT>putenv("TZ=GMT");<NL>        tzset();<NL><HT>ret = mktime(tm);<NL>        if (tz) {0%% L50467<NL>85012345789<NL> */<NL>time_t my_timegm(struct tm *tm) {<NL><HT>time_t ret;<NL>        char *tz;<NL><NL><HT>tz = getenv("TZ");<NL>        putenv("TZ=GMT");<NL>        tzset();<NL>        ret = mktime(tm);<NL>        if (tz) {<NL>                char envstr[strlen(tz) + 4];<NL>                envstr[0] = '\0';<NL>                strcat(envstr%% "TZ=");<NL><HT>        strcat(envstr%% tz);<NL><HT>        putenv(envstr);<NL><HT>} else {<NL><HT>        putenv("TZ=");<NL><HT>}<NL><NL><HT>tzset();<NL>2%% L6028970<NL>                envstr[0] = '\0';<NL>                strcat(envstr%% "TZ=");<NL><HT>        strcat(envstr%% tz);<NL><HT>        putenv(envstr);<NL><HT>} else {<NL><HT>        putenv("TZ=");<NL><HT>}<NL><NL><HT>tzset();<NL><NL><HT>return ret;<NL>}<NL><NL>char *get_header(const httpreq_t *req%% const char* headername) {<NL><HT>char *hdrptr;<NL><HT>char *hdrend;<NL><HT>char *retval = NULL;<NL><NL><HT>char searchstr[strlen(headername) + 5];<NL><HT>strcpy(searchstr%% "<NL>");<NL><HT>strcat(searchstr%% headername);4%% L7126        strcat(searchstr%% ": ");<NL><NL>        if (hdrptr = strstr(req->headers%% searchstr)) {<NL>                hdrptr += strlen(searchstr);<NL>                if (hdrend = strstr(hdrptr%% "<NL>")) {<NL>                        char hdrval[1024]; // temporary return value            <NL><NL>                        memcpy((char *)hdrval%% hdrptr%% (hdrend - hdrptr));<NL>                        hdrval[hdrend - hdrptr] = '\0'; // tack null onto end o\<NL><NL>f header value                                                                  <NL><NL>                        int hdrvallen = strlen(hdrval);<NL>                        retval = (char *)malloc((hdrvallen + 1) * sizeof(char))\<NL>5%% L82; // malloc a space for retval                                                  <NL><NL>                        strcpy(retval%% (char *)hdrval);<NL>                } else {<NL>                        retval = (char *)malloc((strlen(hdrptr) + 1) * sizeof(c\<NL><NL>har)); //                                                                       <NL><NL>                        strcpy(retval%% hdrptr);<NL>                }<NL>        }<NL><NL>        return retval;6%% L91236}<NL><NL>/* As long as str begins with a proper HTTP-Version followed by delim%% returns \<NL><NL>a                                                                               <NL><NL>   pointer to the start of the version number (e.g.%% 1.0). Returns NULL otherwi\<NL><NL>se.                                                                             <NL><NL> */<NL>char *http_version_str(char *str%% char *delim) {<NL>        char *vstart = strstr(str%% "HTTP/");<NL>        char *vnumstart = str + 5;<NL>        char *vdot = strchr(str%% '.');<NL>        char *vend = strstr(str%% delim);20%% L102        char *digits = "0123456789";<NL>        int majvlen = 0;<NL>        int minvlen = 0;<NL><NL>        if (!vstart || !vdot // something's missing                             <NL><NL>                || vstart != str) // str doesn't start with "HTTP/"             <NL><NL>                return NULL;<NL><NL>        majvlen = strspn(vnumstart%% digits);<NL>        minvlen = strspn(vdot + 1%% digits);1%% L110<NL>        if (majvlen < 1 || (vnumstart + majvlen) != vdot // bad major version   <NL><NL>                || minvlen < 1 || (vdot + minvlen + 1) != vend) // bad minor ve\<NL><NL>rsion                                                                           <NL><NL>                return NULL;<NL><NL>        return vnumstart;<NL>}<NL><NL>/* Fills req with the request data from datastr. Returns 0 on success.          <NL><NL> */<NL><NL>int parsereq(httpreq_t *req%% char *datastr) {<NL>        char *position;4%% L123int parsereq(httpreq_t *req%% char *datastr) {<NL><HT>char *position;<NL><HT>char *last_position = datastr;<NL><HT>char *temp_position<NL><HT>int matchlen;<NL><NL><HT>req->method = "";<NL><HT>req->uri = "";<NL><HT>req->version = "";<NL><HT>req->headers = "";<NL><NL><HT>if (!(position = strchr(last_position%% ' '))) {<NL><HT><HT>return 1;<NL><HT>}<NL>        matchlen = (int)(position - last_position);<NL><HT>req->method = (char *)malloc((matchlen + 1) * sizeof(char));<NL>        memcpy(req->method%% last_position%% matchlen);<NL>        req->method[matchlen] = '\0';<NL><HT>last_position = position + 1;<NL><NL><HT>if (!(position = strchr(last_position%% ' '))8%% L141End of buffer<NL>                        pthread_t *thread = (pthread_t *) malloc(sizeof(pthread\<NL>_t));<NL><HT>                int *sockfd_ptr = (int *) malloc(sizeof(int));<NL><NL><HT>                *sockfd_ptr = acc;<NL><HT><HT><HT>pthread_create(thread%% NULL%% data_thread%% sockfd_ptr);<NL><HT>        }<NL><HT>}<NL><NL><HT>return 0;<NL>}<NL><NL><NL><NL><NL><NL><NL><NL><NL><NL>Bot L520<NL><HT>if (statcode == 200 && (strcmp(req->method%% "HEAD") != 0)) {<NL>                // send the requested file as long as there's no error and the  <NL><HT><HT>// request wasn't just for the headers                          <NL><HT><HT>int readbytes;<NL><NL><HT><HT>while (readbytes = read(urifd%% sendmessage%% BUFSIZE)) {<NL><HT><HT>        if (readbytes < 0) {<NL><HT>                        perror("read");<NL><HT><HT><HT><HT>pthread_exit(NULL);<NL><HT>                }<NL>                        if (send(sockfd%% sendmessage%% readbytes%% 0) < 0) {<NL><HT><HT><HT><HT>perror("send");<NL><HT><HT><HT><HT>pthread_exit(NULL);<NL><HT><HT><HT>}<NL><HT><HT>}<NL><HT>}<NL>}<NL><NL>void *data_thread(void *sockfd_ptr) {<NL><NL><HT>int sockfd = *(int *) sockfd_ptr;69%% L3354320125945<NL><NL><HT>int sockfd = *(int *) sockfd_ptr;<NL><HT>const int BUFSIZE = 5;<NL><HT>char recvmessage[BUFSIZE];<NL><HT>char *headerstr = NULL;<NL><HT>char *newheaderstr = NULL;<NL><HT>int recvbytes = 0;<NL><HT>int curheadlen = 0;<NL><HT>int totalheadlen = 0;<NL><HT>httpreq_t req;<NL><HT>int statcode = 200;<NL><HT>int done = 0;<NL><HT>int seen_header = 0;<NL><HT>char *header_end;<NL><HT>int content_length = 0;<NL><HT>char *qstr;<NL><NL><HT>free(sockfd_ptr); // we have the int value out of this now              <NL>        recvmessage[BUFSIZE - 1] = '\0'; // mark end of "string"                <NL><NL><HT>/* Read incoming client message from the socket */72%% L3546<NL><NL><HT>while(!done && (recvbytes = recv(sockfd%% recvmessage%% BUFSIZE - 1%% 0)))\<NL>{<NL><HT>        if (recvbytes < 0) {<NL><HT>                perror("recv");<NL><HT>                pthread_exit(NULL);<NL><HT>        }<NL><NL><NL><HT>        recvmessage[recvbytes] = '\0';<NL><NL><HT>        if (seen_header) {<NL><HT>                // getting the entity body                              <NL><HT>                content_length -= recvbytes;<NL><HT>                if (content_length <= 0) done = 1;<NL><NL><HT>        } else {<NL><NL><HT>                newheaderstr = (char *) malloc((totalheadlen + recvbyte\<NL>s + 1) * sizeof(char));<NL><HT>newheaderstr[totalheadlen + recvbytes] = '\0';<NL><HT>                memcpy(newheaderstr%% headerstr%% totalheadlen);6%% L375                        memcpy(newheaderstr + totalheadlen%% recvmessage%% recvby\<NL><NL>tes);<NL><NL>                        if (headerstr != NULL) {<NL>                                free(headerstr);<NL>                        }<NL><NL>                        headerstr = newheaderstr;<NL>                        totalheadlen += recvbytes;<NL><NL>                        header_end = strstr(headerstr%% "<NL><NL>");<NL><NL>                        if (header_end) {<NL>                                seen_header = 1;<NL>                                header_end[2] = '\0';9%% L388<NL><HT><HT><HT>header_end = strstr(headerstr%% "<NL><NL>");<NL><NL>                        if (header_end) {<NL><HT><HT><HT>        seen_header = 1;<NL><HT><HT><HT>        header_end[2] = '\0';<NL><NL>                                if (parsereq(&req%% headerstr) != 0) {<NL><HT><HT><HT><HT><HT>statcode = 400;<NL><HT><HT><HT>        }<NL><NL><HT><HT><HT>        if (strcmp(req.method%% "POST") == 0) {<NL><NL><HT><HT><HT>                // grab the body length                 <NL><HT><HT><HT>                char *clenstr = get_header(&req%% "Conte\<NL>nt-Length");<NL><NL><HT><HT><HT><HT><HT>if (clenstr) {<NL><NL><HT><HT><HT><HT>                content_length = atoi(clenstr) \<NL>- ((headerstr + totalheadlen) - header_end - 4);81%% L402<NL>                                                if (content_length <= 0) {<NL>                                                        done = 1;<NL>                                                }<NL><NL>                                                free(clenstr);<NL><NL>                                        } else {<NL><NL>                                                statcode = 400; // bad request \<NL><NL>-- no content length                                                            <NL><NL>                                                done = 1;<NL>                                        }3%% L414} else {<NL><NL>                                                statcode = 400; // bad request \<NL>-- no content length                                                            <NL><HT><HT><HT><HT><HT>        done = 1;}<NL><NL>                                } else {<NL><NL>// This isn't a POST%% so there's no ent\<NL>ity body                                                                        <NL><HT><HT><HT><HT><HT>done = 1;if (strcmp(req.method%% "GET") != 0&& strcmp(req.method%% "HEAD") !\<NL>= 0) {501; // unknown requ<NL>est method          <NL><HT><HT><HT>}<NL>5%% L427statcode = 501; // unknown requ\<NL>est method                                                                      <NL>                                        }<NL><NL><HT><HT><HT><HT><NL><HT><HT><HT>} // end of "if (header)end)"                           <NL><HT><HT>}<NL><HT>} // end of recv while loop                                             <NL><NL>        // used to deref a NULL pointer here... :(<NL><HT>if (headerstr != NULL) {<NL><HT><HT>printf("%%s<NL>"%% headerstr);<NL><HT><HT>free(headerstr);<NL><HT>}<NL><NL><HT>send_response(sockfd%% &req%% statcode);<NL><HT>close(sockfd);<NL><NL><HT>return NULL;7%% L441<NL><HT>close(sockfd);<NL><NL>        return NULL;<NL><NL>}<NL><NL>int main(int argc%% char *argv[]) {<NL><HT>int acc%% sockfd%% clen%% port;<NL><HT>struct hostent *he;<NL><HT>struct sockaddr_in caddr%% saddr;<NL>(argc <= 1) {<NL>printf(stderr%% "No port specified. Exiting!<NL>");<NL><HT>        exit(1);<NL><NL><HT>}<NL><NL><HT>port = atoi(argv[1]);<NL><NL><HT>/* Obtain name and address for the local host */9%% L457<NL><HT>}<NL><NL>port = atoi(argv[1]);<NL><NL>        /* Obtain name and address for the local host */<NL><HT>if((he=gethostbyname("localhost"))==NULL) {<NL><NL><HT>        herror("gethostbyname");<NL><HT>        exit(1);<NL><NL><HT>}<NL><NL><HT>/* Open a TCP (Internet Stream) socket */<NL><HT>if((sockfd=socket(AF_INET%%SOCK_STREAM%%0)) == -1) {<NL><NL><HT><HT>perror("socket");<NL><HT>        exit(1);<NL><NL><HT>}Create socket address structure91%% L473/* Create socket address structure for the local host */<NL><HT>memset((char *) &saddr%% '\0'%% sizeof(saddr));<NL><HT>saddr.sin_family=AF_INET;<NL><HT>saddr.sin_port=htons(port);<NL><HT>saddr.sin_addr.s_addr=htonl(INADDR_ANY);<NL><NL><HT>/* Bind our local address so that the client can send to us */<NL><HT>if(bind(sockfd%%(struct sockaddr *) &saddr%%sizeof(saddr)) == -1) {<NL><HT>        perror("bind");<NL><HT><HT>exit(1);<NL><HT>}<NL><NL><HT>if(listen(sockfd%%5) < 0) {<NL><HT><HT><HT>listen<NL><NL><HT>}<NL><NL><HT>/* Infinite loop for receiving and processing client requests */<NL><HT>for(;;) {3%% L491<NL><HT>        perror("listen");<NL><HT><HT>exit(1);<NL><HT>}<NL><NL><HT>/* Infinite loop for receiving and processing client requests */<NL><HT>for(;;) {<NL><HT>        clen=sizeof(caddr);<NL><NL><HT>        /* Wait for a connection for a client process */<NL><HT>        acc=accept(sockfd%%(struct sockaddr *) &caddr%%(socklen_t*)&clen)\<NL>;<NL><HT><HT>if(acc < 0) {<NL><HT>                perror("accept");<NL><HT><HT><HT>exit(1);<NL><HT>        } else {<NL><HT><HT>        pthread_t *thread = (pthread_t *) malloc(sizeof(pthread\<NL>_t));<NL><HT>                int *sockfd_ptr = (int *) malloc(sizeof(int));<NL><NL><HT>                *sockfd_ptr = acc;<NL><HT>                pthread_create(thread%% NULL%% data_thread%% sockfd_ptr);7%% L506710                }<NL>        }<NL><NL>        return 0;<NL>}<NL><NL><NL><NL><NL>Bot L5157End of buffer201987654321009876<NL><NL>5<NL>        if(listen(sockfd%%5) < 0) {<NL>                perror("listen");<NL>                exit(1);<NL>        }<NL><NL>        /* Infinite loop for receiving and processing client requests */<NL>        for(;;) {<NL>                clen=sizeof(caddr);<NL><NL>                /* Wait for a connection for a client process */<NL>                acc=accept(sockfd%%(struct sockaddr *) &caddr%%(socklen_t*)&clen)\<NL>96%%43210499876<NL><NL>5<NL>        memset((char *) &saddr%% '\0'%% sizeof(saddr));<NL>        saddr.sin_family=AF_INET;<NL>        saddr.sin_port=htons(port);<NL>        saddr.sin_addr.s_addr=htonl(INADDR_ANY);<NL><NL>        /* Bind our local address so that the client can send to us */<NL>        if(bind(sockfd%%(struct sockaddr *) &saddr%%sizeof(saddr)) == -1) {<NL>                perror("bind");<NL>                exit(1);<NL>        }<NL>4%% L4943210898765<NL><NL>4<NL>        }<NL><NL>        /* Open a TCP (Internet Stream) socket */<NL>        if((sockfd=socket(AF_INET%%SOCK_STREAM%%0)) == -1) {<NL><NL>                perror("socket");<NL>                exit(1);<NL><NL>        }<NL><NL>        /* Create socket address structure for the local host */2%% L4832107987654<NL><NL>3<NL><NL><HT>}<NL><NL><HT>port = atoi(argv[1]);<NL><NL><HT>/* Obtain name and address for the local host */<NL><HT>if((he=gethostbyname("localhost"))==NULL) {<NL><NL><HT>        herror("gethostbyname");<NL><HT><HT>exit(1);<NL><NL><HT>}<NL><NL><HT>/* Open a TCP (Internet Stream) socket */<NL><HT>if((sockfd=socket(AF_INET%%SOCK_STREAM%%0)) == -1) {<NL><NL><HT>        perror("socket");<NL><HT>        exit(1);<NL><NL><HT>}<NL>1%% L4721069876543<NL><NL>2<NL>}<NL><NL>int main(int argc%% char *argv[]) {<NL>        int acc%% sockfd%% clen%% port;<NL>        struct hostent *he;<NL>        struct sockaddr_in caddr%% saddr;<NL><NL>        if(argc <= 1) {<NL><NL>                fprintf(stderr%% "No port specified. Exiting!<NL>");<NL>                exit(1);<NL>0%% L4610598765432<NL><NL>1<NL>        // used to deref a NULL pointer here... :(                              <NL><NL>        if (headerstr != NULL) {<NL>                printf("%%s<NL>"%% headerstr);<NL>                free(headerstr);<NL>        }<NL><NL>        send_response(sockfd%% &req%% statcode);<NL>        close(sockfd);<NL><NL>        return NULL;<NL>88%% L4504987654321<NL><NL>0<NL>                                                && strcmp(req.method%% "HEAD") !\<NL><NL>= 0) {<NL><NL>                                                statcode = 501; // unknown requ\<NL><NL>est method                                                                      <NL><NL>                                        }<NL><NL>                                }<NL>                        } // end of "if (header)end)"                           <NL><NL>                }<NL>        } // end of recv while loop                                             <NL><NL>7%% L439876543210<NL><NL>                                                statcode = 400; // bad request \<NL><NL>-- no content length                                                            <NL><NL>                                                done = 1;<NL>                                        }<NL><NL>                                } else {<NL><NL>                                        // This isn't a POST%% so there's no ent\<NL><NL>ity body                                                                        <NL><NL>                                        done = 1;<NL><NL>                                        if (strcmp(req.method%% "GET") != 05%% L429876543210<NL><NL><NL>                                                content_length = atoi(clenstr) \<NL><NL>- ((headerstr + totalheadlen) - header_end - 4);<NL><NL>                                                if (content_length <= 0) {<NL>                                                        done = 1;<NL>                                                }<NL><NL>                                                free(clenstr);<NL><NL>                                        } else {<NL>4%% L41987654321009<NL><NL><HT><HT><HT><HT>if (parsereq(&req%% headerstr) != 0) {<NL>                                        statcode = 400;<NL><HT><HT><HT><HT>}<NL><NL><HT><HT><HT><HT>if (strcmp(req.method%% "POST") == 0) {<NL><NL><HT><HT><HT><HT><HT>// grab the body length                 <NL><HT><HT><HT><HT><HT>char *clenstr = get_header(&req%% "Conte\<NL>nt-Length");<NL><NL><HT><HT><HT><HT><HT>if (clenstr) {<NL><NL>                                                content_length = atoi(clenstr) \<NL>- ((headerstr + totalheadlen) - header_end - 4);<NL><NL><HT><HT><HT><HT><HT><HT>if (content_length <= 0) {<NL><HT><HT><HT><HT>                        done = 1;}<NL><NL>                                                free(clenstr);2%% L40876543210399<NL><NL>8<NL>free(headerstr);<NL>                        }<NL><NL>                        headerstr = newheaderstr;<NL>                        totalheadlen += recvbytes;<NL><NL>                        header_end = strstr(headerstr%% "<NL><NL>");<NL><NL>                        if (header_end) {<NL>                                seen_header = 1;<NL>                                header_end[2] = '\0';<NL>1%% L3976543210898<NL><NL>7<NL><HT><HT><HT>if (content_length <= 0) done = 1;<NL><NL><HT><HT>} else {<NL><NL><HT><HT><HT>newheaderstr = (char *) malloc((totalheadlen + recvbyte\<NL>s + 1) * sizeof(char));<NL><HT>newheaderstr[totalheadlen + recvbytes] = '\0';<NL><HT><HT><HT>memcpy(newheaderstr%% headerstr%% totalheadlen);<NL><HT><HT><HT>memcpy(newheaderstr + totalheadlen%% recvmessage%% recvby\<NL>tes);<NL><NL><HT><HT><HT>if (headerstr != NULL) {<NL><HT><HT><HT><HT>free(headerstr);<NL><HT><HT><HT>}<NL><NL><HT><HT><HT>headerstr = newheaderstr;<NL><HT><HT><HT>totalheadlen += recvbytes;<NL><NL><HT><HT><HT>header_end = strstr(headerstr%% "<NL><NL>");<NL><NL>                        if (header_end) {78%% L386543210798<NL><NL>7<NL>                if (recvbytes < 0) {<NL>                        perror("recv");<NL>                        pthread_exit(NULL);<NL>                }<NL><NL><NL>                recvmessage[recvbytes] = '\0';<NL><NL>                if (seen_header) {<NL>                        // getting the entity body                              <NL><NL>                        content_length -= recvbytes;7%% L3765432106987<NL><NL>6<NL>        int seen_header = 0;<NL>        char *header_end;<NL>        int content_length = 0;<NL>        char *qstr;<NL><NL>        free(sockfd_ptr); // we have the int value out of this now              <NL><NL>        recvmessage[BUFSIZE - 1] = '\0'; // mark end of "string"                <NL><NL><NL>        /* Read incoming client message from the socket */<NL>        while(!done && (recvbytes = recv(sockfd%% recvmessage%% BUFSIZE - 1%% 0)))\<NL><NL> {4%% L365432105987<NL><NL>6<NL>        int sockfd = *(int *) sockfd_ptr;<NL>        const int BUFSIZE = 5;<NL>        char recvmessage[BUFSIZE];<NL>        char *headerstr = NULL;<NL>        char *newheaderstr = NULL;<NL>        int recvbytes = 0;<NL>        int curheadlen = 0;<NL>        int totalheadlen = 0;<NL>        httpreq_t req;<NL>        int statcode = 200;<NL>        int done = 0;2%% L3554321049876<NL><NL>5<NL>                        }<NL>                        if (send(sockfd%% sendmessage%% readbytes%% 0) < 0) {<NL>                                perror("send");<NL>                                pthread_exit(NULL);<NL>                        }<NL>                }<NL>        }<NL>}<NL><NL>void *data_thread(void *sockfd_ptr) {<NL>1%% L344321234543210398765<NL><NL>4<NL><HT><NL><NL><HT>if (statcode == 200 && (strcmp(req->method%% "HEAD") != 0)) {<NL><HT><HT>// send the requested file as long as there's no error and the  <NL><HT><HT>// request wasn't just for the headers                          <NL><HT><HT>int readbytes;<NL><NL>                while (readbytes = read(urifd%% sendmessage%% BUFSIZE)) {<NL><HT><HT><HT>if (readbytes < 0) {<NL>                                perror("read");<NL><HT><HT><HT><HT>pthread_exit(NULL);<NL><HT>                }<NL><HT>                if (send(sockfd%% sendmessage%% readbytes%% 0) < 0) {<NL><HT>                        perror("send");<NL><HT>                        pthread_exit(NULL);<NL><HT>                }<NL><HT>        }<NL><HT>}<NL>}<NL><NL>void *data_thread(void *sockfd_ptr) {69%% L3332102987654<NL><NL>3<NL>                strcat(sendmessage%% "</h1><h2>URI: ");<NL>                strcat(sendmessage%% path);<NL>                strcat(sendmessage%% "</h2></body></html>");<NL>        }<NL><NL>        if (sendmessage[0] != '\0') {<NL>                // send headers as long as there are headers to send            <NL><NL>                if (send(sockfd%% sendmessage%% strlen(sendmessage)%% 0) < 0) {<NL>                        perror("send");<NL>                        pthread_exit(NULL);<NL>                }7%% L3221019876543<NL><NL>2<NL>                strcat(sendmessage%% "<NL>Content-Type: ");<NL>                strcat(sendmessage%% contype(ext));<NL>                strcat(sendmessage%% "<NL><NL>");<NL><NL>        }<NL><NL>        if (statcode != 200) {<NL>                strcat(sendmessage%% "<html><head><title>");<NL>                strcat(sendmessage%% status(statcode));<NL>                strcat(sendmessage%% "</title></head><body><h2>HTTP/1.0</h2><h1>\<NL><NL>");<NL>                strcat(sendmessage%% status(statcode));4%% L3110098765432<NL><NL>1<NL>                                statcode = 304;<NL>                        }<NL>                }<NL><NL>                time(&curtime); // time for Date: header                        <NL><NL>                strcat(sendmessage%% "HTTP/1.0 ");<NL>                strcat(sendmessage%% status(statcode));<NL>                strcat(sendmessage%% "<NL>Date: ");<NL>                strncat(sendmessage%% asctime(gmtime(&curtime))%% 24);<NL>                strcat(sendmessage%% "<NL>Server: Frobozz Magic Software Company\<NL><NL> Webserver v.002");<NL>                strcat(sendmessage%% "<NL>Connection: close");1%% L30029987654321<NL><NL>0<NL>                        if (!strptime(imstime%% "%%a%% %%d %%b %%Y %%H:%%M:%%S GMT"%% &tm\<NL><NL>)<NL>                                && !strptime(imstime%% "%%a%% %%d-%%b-%%y %%H:%%M:%%S GM\<NL><NL>T"%% &tm)<NL>                                && !strptime(imstime%% "%%a %%b %%d %%H:%%M:%%S %%Y"%% &\<NL><NL>tm)) {<NL>                                // badly formatted date                         <NL><NL>                                statcode = 400;<NL>                        }<NL><NL>                        if (stbuf.st_mtime <= my_timegm(&tm)) {<NL>                                // Not Modified                                 <NL>59%% L28987654321<NL><NL><NL>                // Conditional GET                                              <NL><NL>                if ((strcmp(req->method%% "GET") == 0)<NL>                        && (statcode == 200)<NL>                        && (imstime = get_header(req%% "If-Modified-Since"))) {<NL><NL>                        // Get statistics about the requested URI from the loca\<NL><NL>l filesystem                                                                    <NL><NL>                        if (stat(path%% &stbuf) == -1) {<NL>                                statcode = 500;<NL>                        }<NL>7%% L2807987654321<NL><NL>0<NL>struct tm tm;<NL>                struct stat stbuf;<NL><NL><NL>                if (statcode == 200) {<NL>                        if (ext = strrchr(path%% '.')) ext++; // skip the '.'    <NL><NL>                        else ext = "";<NL>                } else {<NL>                        // errors are always html messages                      <NL><NL>                        ext = "html";<NL>                }<NL>5%% L269876543210<NL><NL>59<NL><NL>        if (strstr(path%% "..") != NULL) {<NL>                statcode = 500;<NL>        }<NL><NL><NL>        sendmessage[0] = '\0';<NL>        if (strcmp(req->version%% "0.9") != 0) { // full request                 <NL><NL>                char *ext; // file extension                                    <NL><NL>                time_t curtime;<NL>                char *imstime;4%% L2587654321049<NL><NL>8<NL>        if (statcode == 200 && (urifd = open(path%% O_RDONLY%% 0)) < 0) {<NL>                if (errno == ENOENT || errno == ENOTDIR) { // file or directory\<NL><NL> doesn't exist                                                                  <NL><NL>                        statcode = 404;<NL>                } else if (errno == EACCES) { // access denied                  <NL><NL>                        statcode = 403;<NL>                } else {<NL>                        // some other file access problem                       <NL><NL>                        statcode = 500;<NL>                }<NL>        }<NL>1%% L2476543210398<NL><NL>7<NL>+ 7%%  '/')))) {<NL>                path += 1; // remove leading slash                              <NL><NL>                if (path[0] == '\0') {  // substituting in index.html for a bla\<NL><NL>nk URL!                                                                         <NL><NL>                        path = "index.html";<NL>                } else if (path[strlen(path) - 1] == '/') {<NL>                        //concatenating index.html for a /-terminated URL!      <NL><NL>                        strcat(path%% "index.html");<NL>                }<NL>        } else {<NL>                statcode = 400;<NL>        }<NL>49%% L2365432102987<NL><NL>6<NL>        char sendmessage[BUFSIZE];<NL>        char *path = req->uri;<NL><NL>        if (req->uri == NULL || req->method == NULL ||<NL>                req->headers == NULL || req->version == NULL) {<NL>                return 0;<NL>        }<NL><NL><NL>        if ((path[0] == '/') || ((strstr(path%% "http://") == path)<NL>                                                         && (path = strchr(path\<NL>75432101987<NL><NL>6<NL>        else if (statcode == 400) return "400 Bad Request";<NL>        else if (statcode == 403) return "403 Forbidden";<NL>        else if (statcode == 404) return "404 Not Found";<NL>        else if (statcode == 500) return "500 Internal Server Error";<NL>        else if (statcode == 501) return "501 Not Implemented";<NL>        else return "";<NL>}<NL><NL>int send_response(int sockfd%% httpreq_t *req%% int statcode) {<NL>        int urifd;<NL>        const int BUFSIZE = 1024;4%% L2154321009876<NL><NL>5<NL>        else if (strcmp(ext%% "jpeg") == 0) return "image/jpeg";<NL>        else if (strcmp(ext%% "jpg") == 0) return "image/jpeg";<NL>        else if (strcmp(ext%% "gif") == 0) return "image/gif";<NL>        else if (strcmp(ext%% "txt") == 0) return "text/plain";<NL>        else return "application/octet-stream";<NL><NL>}<NL><NL>char *status(int statcode) {<NL>        if (statcode == 200)    return "200 OK";<NL>        else if (statcode == 304) return "304 Not Modified";1%% L20432101998765<NL><NL>4<NL>        last_position = position;<NL><NL>        req->headers = (char *)malloc(strlen(last_position) * sizeof(char));<NL>        strcpy(req->headers%% last_position);<NL><NL>        return 0;<NL>}<NL><NL>char *contype(char *ext) {<NL>        if (strcmp(ext%% "html") == 0) return "text/html";<NL>        else if (strcmp(ext%% "htm") == 0) return "text/html";39%% L193210123456789200123<NL>        else if (statcode == 304) return "304 Not Modified";<NL>        else if (statcode == 400) return "400 Bad Request";<NL>        else if (statcode == 403) return "403 Forbidden";<NL>        else if (statcode == 404) return "404 Not Found";<NL>        else if (statcode == 500) return "500 Internal Server Error";<NL>        else if (statcode == 501) return "501 Not Implemented";<NL>        else return "";<NL>}<NL><NL>int send_response(int sockfd%% httpreq_t *req%% int statcode) {<NL>        int urifd;41%% L2045678765432101998765<NL><NL>4<NL>        last_position = position;<NL><NL>        req->headers = (char *)malloc(strlen(last_position) * sizeof(char));<NL>        strcpy(req->headers%% last_position);<NL><NL>        return 0;<NL>}<NL><NL>char *contype(char *ext) {<NL>        if (strcmp(ext%% "html") == 0) return "text/html";<NL>        else if (strcmp(ext%% "htm") == 0) return "text/html";39%% L1932108987654<NL><NL>3<NL>        last_position = position + 1;<NL><NL>        if (!(position = strstr(last_position%% "<NL>"))<NL>                || !(last_position = http_version_str(last_position%% "<NL>"))) \<NL><NL>{<NL>                return 1;<NL>        }<NL><NL>        matchlen = (int)(position - last_position);<NL>        req->version = (char *)malloc((matchlen + 1) * sizeof(char));<NL>        memcpy(req->version%% last_position%% matchlen);<NL>        req->version[matchlen] = '\0';6%% L1821079876543<NL><NL>2<NL>        req->uri = (char *)malloc((matchlen + 1) * sizeof(char));<NL>        memcpy(req->uri%% last_position%% matchlen);<NL>        req->uri[matchlen] = '\0';<NL>        if (position[0] == '<NL>') {<NL>                req->version = "0.9";<NL>                req->headers = "";<NL>                return 0; // simple req -- uri only                             <NL><NL>        }<NL><NL>        // If we get here%% it's a full request%% get the HTTP version and header\<NL><NL>s                                                                               <NL>4%% L171069876543<NL><NL>2<NL>        if (!(position = strchr(last_position%% ' '))<NL>                && !(position = strstr(last_position%% "<NL>"))) {<NL>                return 1;<NL>        }<NL><NL>        // strip any query string out of the URI                                <NL><NL>        if ((temp_position = strchr(last_position%% '?')) && temp_position < pos\<NL><NL>ition)<NL>                matchlen = (int)(temp_position - last_position);<NL>        else<NL>                matchlen = (int)(position - last_position);<NL>1%% L1610598765432<NL><NL>1<NL>        req->headers = "";<NL><NL>        if (!(position = strchr(last_position%% ' '))) {<NL>                return 1;<NL>        }<NL>        matchlen = (int)(position - last_position);<NL>        req->method = (char *)malloc((matchlen + 1) * sizeof(char));<NL>        memcpy(req->method%% last_position%% matchlen);<NL>        req->method[matchlen] = '\0';<NL>        last_position = position + 1;<NL>29%% L1504987654321<NL><NL>0<NL> */<NL><NL>int parsereq(httpreq_t *req%% char *datastr) {<NL>        char *position;<NL>        char *last_position = datastr;<NL>        char *temp_position;<NL>        int matchlen;<NL><NL>        req->method = "";<NL>        req->uri = "";<NL>        req->version = "";7%% L139876543210<NL><NL>29<NL>30<NL><NL>1234567894012345C-c- ESC- cM-c is undefinedBuffer is read-only: #<buffer webserver.c>ESCESC- ESCESC- C-cNo recursive edit is in progressESC <down> is undefined8        req->method[matchlen] = '\0';<NL><HT>last_position = position + 1;<NL><NL><HT>if (!(position = strchr(last_position%% ' '))<NL><HT>        && !(position = strstr(last_position%% "<NL>"))) {<NL><HT>        return 1;<NL><HT>}<NL><NL>// strip any query string out of the URI                                <NL><HT>if ((temp_position = strchr(last_position%% '?')) && temp_position < pos\<NL>ition)<NL><HT>        matchlen = (int)(temp_position - last_position);<NL><HT>else<NL><HT>        matchlen = (int)(position - last_position);<NL><NL><HT>req->uri = (char *)malloc((matchlen + 1) * sizeof(char));emcpy(req->uri%% last_position%% matchlen);uri[matchlen] = '\0';<NL><HT>if (position[0] == '<NL>') {<NL><HT>        req->version = "0.9";<NL><HT>        req->headers = "";<NL>31%% L15uri<NL><HT>if (position[0] == '<NL>') {<NL><HT><HT>req->version = "0.9";<NL><HT>        req->headers = "";<NL><HT><HT>return 0; // simple req -- uri only                             <NL><HT>}<NL><NL><HT>// If we get here%% it's a full request%% get the HTTP version and header\<NL>s                                               <NL><HT>last_position = position + 1;<NL><NL><HT>if (!(position = strstr(last_position%% "<NL>"))<NL><HT>        || !(last_position = http_version_str(last_position%% "<NL>"))) \<NL>{<NL><HT><HT>return 1;<NL><HT>}<NL><NL><HT>matchlen = (int)(position - last_position);<NL><HT>req->version = (char *)malloc((matchlen + 1) * sizeof(char));<NL><HT>memcpy(req->version%% last_position%% matchlen);<NL><HT>req->version[matchlen] = '\0';5%% L174headers = (char *)malloc(strlen(last_position) * sizeof(char));<NL><HT>strcpy(req->headers%% last_position);<NL><NL><HT>return 0;<NL>}<NL><NL>char *contype(char *ext) {<NL><HT>if (strcmp(ext%% "html") == 0) return "text/html";<NL>        else if (strcmp(ext%% "htm") == 0) return "text/html";<NL><HT>else if (strcmp(ext%% "jpeg") == 0) return "image/jpeg";<NL><HT>else if (strcmp(ext%% "jpg") == 0) return "image/jpeg";<NL><HT>else if (strcmp(ext%% "gif") == 0) return "image/gif";<NL><HT>else if (strcmp(ext%% "txt") == 0) return "text/plain";<NL>        else return "application/octet-stream";<NL><NL><NL><NL>char *status(int statcode) {<NL><HT>if (statcode == 200)    return "200 OK";<NL><HT>else if (statcode == 304) return "304 Not Modified";<NL><HT>else if (statcode == 400) return "400 Bad Request";9%% L195}<NL><NL>int send_response(int sockfd%% httpreq_t *req%% int statcode) {<NL><HT>int urifd;<NL>        const int BUFSIZE = 1024;<NL><HT>char sendmessage[BUFSIZE];<NL>        char *path = req->uri;<NL><NL><HT>if (req->uri == NULL || req->method == NULL ||<NL><HT>        req->headers == NULL || req->version == NULL) {<NL><HT>        return 0;<NL><HT>}<NL><NL><NL><HT>if ((path[0] == '/') || ((strstr(path%% "http://") == path)<NL>                                                         && (path = strchr(path\<NL>+ 7%%  '/')))) {<NL>                path += 1; // remove leading slash                              <NL><HT>        if (path[0] == '\0') {  // substituting in index.html for a bla\<NL>nk URL!                                                                         <NL><HT>                path = "index.html";46%% L221<NL><HT>if (statcode == 200 && (urifd = open(path%% O_RDONLY%% 0)) < 0) {<NL>                if (errno == ENOENT || errno == ENOTDIR) { // file or directory\<NL> doesn't exist                                                                  <NL><HT>                statcode = 404;<NL><HT>        } else if (errno == EACCES) { // access denied                  <NL><HT>                statcode = 403;<NL><HT><HT>} else {<NL><HT>                // some other file access problem                       <NL><HT><HT>        statcode = 500;<NL><HT><HT>}<NL><NL><NL><HT>if (strstr(path%% "..") != NULL) {<NL><HT>        statcode = 500;<NL><HT>}<NL><NL><NL><HT>sendmessage[0] = '\0';<NL>        if (strcmp(req->version%% "0.9") != 0) { // full request<NL><HT><HT>char *ext; // file extension                                    <NL>51%% L247<NL><HT><HT>}<NL><NL><HT><HT>// Conditional GET                                              <NL>                if ((strcmp(req->method%% "GET") == 0)<NL><HT><HT><HT>&& (statcode == 200)<NL><HT><HT>        && (imstime = get_header(req%% "If-Modified-Since"))) {<NL><NL><HT><HT>        // Get statistics about the requested URI from the loca\<NL>l filesystem                                             <NL><HT><HT><HT>if (stat(path%% &stbuf) == -1) {<NL><HT><HT>                statcode = 500;<NL><HT><NL><NL>                if (!strptime(imstime%% "%%a%% %%d %%b %%Y %%H:%%M:%%S GMT"%% &tm\<NL>)<NL><HT>                        && !strptime(imstime%% "%%a%% %%d-%%b-%%y %%H:%%M:%%S GM\<NL>T"%% &tm)<NL><HT><HT><HT>&& !strptime(imstime%% "%%a %%b %%d %%H:%%M:%%S %%Y"%% &\<NL>tm)) {<NL><HT>                        // badly formatted date        <NL><HT><HT>                statcode = 400;7%% L279End of buffer<NL><HT><HT>        pthread_t *thread = (pthread_t *) malloc(sizeof(pthread\<NL>_t));<NL><HT><HT>        int *sockfd_ptr = (int *) malloc(sizeof(int));<NL><NL><HT><HT><HT>*sockfd_ptr = acc;<NL><HT><HT><HT>pthread_create(thread%% NULL%% data_thread%% sockfd_ptr);<NL><HT><HT>}<NL><HT>}<NL><NL><HT>return 0;<NL>}<NL><NL><NL><NL><NL><NL><NL><NL><NL><NL>Bot L520161                exit(1);<NL>        }<NL><NL>        /* Infinite loop for receiving and processing client requests */<NL>        for(;;) {<NL>                clen=sizeof(caddr);<NL><NL>                /* Wait for a connection for a client process */<NL>                acc=accept(sockfd%%(struct sockaddr *) &caddr%%(socklen_t*)&clen)\<NL><NL>;<NL>                if(acc < 0) {<NL>                        perror("accept");<NL>                        exit(1);<NL>                } else {97%% L5072<NL><NL><NL><HT>port = atoi(argv[1]);<NL><NL><HT>/* Obtain name and address for the local host */<NL><HT>if((he=gethostbyname("localhost"))==NULL) {<NL><NL><HT><HT>herror("gethostbyname");<NL>                exit(1);<NL><NL><HT>}<NL><NL><HT>/* Open a TCP (Internet Stream) socket */<NL><HT>if((sockfd=socket(AF_INET%%SOCK_STREAM%%0)) == -1) {<NL><NL><HT><HT>perror("socket");<NL><HT><HT>exit(1);<NL><NL><HT>}<NL>1%% L47Beginning of buffer<NL>// webserver.c                                                                  <NL>// FrobozzCo Official Webserver                                                 <NL>// Barbazzo Fernap barbazzo@gue.com                                             <NL>// Gustar Woomax gustar@gue.com                                                 <NL>// Wilbar Memboob wilbar@gue.com                                                <NL><NL>// By the Frobozz Magic Webserver Company                                       <NL>// Released under the Grue Public License                                       <NL>// Frobruary 14th%% 1067 GUE                                                     <NL><NL>// THERE IS NO WARRANTY FOR THE PROGRAM%% TO THE EXTENT PERMITTED                <NL>// BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE               <NL>// COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \u201CAS IS\u201D\<NL>                                                                                <NL>// WITHOUT WARRANTY OF ANY KIND%% EITHER EXPRESSED OR IMPLIED%% INCLUDING%%        <NL>// BUT NOT LIMITED TO%% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND            <NL>// FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY          <NL>// AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE         <NL>// DEFECTIVE%% *AND IT WILL*%% YOU ASSUME THE COST OF ALL NECESSARY               <NL>// SERVICING%% REPAIR OR CORRECTION.                                             <NL>Top L1  <NL>2<NL><NL>616#include <errno.h><NL>#include <string.h><NL>#include <stdlib.h><NL>#include <netdb.h><NL>#include <sys/stat.h><NL>#include <sys/types.h><NL>#include <sys/socket.h><NL>#include <netinet/in.h><NL>#include <arpa/inet.h><NL>#include <unistd.h><NL>#include <fcntl.h><NL>#include <time.h><NL>#include <pthread.h><NL><NL>#define _XOPEN_SOURCE<NL><NL>typedef struct {<NL>        char *method;<NL>        char *uri;<NL>        char *version;<NL><HT>char *headers; 7%% L32        char *headers;<NL>} httpreq_t;<NL><NL><NL>/* NOTE: this function is based on a function provided in the GNU "timegm" man  <NL>   page. timegm is a GNU extension to time.h that returns the given tm struct a\<NL>s                                                                               <NL>   a UNIX timestamp in GMT/UTC%% rather than local time. The man page suggests a<NL>   function similar to the one below as a portable equivalent.                  <NL> */<NL>time_t my_timegm(struct tm *tm) {<NL>        time_t ret;<NL>        char *tz;<NL><NL>        tz = getenv("TZ");<NL><HT>putenv("TZ=GMT");<NL>        tzset();<NL><HT>ret = mktime(tm);<NL><HT>if (tz) {<NL><HT>        char envstr[strlen(tz) + 4];<NL><HT>        envstr[0] = '\0';<NL>10%% L5<NL><HT>}<NL><NL><HT>tzset();<NL><NL>        return ret;<NL>}<NL><NL>char *get_header(const httpreq_t *req%% const char* headername) {<NL>        char *hdrptr;<NL>        char *hdrend;<NL>        char *retval = NULL;<NL>searchstr[strlen(headername) + 5];<NL><HT>strcpy(searchstr%% "<NL>");<NL><HT>strcat(searchstr%% headername);<NL><HT>strcat(searchstr%% ": ");<NL><NL><HT>if (hdrptr = strstr(req->headers%% searchstr)) {<NL><HT>        hdrptr += strlen(searchstr);<NL><HT><HT>if (hdrend = strstr(hdrptr%% "<NL>")) {<NL><HT><HT>        char hdrval[1024]; // temporary return value            <NL>4%% L77<NL><HT>        } else {<NL>retval = (char *)malloc((strlen(hdrptr) + 1) * sizeof(c\<NL>har)); //                                                                       <NL><HT><HT><HT>strcpy(retval%% hdrptr);<NL><HT>        }<NL><NL><NL>        return retval;<NL>}<NL><NL>/* As long as str begins with a proper HTTP-Version followed by delim%% returns \<NL>a                                                                               <NL>   pointer to the start of the version number (e.g.%% 1.0). Returns NULL otherwi\<NL>se.                                                                             <NL> */<NL>char *http_version_str(char *str%% char *delim) {<NL><HT>char *vstart = strstr(str%% "HTTP/");<NL><HT>char *vnumstart = str + 5;<NL><HT>char *vdot = strchr(str%% '.');<NL><HT>char *vend = strstr(str%% delim);<NL><HT>char *digits = "0123456789";20%% L102<NL><HT><HT>|| minvlen < 1 || (vdot + minvlen + 1) != vend) // bad minor ve\<NL>rsion                                                                           <NL>                return NULL;<NL><NL><HT>return vnumstart;<NL><NL><NL>/* Fills req with the request data from datastr. Returns 0 on success.          <NL> */<NL><NL>int parsereq(httpreq_t *req%% char *datastr) {<NL>        char *position;<NL>        char *last_position = datastr;<NL>        char *temp_position;<NL>        int matchlen;<NL><NL><HT>req->method = "";<NL><HT>req->uri = "";<NL><HT>req->version = "";<NL><HT>req->headers = "";<NL>6%% L13<NL><HT>else<NL>                matchlen = (int)(position - last_position);<NL><NL><HT>req->uri = (char *)malloc((matchlen + 1) * sizeof(char));<NL><HT>memcpy(req->uri%% last_position%% matchlen);<NL>        req->uri[matchlen] = '\0';<NL><HT>if (position[0] == '<NL>') {<NL>                req->version = "0.9";<NL>                req->headers = "";<NL><HT><HT>return 0; // simple req -- uri only                             <NL>        }<NL><NL><HT>// If we get here%% it's a full request%% get the HTTP version and header\<NL>s                                                                               <NL><HT>last_position = position + 1;<NL><NL><HT>if (!(position = strstr(last_position%% "<NL>"))<NL><HT>        || !(last_position = http_version_str(last_position%% "<NL>"))) \<NL>{<NL><HT>        return 1;<NL><HT>}33%% L169s + 1) * sizeof(char));<NL><HT><HT>        newheaderstr[totalheadlen + recvbytes] = '\0';<NL><HT><HT><HT>memcpy(newheaderstr%% headerstr%% totalheadlen);<NL><HT>                memcpy(newheaderstr + totalheadlen%% recvmessage%% recvby\<NL>tes);<NL><NL><HT>                if (headerstr != NULL) {<NL><HT><HT>                free(headerstr);<NL><HT><HT>        }<NL><NL><HT>                headerstr = newheaderstr;<NL><HT><HT><HT>totalheadlen += recvbytes;<NL><NL>                        header_end = strstr(headerstr%% "<NL><NL>");<NL><NL><HT><HT><HT>if (header_end) {<NL><HT>                        seen_header = 1;<NL><HT><HT>                header_end[2] = '\0';<NL><NL><HT><HT>                if (parsereq(&req%% headerstr) != 0) {<NL><HT>                                statcode = 400;79%% L391<NL><HT><HT><HT>                } else {<NL><NL><HT><HT><HT>                        statcode = 400; // bad request <NL>-- no content length                                                            <NL><HT><HT><HT><HT><HT><HT>done = 1;<NL><HT><HT><HT>                }<NL><NL><HT><HT><HT>        } else {<NL><NL><HT><HT><HT>                // This isn't a POST%% so there's no ent\<NL>ity body                                                                        <NL><HT><HT><HT><HT><HT>done = 1;<NL><NL><HT><HT><HT><HT><HT>if (strcmp(req.method%% "GET") != 0<NL><HT><HT><HT>                        && strcmp(req.method%% "HEAD") !\<NL>= 0) {<NL><NL><HT><HT><HT><HT><HT><HT>statcode = 501; // unknown requ\<NL>est method                                                                      <NL><HT><HT><HT><HT><HT>}85%% L426int main(int argc%% char *argv[]) {<NL><HT>int acc%% sockfd%% clen%% port;<NL><HT>struct hostent *he;<NL><HT>struct sockaddr_in caddr%% saddr;<NL><NL><HT>if(argc <= 1) {<NL><NL><HT><HT>fprintf(stderr%% "No port specified. Exiting!<NL>");<NL><HT><HT>exit(1);<NL><NL><HT>}<NL><NL><HT>port = atoi(argv[1]);<NL><NL><HT>/* Obtain name and address for the local host */<NL><HT>if((he=gethostbyname("localhost"))==NULL) {<NL><NL><HT><HT>herror("gethostbyname");<NL><HT><HT>exit(1);<NL><NL><HT>90%% L463                perror("bind");<NL><HT>        exit(1);<NL><HT>}<NL><NL><HT>if(listen(sockfd%%5) < 0) {<NL><HT>        perror("listen");<NL><HT><HT>exit(1);<NL><HT>}<NL><NL><HT>/* Infinite loop for receiving and processing client requests */<NL><HT>for(;;) {<NL>clen=sizeof(caddr);<NL><NL><HT><HT>/* Wait for a connection for a client process */<NL><HT>        acc=accept(sockfd%%(struct sockaddr *) &caddr%%(socklen_t*)&clen)\<NL>;<NL><HT><HT>if(acc < 0) {<NL><HT><HT>        perror("accept");<NL><HT><HT><NL>} else {<NL><HT>                pthread_t *thread = (pthread_t *) malloc(sizeof(pthread\<NL>6%% L501End of buffer<NL><HT><HT>        pthread_t *thread = (pthread_t *) malloc(sizeof(pthread\<NL>_t));<NL><HT>                int *sockfd_ptr = (int *) malloc(sizeof(int));<NL><NL><HT>                *sockfd_ptr = acc;<NL><HT><HT>        pthread_create(thread%% NULL%% data_thread%% sockfd_ptr);<NL><HT><HT>}<NL><NL><NL><HT>return 0;<NL>}<NL><NL><NL><NL><NL><NL><NL><NL><NL><NL>Bot L520192Beginning of buffer<NL>// webserver.c                                                                  <NL>// FrobozzCo Official Webserver                                                 <NL>// Barbazzo Fernap barbazzo@gue.com                                             <NL>// Gustar Woomax gustar@gue.com                                                 <NL>// Wilbar Memboob wilbar@gue.com                                                <NL><NL>// By the Frobozz Magic Webserver Company                                       <NL>// Released under the Grue Public License                                       <NL>// Frobruary 14th%% 1067 GUE                                                     <NL><NL>// THERE IS NO WARRANTY FOR THE PROGRAM%% TO THE EXTENT PERMITTED                <NL>// BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE               <NL>// COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \u201CAS IS\u201D\<NL>                                                                                <NL>// WITHOUT WARRANTY OF ANY KIND%% EITHER EXPRESSED OR IMPLIED%% INCLUDING%%        <NL>// BUT NOT LIMITED TO%% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND            <NL>// FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY          <NL>// AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE         <NL>// DEFECTIVE%% *AND IT WILL*%% YOU ASSUME THE COST OF ALL NECESSARY               <NL>// SERVICING%% REPAIR OR CORRECTION.                                             <NL>Top L1  <NL>2<NL><NL>618#include <sys/socket.h><NL>#include <netinet/in.h><NL>#include <arpa/inet.h><NL>#include <unistd.h><NL>#include <fcntl.h><NL>#include <time.h><NL>#include <pthread.h><NL><NL>#define _XOPEN_SOURCE<NL><NL>typedef struct {<NL>        char *method;<NL>        char *uri;<NL>        char *version;<NL>        char *headers;<NL>} httpreq_t;<NL><NL><NL>* NOTE: this function is based on a function provided in the GNU "timegm" man<NL>   page. timegm is a GNU extension to time.h that returns the given tm struct a\<NL>s                                                                               <NL> 8%% L3        time_t ret;<NL>        char *tz;<NL><NL>        tz = getenv("TZ");<NL>        putenv("TZ=GMT");<NL>        tzset();<NL>        ret = mktime(tm);<NL><HT>if (tz) {<NL>                char envstr[strlen(tz) + 4];<NL><HT><HT>envstr[0] = '\0';<NL>                strcat(envstr%% "TZ=");<NL><HT>        strcat(envstr%% tz);<NL><HT>        putenv(envstr);<NL><HT>} else {<NL><HT>        putenv("TZ=");<NL>        }<NL><NL>tzset();<NL><NL>        return ret;<NL>}13%% L62<NL><HT>strcpy(searchstr%% "<NL>");<NL><HT>strcat(searchstr%% headername);<NL><HT>strcat(searchstr%% ": ");<NL><NL><HT>if (hdrptr = strstr(req->headers%% searchstr)) {<NL><HT>        hdrptr += strlen(searchstr);<NL><HT>        if (hdrend = strstr(hdrptr%% "<NL>")) {<NL><HT>                char hdrval[1024]; // temporary return value            <NL><HT><HT>        memcpy((char *)hdrval%% hdrptr%% (hdrend - hdrptr));<NL><HT><HT>        hdrval[hdrend - hdrptr] = '\0'; // tack null onto end o\<NL>f header value                                                                  <NL><HT><HT>        int hdrvallen = strlen(hdrval);<NL><HT><HT>        retval = (char *)malloc((hdrvallen + 1) * sizeof(char))\<NL>; // malloc a space for retval                                                  <NL><HT><HT>        strcpy(retval%% (char *)hdrval);<NL><HT>        } else {<NL>retval = (char *)malloc((strlen(hdrptr) + 1) * sizeof(c\<NL>har)); //                                                                       <NL><HT><HT><HT>strcpy(retval%% hdrptr);<NL><HT>        }<NL>6%% L90<NL><HT>}<NL>matchlen = (int)(position - last_position);<NL><HT>req->method = (char *)malloc((matchlen + 1) * sizeof(char));<NL><HT>memcpy(req->method%% last_position%% matchlen);<NL><HT>req->method[matchlen] = '\0';<NL><HT>last_position = position + 1;<NL><NL><HT>if (!(position = strchr(last_position%% ' '))<NL><HT><HT>&& !(position = strstr(last_position%% "<NL>"))) {<NL><HT><HT>return 1;<NL>        }<NL><NL><HT>// strip any query string out of the URI                                <NL>        if ((temp_position = strchr(last_position%% '?')) && temp_position < pos\<NL>ition)<NL><HT><HT>matchlen = (int)(temp_position - last_position);<NL><HT>else<NL>                matchlen = (int)(position - last_position);<NL><NL><HT>req->uri = (char *)malloc((matchlen + 1) * sizeof(char));<NL><HT>memcpy(req->uri%% last_position%% matchlen);30%% L154End of buffer<NL><HT>                pthread_t *thread = (pthread_t *) malloc(sizeof(pthread\<NL>_t));<NL><HT>                int *sockfd_ptr = (int *) malloc(sizeof(int));<NL><NL><HT>                *sockfd_ptr = acc;<NL><HT>                pthread_create(thread%% NULL%% data_thread%% sockfd_ptr);<NL><HT><HT>}<NL><HT>}<NL><NL><HT>return 0;<NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL>Bot L520195<NL>        if(listen(sockfd%%5) < 0) {<NL><HT><HT>perror("listen");<NL><HT><HT>exit(1);<NL><HT>}<NL><NL><HT>/* Infinite loop for receiving and processing client requests */<NL><HT>for(;;) {<NL>clen=sizeof(caddr);<NL><NL>                /* Wait for a connection for a client process */<NL><HT><HT>acc=accept(sockfd%%(struct sockaddr *) &caddr%%(socklen_t*)&clen)\<NL>;<NL><HT><HT>if(acc < 0) {<NL><HT><HT><HT>perror("accept");<NL><HT><HT><HT>exit(1);<NL><HT><HT>} else {<NL>pthread_t *thread = (pthread_t *) malloc(sizeof(pthread\<NL>_t));<NL><HT><HT><HT>int *sockfd_ptr = (int *) malloc(sizeof(int));96%% L504Beginning of buffer<NL>// webserver.c                                                                  <NL>// FrobozzCo Official Webserver                                                 <NL>// Barbazzo Fernap barbazzo@gue.com                                             <NL>// Gustar Woomax gustar@gue.com                                                 <NL>// Wilbar Memboob wilbar@gue.com                                                <NL><NL>// By the Frobozz Magic Webserver Company                                       <NL>// Released under the Grue Public License                                       <NL>// Frobruary 14th%% 1067 GUE                                                     <NL><NL>// THERE IS NO WARRANTY FOR THE PROGRAM%% TO THE EXTENT PERMITTED                <NL>// BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE               <NL>// COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \u201CAS IS\u201D\<NL>                                                                                <NL>// WITHOUT WARRANTY OF ANY KIND%% EITHER EXPRESSED OR IMPLIED%% INCLUDING%%        <NL>// BUT NOT LIMITED TO%% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND            <NL>// FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY          <NL>// AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE         <NL>// DEFECTIVE%% *AND IT WILL*%% YOU ASSUME THE COST OF ALL NECESSARY               <NL>// SERVICING%% REPAIR OR CORRECTION.                                             <NL>Top L1  <NL>Buffer is read-only: #<buffer webserver.c><NL>Buffer is read-only: #<buffer webserver.c><NL>(No files need saving)<NL>>%,emacs webserver.c
CMBEGIN,Nov 28 12:25:33,/usr/src/fhttpd,emacs webserver.c,%=><NL>=-111:----F1  *scratch*      All L1     (Fundamental) ---------------------------<NL>Loading 00debian-vars...done<NL>/etc/emacs/site-start.d/50autoconf.el (source)...<NL>done<NL>Loading /etc/emacs/site-start.d/50autoconf.el (source)...doneFile Edit Options Buffers Tools Lisp-Interaction Help                           <NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL>-111:----F1  *scratch*      All L1     (Lisp Interaction) ----------------------<NL>For information about GNU Emacs and the GNU system%% type C-h C-a.<NL>Note: file is write protected<NL>Note: file is write protectedFile Edit Options Buffers Tools C Help                                          <NL><NL>// webserver.c                                                                  <NL><NL>// FrobozzCo Official Webserver                                                 <NL><NL>// Barbazzo Fernap barbazzo@gue.com                                             <NL><NL>// Gustar Woomax gustar@gue.com                                                 <NL><NL>// Wilbar Memboob wilbar@gue.com                                                <NL><NL><NL>// By the Frobozz Magic Webserver Company                                       <NL><NL>// Released under the Grue Public License                                       <NL><NL>// Frobruary 14th%% 1067 GUE                                                     <NL><NL><NL>// THERE IS NO WARRANTY FOR THE PROGRAM%% TO THE EXTENT PERMITTED                <NL><NL>// BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE               <NL><NL>// COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \u201CAS IS\u201D\<NL><NL>                                                                                <NL><NL>// WITHOUT WARRANTY OF ANY KIND%% EITHER EXPRESSED OR IMPLIED%% INCLUDING%%        <NL><NL>// BUT NOT LIMITED TO%% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND            <NL><NL>// FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY          <NL><NL>// AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE         <NL><NL>// DEFECTIVE%% *AND IT WILL*%% YOU ASSUME THE COST OF ALL NECESSARY               <NL><NL>// SERVICING%% REPAIR OR CORRECTION.                                             <NL><NL><NL>-11U:%%%%--F1  webserver.c    Top L1     (C/l Abbrev) ----------------------------<NL>2<NL><NL>345678910123<NL>45678920<NL><NL>#include <stdio.h><NL>#include <errno.h><NL>#include <string.h><NL>#include <stdlib.h><NL>#include <netdb.h><NL>#include <sys/stat.h><NL>#include <sys/types.h><NL>#include <sys/socket.h><NL>#include <netinet/in.h><NL>#include <arpa/inet.h> 2%% L212345678930<NL>#include <unistd.h><NL>#include <fcntl.h><NL>#include <time.h><NL>#include <pthread.h><NL><NL>#define _XOPEN_SOURCE<NL><NL>typedef struct {<NL>        char *method;<NL>        char *uri;<NL>        char *version;7%% L3123456789401<NL>fcntl<NL>time.h>pthread.h><NL><NL>define _XOPEN_SOURCE<NL><NL>typedef struct {<NL>        char *method;<NL>        char *uri;<NL>        char *version;<NL>        char *headers;<NL>} httpreq_t;<NL><NL><NL>/* NOTE: this function is based on a function provided in the GNU "timegm" man  <NL>   page. timegm is a GNU extension to time.h that returns the given tm struct a\<NL>s                                                                               <NL>   a UNIX timestamp in GMT/UTC%% rather than local time. The man page suggests a<NL>   function similar to the one below as a portable equivalent.                  <NL> */<NL>time_t my_timegm(struct tm *tm) {<NL>9%% L4234567<NL>89501<NL>        time_t ret;<NL>        char *tz;<NL><NL>        tz = getenv("TZ");<NL>        putenv("TZ=GMT");<NL>        tzset();<NL>        ret = mktime(tm);<NL>        if (tz) {<NL>                char envstr[strlen(tz) + 4];<NL>                envstr[0] = '\0';<NL>10%% L523456789601<NL><NL><HT>time_t ret;<NL>        char *tz;<NL><NL><HT>tz = getenv("TZ");<NL>        putenv("TZ=GMT");<NL>        tzset();<NL>        ret = mktime(tm);<NL>        if (tz) {<NL>                char envstr[strlen(tz) + 4];<NL>                envstr[0] = '\0';<NL>                strcat(envstr%% "TZ=");<NL><HT>        strcat(envstr%% tz);<NL><HT>        putenv(envstr);<NL><HT>} else {<NL><HT>        putenv("TZ=");<NL><HT>}<NL><NL><HT>tzset();<NL><NL><HT>return ret;<NL>}3%% L6234567897012<NL><NL><HT>        strcat(envstr%% tz);<NL><HT>        putenv(envstr);<NL><HT>} else {<NL><HT>        putenv("TZ=");<NL><HT>}<NL><NL><HT>tzset();<NL><NL><HT>return ret;<NL>}<NL><NL>char *get_header(const httpreq_t *req%% const char* headername) {<NL><HT>char *hdrptr;<NL><HT>char *hdrend;<NL><HT>char *retval = NULL;<NL><NL><HT>char searchstr[strlen(headername) + 5];<NL><HT>strcpy(searchstr%% "<NL>");<NL><HT>strcat(searchstr%% headername);<NL><HT>strcat(searchstr%% ": ");<NL>4%% L7345678980123<NL><NL>        if (hdrptr = strstr(req->headers%% searchstr)) {<NL>                hdrptr += strlen(searchstr);<NL>                if (hdrend = strstr(hdrptr%% "<NL>")) {<NL>                        char hdrval[1024]; // temporary return value            <NL><NL>                        memcpy((char *)hdrval%% hdrptr%% (hdrend - hdrptr));<NL>                        hdrval[hdrend - hdrptr] = '\0'; // tack null onto end o\<NL><NL>f header value                                                                  <NL><NL>                        int hdrvallen = strlen(hdrval);<NL>                        retval = (char *)malloc((hdrvallen + 1) * sizeof(char))\<NL><NL>; // malloc a space for retval                                                  <NL><NL><HT><HT><HT>strcpy(retval%% (char *)hdrval);5%% L8456789<NL>901<NL>2<NL>                } else {<NL>                        retval = (char *)malloc((strlen(hdrptr) + 1) * sizeof(c\<NL><NL>har)); //                                                                       <NL><NL>                        strcpy(retval%% hdrptr);<NL>                }<NL>        }<NL><NL>        return retval;<NL>}<NL>7%% L934<NL>567891001<NL><NL>/* As long as str begins with a proper HTTP-Version followed by delim%% returns \<NL><NL>a                                                                               <NL><NL>   pointer to the start of the version number (e.g.%% 1.0). Returns NULL otherwi\<NL><NL>se.                                                                             <NL><NL> */<NL>char *http_version_str(char *str%% char *delim) {<NL>        char *vstart = strstr(str%% "HTTP/");<NL>        char *vnumstart = str + 5;<NL>        char *vdot = strchr(str%% '.');<NL><HT>char *vend = strstr(str%% delim);20%% L102<NL>3<NL>456789<NL>        char *digits = "0123456789";<NL>        int majvlen = 0;<NL>        int minvlen = 0;<NL><NL>        if (!vstart || !vdot // something's missing                             <NL><NL>                || vstart != str) // str doesn't start with "HTTP/"             <NL><NL>                return NULL;<NL><NL>        majvlen = strspn(vnumstart%% digits);<NL>        minvlen = strspn(vdot + 1%% digits);1%% L110123456789<NL><NL>        if (majvlen < 1 || (vnumstart + majvlen) != vdot // bad major version   <NL><NL>                || minvlen < 1 || (vdot + minvlen + 1) != vend) // bad minor ve\<NL><NL>rsion                                                                           <NL><NL>                return NULL;<NL><NL>        return vnumstart;<NL>}<NL><NL>/* Fills req with the request data from datastr. Returns 0 on success.          <NL><NL> */<NL><NL>int parsereq(httpreq_t *req%% char *datastr) {4%% L122<NL>3456789301<NL>        char *position;<NL>        char *last_position = datastr;<NL>        char *temp_position;<NL>        int matchlen;<NL><NL>        req->method = "";<NL>        req->uri = "";<NL>        req->version = "";<NL>        req->headers = "";<NL>6%% L1323456789401<NL><NL>        if (!(position = strchr(last_position%% ' '))) {<NL>                return 1;<NL>        }<NL>        matchlen = (int)(position - last_position);<NL>        req->method = (char *)malloc((matchlen + 1) * sizeof(char));<NL>        memcpy(req->method%% last_position%% matchlen);<NL>        req->method[matchlen] = '\0';<NL>        last_position = position + 1;<NL><NL>        if (!(position = strchr(last_position%% ' '))<NL><HT><HT>&& !(position = strstr(last_position%% "<NL>"))) {8%% L14234567895012<NL>                return 1;<NL>        }<NL><NL>        // strip any query string out of the URI                                <NL><NL>        if ((temp_position = strchr(last_position%% '?')) && temp_position < pos\<NL><NL>ition)<NL>                matchlen = (int)(temp_position - last_position);<NL>        else<NL>                matchlen = (int)(position - last_position);<NL><NL>        req->uri = (char *)malloc((matchlen + 1) * sizeof(char));9%% L1534567<NL>896012<NL>        memcpy(req->uri%% last_position%% matchlen);<NL>        req->uri[matchlen] = '\0';<NL>        if (position[0] == '<NL>') {<NL>                req->version = "0.9";<NL>                req->headers = "";<NL>                return 0; // simple req -- uri only                             <NL><NL>        }<NL><NL>        // If we get here%% it's a full request%% get the HTTP version and header\<NL><NL>s                                                                               <NL>32%% L163456789701<NL>        last_position = position + 1;<NL><NL>        if (!(position = strstr(last_position%% "<NL>"))<NL>                || !(last_position = http_version_str(last_position%% "<NL>"))) \<NL><NL>{<NL>                return 1;<NL>        }<NL><NL>        matchlen = (int)(position - last_position);<NL>        req->version = (char *)malloc((matchlen + 1) * sizeof(char));4%% L172345<NL>680<NL><NL><NL>End of buffer<NL><HT>                pthread_t *thread = (pthread_t *) malloc(sizeof(pthread\<NL>_t));<NL><HT>                int *sockfd_ptr = (int *) malloc(sizeof(int));<NL><NL><HT><HT>        *sockfd_ptr = acc;<NL><HT><HT>        pthread_create(thread%% NULL%% data_thread%% sockfd_ptr);<NL><HT><HT>}<NL><NL><NL><HT>return 0;<NL>}<NL><NL><NL><NL><NL><NL><NL><NL><NL><NL>Bot L52(No files need saving)>%,emacs webserver.c
CMBEGIN,,,tar cvzf lclarkey-intro.tar.gz top_secret,,
CMBEGIN,,,tar cvzf lclarkey-intro.tar.gz top_secret,,
CMBEGIN,,,sftp intro.lclarkey.CS495LC.isi.deterlab.net top,p_secret<ESC>[A@server:/usr/src/fhttpd$ sftp ssh intro.lclarkey.CS495LC.isi.deterlab.net <ESC>[K<ESC>[Alarkey@server:/usr/src/fhttpd$ sudo scp -r /users/lclarkey/top_secret/xbzf136INTRO-1.jpg downloads<BS><BS><BS><BS><BS><BS><BS><BS>esktop/dumpster<BS><BS><BS><BS><BS><BS><BS><BS><BS><ESC>[K<ESC>[Asr/src/fhttpd$ scp -r /users/lclarkey/top_secret/xbzf136INTRO-1<ESC>[5P.jpg desktop<NL>1.jpg<ESC>[K<ESC>[Akey@server:/usr/src/fhttpd$ cd ..<ESC>[K<NL>,
CMBEGIN,,,xdg-open top_secret/xbzf136INTRO-1.jpg,,
CMBEGIN,,,tar cvzf IwillChooseFileName.tar.gz top_secret,,
CMBEGIN,,,pscp.exe lclarkey@users.isi.deterlab.net:top_sec,cret/wuer136intro-4.JPG Old<ESC>[Attpd$ <ESC>[24Psftp wuer136intro-4.JPG<NL>,
CMBEGIN,,,cp /usr/share/pixmaps/xbzf136INTRO-1.jpg top_sec,cret<ESC>[Arkey@server:/usr/src/fhttpd$ cp /<ESC>[9Pdev/136intro-2jjaj.JPEG top_secret<NL>,
CMBEGIN,,,cp /.hidden/asdf136Intro-5kqlw.jpeg top_secret,,
CMBEGIN,,,find / -iname "*intro*.JPEG" 2>dev/null,,
CMBEGIN,,,cp /var/log/136intro-3.jpg top_secret,,
CMBEGIN,,,find / -name ""intro""2> /dev/null |xargs file$1,1<ESC>[Aclarkey@server:/usr/src/fhttpd$ find |<NL><NL>1 | grep JPEG<ESC>[Aer:/usr/src/fhttpd$ find /<NL><NL>1 | grep JPEG<ESC>[Aer:/usr/src/fhttpd$ find <ESC>[15P| xargs file $1 | grep JPEG<NL>,
CMBEGIN,,,Find /-mount -name ""intro""2> /dev/null |xargs , file$1 | grep JPEG<ESC>[Ar/src/fhttpd$ ssh intro.lclarkey-intro-21.CS495LC.isi.deterlab.net<ESC>[K<ESC>[Akey@server:/usr/src/fhttpd$ <ESC>[26Prm ~/.ssh/known_hosts<NL>,
CMBEGIN,,,ssh intro.lclarkey-intro-21.CS495LC.isi.deterlab,b.net<ESC>[Akey@server:/usr/src/fhttpd$ ssh <ESC>[16Plclarkey@users.deterlab.net<NL>,
CMBEGIN,,,ssh intro.lclarkey-intro-21.cs495lc.isi.deterlab,b.net<ESC>[Akey@server:/usr/src/fhttpd$ ssh intro.lclarkey.lclarkey-intro-21.cs495lc.isi.<ESC>[9@deterlab.net<ESC>[Ar:/usr/src/fhttpd$ ssh intro.lclarkey-intro-21.cs495lc.isi.deterlab.net<ESC>[K<ESC>[Akey@server:/usr/src/fhttpd$ ssh intro.lclarkey<ESC>[4P.CS495LC.isi.deterlab.net<NL>,
CMBEGIN,,,ssh intro.XXXXXXXXXX.CS495LC.isi.deterlab.net^[ ,OA<BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><BEL><ESC>[Alarkey@server:/usr/src/fhttpd$ ssh intro.XXXXXXXXXX.CS495LC.isi.deterlab.net<ESC>[K<NL>,
CMBEGIN,,,ssh intro.lclarkey-intro-21.cs495lc.isi.deterlab,b.net<ESC>[Akey@server:/usr/src/fhttpd$ ssh intro.lclarkey.lclarkey-intro-21.cs495lc.isi.<ESC>[9@deterlab.net<ESC>[Ar:/usr/src/fhttpd$ ssh intro.lclarkey-intro-21.cs495lc.isi.deterlab.net<ESC>[K<ESC>[Akey@server:/usr/src/fhttpd$ find intro<ESC>[K<NL>,
CMBEGIN,,,ssh intro.lclarkey-intro-21.CS495LC.isi.deterlab,b.net<ESC>[Akey@server:/usr/src/fhttpd$ <ESC>[26Prm ~/.ssh/known_hosts<NL>,
CMBEGIN,,,ssh intro.lclarkey-intro-21.CS495LC.isi.deterlab,b.net<ESC>[Akey@server:/usr/src/fhttpd$ Find /-mount -name ""intro""2> /dev/null |xargs file$1 | grep JPEG<ESC>[Ar/src/fhttpd$ <ESC>[18Pfindxargs file $1 | grep JPEG<NL>,
CMBEGIN,,,find / -name ""intro""2> /dev/null |xargs file$1,1 | grep JPEG<ESC>[Aer:/usr/src/fhttpd$ find |<NL><NL>1 | grep JPEG<NL>1<ESC>[K<ESC>[Aclarkey@server:/usr/src/fhttpd$ find /<NL><NL>1<ESC>[Aclarkey@server:/usr/src/fhttpd$ find / -name ""intro""2>  <ESC>[K<NL>,
CMBEGIN,,,cp /etc/wuer136intro-4.JPG top_secret,,
CMBEGIN,,,cp /.hidden/asdf136Intro-5kqlw.jpeg top_secret,,
CMBEGIN,,,cp /usr/share/pixmaps/xbzf136INTRO-1.jpg top_sec,cret<ESC>[Arkey@server:/usr/src/fhttpd$ ls<ESC>[K<NL>,
CMBEGIN,,,pscp.exe lclarkey@users.isi.deterlab.net:top_sec,cret/wuer136intro-4.JPG Old<ESC>[Attpd$ ls<ESC>[K<NL>,
CMBEGIN,,,tar cvzf IwillChooseFileName.tar.gz top_secret,,
CMBEGIN,,,xdg-open top_secret/xbzf136INTRO-1.jpg,,
CMBEGIN,,,scp -r /users/lclarkey/top_secret/xbzf136INTRO-1,1.jpg desktop<ESC>[Aer:/usr/src/fhttpd$ sudo scp -r /users/lclarkey/top_secret/xbzf136IN<ESC>[5@TRO-1.jpg desktop/dumpster<NL>NTRO-1.jpg d<ESC>[7Pownloads<ESC>[A/src/fhttpd$ sftp ssh intro.lclarkey.CS495LC.isi.deterlab.net <ESC>[K<ESC>[Alarkey@server:/usr/src/fhttpd$ sftp intro.lclarkey.CS495LC.isi.deterlab.net top_secret<ESC>[A@server:/usr/src/fhttpd$ sftp <ESC>[4Plclarkey@users.deterlab.net top_secret<NL>,
CMBEGIN,,,sftp lclarkey@users.deterlab.net top_secret,,
CMBEGIN,,,sudo ./webserver 8000,,
CMBEGIN,,,cd /usr/src/fhttpd,,
CMBEGIN,Nov 28 12:28:36,/users/lclarkey,emacs webserver.c,%=><NL>=-111:----F1  *scratch*      All L1     (Fundamental) ---------------------------<NL>Loading 00debian-vars...done<NL>/etc/emacs/site-start.d/50autoconf.el (source)...<NL>done<NL>Loading /etc/emacs/site-start.d/50autoconf.el (source)...doneFile Edit Options Buffers Tools Lisp-Interaction Help                           <NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL>-111:----F1  *scratch*      All L1     (Lisp Interaction) ----------------------<NL>For information about GNU Emacs and the GNU system%% type C-h C-a.<NL>Note: file is write protected<NL>Note: file is write protectedFile Edit Options Buffers Tools C Help                                          <NL><NL>// webserver.c                                                                  <NL><NL>// FrobozzCo Official Webserver                                                 <NL><NL>// Barbazzo Fernap barbazzo@gue.com                                             <NL><NL>// Gustar Woomax gustar@gue.com                                                 <NL><NL>// Wilbar Memboob wilbar@gue.com                                                <NL><NL><NL>// By the Frobozz Magic Webserver Company                                       <NL><NL>// Released under the Grue Public License                                       <NL><NL>// Frobruary 14th%% 1067 GUE                                                     <NL><NL><NL>// THERE IS NO WARRANTY FOR THE PROGRAM%% TO THE EXTENT PERMITTED                <NL><NL>// BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE               <NL><NL>// COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \u201CAS IS\u201D\<NL><NL>                                                                                <NL><NL>// WITHOUT WARRANTY OF ANY KIND%% EITHER EXPRESSED OR IMPLIED%% INCLUDING%%        <NL><NL>// BUT NOT LIMITED TO%% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND            <NL><NL>// FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY          <NL><NL>// AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE         <NL><NL>// DEFECTIVE%% *AND IT WILL*%% YOU ASSUME THE COST OF ALL NECESSARY               <NL><NL>// SERVICING%% REPAIR OR CORRECTION.                                             <NL><NL><NL>-11U:%%%%--F1  webserver.c    Top L1     (C/l Abbrev) ----------------------------<NL>2<NL><NL>616#include <errno.h><NL>#include <string.h><NL>#include <stdlib.h><NL>#include <netdb.h><NL>#include <sys/stat.h><NL>#include <sys/types.h><NL>#include <sys/socket.h><NL>#include <netinet/in.h><NL>#include <arpa/inet.h><NL>#include <unistd.h><NL>#include <fcntl.h><NL>#include <time.h><NL>#include <pthread.h><NL><NL>#define _XOPEN_SOURCE<NL><NL>typedef struct {<NL>        char *method;<NL>        char *uri;<NL>        char *version;<NL><HT>char *headers; 7%% L32        char *version;<NL>        char *headers;<NL>} httpreq_t;<NL><NL><NL>/* NOTE: this function is based on a function provided in the GNU "timegm" man  <NL>   page. timegm is a GNU extension to time.h that returns the given tm struct a\<NL>s                                                                               <NL>   a UNIX timestamp in GMT/UTC%% rather than local time. The man page suggests a<NL>   function similar to the one below as a portable equivalent.                  <NL> */<NL>time_t my_timegm(struct tm *tm) {<NL>        time_t ret;<NL><HT>char *tz;<NL><NL><HT>tz = getenv("TZ");<NL>        putenv("TZ=GMT");<NL><HT>tzset();<NL><HT>ret = mktime(tm);<NL><HT>if (tz) {<NL><HT>        char envstr[strlen(tz) + 4];10%% L51<NL><HT>        strcat(envstr%% tz);<NL><HT>        putenv(envstr);<NL>        } else {<NL>putenv("TZ=");<NL><HT>}<NL><NL>        tzset();<NL><NL>        return ret;<NL>}<NL><NL>char *get_header(const httpreq_t *req%% const char* headername) {<NL><HT>char *hdrptr;hdrend;<NL><HT>char *retval = NULL;<NL><NL><HT>char searchstr[strlen(headername) + 5];<NL><HT>strcpy(searchstr%% "<NL>");<NL><HT>strcat(searchstr%% headername);<NL><HT>strcat(searchstr%% ": ");<NL>4%% L73End of buffer<NL><HT><HT>        pthread_t *thread = (pthread_t *) malloc(sizeof(pthread\<NL>_t));<NL><HT>                int *sockfd_ptr = (int *) malloc(sizeof(int));<NL><NL><HT>                *sockfd_ptr = acc;<NL><HT><HT><HT>pthread_create(thread%% NULL%% data_thread%% sockfd_ptr);<NL><HT>        }<NL><HT>}<NL><NL>        return 0;<NL>}<NL><NL><NL><NL><NL><NL><NL><NL><NL>Bot L520195<NL><HT>if(listen(sockfd%%5) < 0) {<NL>                perror("listen");<NL><HT><HT>exit(1);<NL><HT>}<NL><NL><HT>/* Infinite loop for receiving and processing client requests */<NL><HT>for(;;) {<NL><HT>        clen=sizeof(caddr);<NL><NL><HT>        /* Wait for a connection for a client process */<NL>                acc=accept(sockfd%%(struct sockaddr *) &caddr%%(socklen_t*)&clen)\<NL>;<NL><HT><HT>if(acc < 0) {<NL><HT><HT><HT>perror("accept");<NL><HT><HT><HT>exit(1);<NL><HT><HT>} else {<NL>pthread_t *thread = (pthread_t *) malloc(sizeof(pthread\<NL>_t));<NL><HT><HT><HT>int *sockfd_ptr = (int *) malloc(sizeof(int));<NL><NL><HT><HT><HT>*sockfd_ptr = acc;96%% L50<NL><HT><HT><HT>socket<NL><NL><NL><HT>}<NL><NL><HT>/* Create socket address structure for the local host */<NL><HT>memset((char *) &saddr%% '\0'%% sizeof(saddr));<NL><HT>saddr.sin_family=AF_INET;<NL><HT>saddr.sin_port=htons(port);<NL><HT>saddr.sin_addr.s_addr=htonl(INADDR_ANY);<NL><NL><HT>/* Bind our local address so that the client can send to us */<NL><HT>if(bind(sockfd%%(struct sockaddr *) &saddr%%sizeof(saddr)) == -1) {<NL><HT><HT>perror("bind");<NL><HT><HT>exit(1);<NL><HT>}<NL><NL><HT>if(listen(sockfd%%5) < 0) {<NL><HT><HT>perror("listen");<NL><HT><HT>exit(1);3%% L487<NL><HT>if(argc <= 1) {<NL><NL><HT><HT>fprintf(stderr%% "No port specified. Exiting!<NL>");<NL><HT><HT>exit(1);<NL><NL><HT>}<NL><NL><HT>port = atoi(argv[1]);<NL><NL><HT>/* Obtain name and address for the local host */<NL><HT>if((he=gethostbyname("localhost"))==NULL) {<NL><NL><HT>        herror("gethostbyname");<NL><HT>        exit(1);<NL><NL><HT>}<NL><NL><HT>/* Open a TCP (Internet Stream) socket */(sockfd=socket(AF_INET%%SOCK_STREAM%%0)) == -1) {<NL><NL><HT><HT>perror("socket");<NL>1%% L4684<NL><HT><HT><HT><HT><HT>if (strcmp(req.method%% "GET") != 0<NL><HT><HT>                                && strcmp(req.method%% "HEAD") !\<NL>= 0) {<NL><NL><HT>                                        statcode = 501; // unknown requ\<NL>est method                                                                      <NL><HT>                                }<NL><NL><HT>                        }<NL><HT>                } // end of "if (header)end)"                           <NL><HT><HT>}<NL><HT>} // end of recv while loop                                             <NL><NL><HT>// used to deref a NULL pointer here... :(                              <NL><HT>if (headerstr != NULL) {<NL><HT><HT>printf("%%s<NL>"%% headerstr);<NL><HT>        free(headerstr);<NL><HT>}<NL><NL>send_response(sockfd%% &req%% statcode);87%% L437<HT><HT><HT>POST") == 0) {<NL><NL>                                        // grab the body length                 <NL><HT><HT><HT><HT><HT>char *clenstr = get_header(&req%% "Conte\<NL>nt-Length");<NL><NL><HT><HT><HT><HT><HT>if (clenstr) {<NL><NL><HT><HT><HT><HT>                content_length = atoi(clenstr) \<NL>- ((headerstr + totalheadlen) - header_end - 4);<NL><NL><HT>                                        if (content_length <= 0) {done = 1;<NL><HT>                                        }<NL><NL><HT><HT>                                free(clenstr);<NL><NL><HT>                                } else {<NL><NL><HT>                                        statcode = 400; // bad request \<NL>3%% L411<NL><HT><HT>recvmessage[recvbytes] = '\0';<NL><NL><HT><HT>if (seen_header) {<NL><HT><HT><HT>etting the entity body             <NL><HT><HT><HT>content_length -= recvbytes;<NL>                        if (content_length <= 0) done = 1;<NL><NL><HT><HT>} else {<NL><NL>newheaderstr = (char *) malloc((totalheadlen + recvbyte<NL>s + 1) * sizeof(char));<NL><HT>newheaderstr[totalheadlen + recvbytes] = '\0';<NL><HT><HT><HT>memcpy(newheaderstr%% headerstr%% totalheadlen);<NL><HT><HT><HT>memcpy(newheaderstr + totalheadlen%% recvmessage%% recvby\<NL>tes);<NL><NL><HT><HT><HT>if (headerstr != NULL) {<NL><HT><HT><HT><HT>free(headerstr);<NL><HT><HT><HT>}<NL><NL>headerstr = newheaderstr;77%% L382<NL><HT><HT>                pthread_exit(NULL);<NL><HT><HT><HT>}<NL><HT><HT>}<NL><HT>}<NL>}<NL><NL>void *data_thread(void *sockfd_ptr) {<NL><NL><HT>int sockfd = *(int *) sockfd_ptr;<NL><HT>const int BUFSIZE = 5;<NL>        char recvmessage[BUFSIZE];<NL><HT>char *headerstr = NULL;<NL><HT>char *newheaderstr = NULL;<NL><HT>int recvbytes = 0;<NL>        int curheadlen = 0;<NL><HT>int totalheadlen = 0;<NL><HT>httpreq_t req;<NL><HT>int statcode = 200;<NL><HT>int done = 0;<NL><HT>int seen_header = 0;<NL><HT>char *header_end;2%% L347852<NL><HT>httpreq_t req;<NL><HT>int statcode = 200;<NL><HT>int done = 0;<NL><HT>int seen_header = 0;<NL>        char *header_end;<NL><HT>int content_length = 0;<NL>        char *qstr;<NL><NL><HT>free(sockfd_ptr); // we have the int value out of this now              <NL><HT>recvmessage[BUFSIZE - 1] = '\0'; // mark end of "string"                <NL><NL><HT>/* Read incoming client message from the socket */<NL><HT>while(!done && (recvbytes = recv(sockfd%% recvmessage%% BUFSIZE - 1%% 0)))\<NL>{<NL><HT>        if (recvbytes < 0) {<NL><HT>                perror("recv");<NL><HT>                pthread_exit(NULL);<NL><HT>        }<NL><NL><NL><HT>        recvmessage[recvbytes] = '\0';4%% L363<NL><HT>                pthread_exit(NULL);<NL><HT>        }<NL><NL><NL><HT>        recvmessage[recvbytes] = '\0';<NL><NL><HT>        if (seen_header) {<NL><HT><HT><HT>// getting the entity body                              <NL><HT>                content_length -= recvbytes;<NL><HT>                if (content_length <= 0) done = 1;<NL><NL><HT>        } else {<NL><NL>                       newheaderstr = (char *) malloc((totalheadlen + recvbyte\<NL>s + 1) * sizeof(char));<NL><HT>newheaderstr[totalheadlen + recvbytes] = '\0';<NL><HT><HT><HT>memcpy(newheaderstr%% headerstr%% totalheadlen);<NL><HT><HT>        memcpy(newheaderstr + totalheadlen%% recvmessage%% recvby\<NL>tes);<NL><NL><HT><HT>        if (headerstr != NULL) {7%% L378}<NL><NL><HT><HT><HT>headerstr = newheaderstr;<NL><HT><HT><HT>totalheadlen += recvbytes;<NL><NL><HT><HT><HT>header_end = strstr(headerstr%% "<NL><NL>");<NL><NL><HT><HT><HT>if (header_end) {<NL><HT><HT><HT>        seen_header = 1;<NL><HT><HT><HT>        header_end[2] = '\0';<NL><NL><HT><HT>                if (parsereq(&req%% headerstr) != 0) {<NL><HT><HT><HT><HT><HT>statcode = 400;<NL><HT><HT><HT>        }<NL><NL><HT><HT><HT>        if (strcmp(req.method%% "POST") == 0) {<NL><NL><HT><HT><HT>                // grab the body length                 <NL>                                        char *clenstr = get_header(&req%% "Conte\<NL>nt-Length");<NL>81%% L39if (content_length <= 0) {<NL><HT><HT><HT>                                done = 1;<NL><HT><HT><HT>                        }<NL><NL><HT><HT><HT>                        free(clenstr);<NL><NL><HT><HT><HT>                } else {<NL><NL><HT><HT><HT><HT>                statcode = 400; // bad request \<NL>-- no content length                                                            <NL><HT><HT><HT><HT>                done = 1;<NL><HT><HT><HT><HT><HT>}<NL><NL><HT><HT><HT><HT>} else {<NL><NL><HT><HT><HT><HT><HT>// This isn't a POST%% so there's no ent\<NL>ity body                                                       <NL><HT><HT><HT><HT><HT>done = 1;<NL><NL><HT><HT><HT><HT><HT>if (strcmp(req.method%% "GET") != 05%% L421<NL><HT>} // end of recv while loop                                             <NL><NL><HT>// used to deref a NULL pointer here... :(                              <NL><HT>if (headerstr != NULL) {<NL><HT><HT>printf("%%s<NL>"%% headerstr);<NL><HT><HT>free(headerstr);<NL><HT>}<NL><NL><HT>send_response(sockfd%% &req%% statcode);<NL><HT>close(sockfd);<NL><NL><HT>return NULL;<NL><NL>}<NL><NL>int main(int argc%% char *argv[]) {<NL><HT>int acc%% sockfd%% clen%% port;<NL>        struct hostent *he;<NL><HT>struct sockaddr_in caddr%% saddr;<NL><NL><HT>if(argc <= 1) {8%% L448<NL><HT>        exit(1);<NL><NL><HT>}<NL><NL><HT>/* Open a TCP (Internet Stream) socket */<NL><HT>if((sockfd=socket(AF_INET%%SOCK_STREAM%%0)) == -1) {<NL><NL><HT><HT>perror("socket");<NL><HT>        exit(1);<NL><NL><HT>}<NL><NL><HT>/* Create socket address structure for the local host */<NL>        memset((char *) &saddr%% '\0'%% sizeof(saddr));<NL><HT>saddr.sin_family=AF_INET;<NL>        saddr.sin_port=htons(port);<NL><HT>saddr.sin_addr.s_addr=htonl(INADDR_ANY);<NL><NL><HT>/* Bind our local address so that the client can send to us */<NL><HT>if(bind(sockfd%%(struct sockaddr *) &saddr%%sizeof(saddr)) == -1) {<NL><HT>        perror("bind");<NL>92%% L4813<NL><HT><HT>        perror("accept");<NL><HT><HT><HT>exit(1);<NL><HT>        } else {<NL>pthread_t *thread = (pthread_t *) malloc(sizeof(pthread\<NL>_t));<NL><HT>                int *sockfd_ptr = (int *) malloc(sizeof(int));<NL><NL><HT><HT>        *sockfd_ptr = acc;<NL><HT><HT>        pthread_create(thread%% NULL%% data_thread%% sockfd_ptr);<NL><HT><HT>}<NL><NL><NL><HT>return 0;<NL>}<NL><NL><NL><NL><NL><NL><NL>Bot L517End of buffer201965208<NL><NL><HT><HT>perror("bind");<NL><HT><HT><NL><HT>}<NL><NL>        if(listen(sockfd%%5) < 0) {<NL><HT><HT>perror("listen");<NL><HT><HT>exit(1);<NL><HT>}<NL><NL><HT>/* Infinite loop for receiving and processing client requests */<NL><HT>for(;;) {<NL>clen=sizeof(caddr);<NL><NL>                /* Wait for a connection for a client process */<NL><HT><HT>acc=accept(sockfd%%(struct sockaddr *) &caddr%%(socklen_t*)&clen)\<NL>;<NL><HT><HT>if(acc < 0) {<NL><HT><HT><HT>perror("accept");<NL><HT><HT><HT>exit(1);<NL><HT><HT>} else {<NL>pthread_t *thread = (pthread_t *) malloc(sizeof(pthread\<NL>96%% L501049762<NL><NL><HT><HT>exit(1);<NL><NL><NL><NL><HT>/* Open a TCP (Internet Stream) socket */<NL><HT>if((sockfd=socket(AF_INET%%SOCK_STREAM%%0)) == -1) {<NL><NL><HT>        perror("socket");<NL><HT><HT>exit(1);<NL><NL><HT>}<NL><NL><HT>/* Create socket address structure for the local host */<NL><HT>memset((char *) &saddr%% '\0'%% sizeof(saddr));<NL><HT>saddr.sin_family=AF_INET;<NL>        saddr.sin_port=htons(port);<NL><HT>saddr.sin_addr.s_addr=htonl(INADDR_ANY);<NL><NL><HT>/* Bind our local address so that the client can send to us */<NL><HT>if(bind(sockfd%%(struct sockaddr *) &saddr%%sizeof(saddr)) == -1) {<NL><HT><HT>perror("bind");<NL>2%% L481<NL><HT>struct sockaddr_in caddr%% saddr;<NL><NL><HT>if(argc <= 1) {<NL><NL><HT>        fprintf(stderr%% "No port specified. Exiting!<NL>");<NL><HT>        exit(1);<NL><NL><HT>}<NL><NL><HT>port = atoi(argv[1]);<NL><NL><HT>/* Obtain name and address for the local host */<NL><HT>if((he=gethostbyname("localhost"))==NULL) {<NL><NL><HT>        herror("gethostbyname");<NL><HT>        exit(1);<NL><NL><HT>}<NL><NL><HT>/* Open a TCP (Internet Stream) socket */<NL><HT>if((sockfd=socket(AF_INET%%SOCK_STREAM%%0)) == -1) {0%% L46651<NL><HT>// used to deref a NULL pointer here... :(                              <NL> (headerstr != NULL) {<NL><HT><HT>printf("%%s<NL>"%% headerstr);ree(headerstr);<NL><HT>}<NL><NL>send_response(sockfd%% &req%% statcode);<NL><HT>close(sockfd);<NL><NL><HT>return NULL;<NL><NL>}<NL><NL>int main(int argc%% char *argv[]) {<NL><HT>int acc%% sockfd%% clen%% port;<NL><HT>struct hostent *he;<NL><HT>struct sockaddr_in caddr%% saddr;<NL><NL><HT>if(argc <= 1) {<NL>88%% L4498                                // This isn't a POST%% so there's no ent\<NL>ity body                                                                        <NL><HT><HT>                        done = 1;<NL><NL><HT>                                if (strcmp(req.method%% "GET") != 0&& strcmp(req.method%% "HEAD") !\<NL>= 0) {<NL><NL><HT><HT><HT><HT><HT><HT>statcode = 501; // unknown requ\<NL>est method                                                                      <NL><HT><HT><HT><HT><HT>}<NL><NL><HT><HT><HT><HT>}<NL>                        } // end of "if (header)end)"                           <NL><HT>        }<NL><HT>} // end of recv while loop                                             <NL><NL><HT>// used to deref a NULL pointer here... :(                              <NL> (headerstr != NULL) {<NL><HT><HT>printf("%%s<NL>"%% headerstr);6%% L4332026<NL><NL>nt-Length");<NL><NL>                                        if (clenstr) {<NL>content_length = atoi(clenstr) \<NL>- ((headerstr + totalheadlen) - header_end - 4);<NL><NL>                                                if (content_length <= 0) {done = 1;}<NL><NL><HT><HT><HT><HT><HT>        free(clenstr);<NL><NL><HT><HT><HT><HT>        } else {<NL><NL><HT><HT>                                statcode = 400; // bad request \<NL>-- no content length               <NL><HT><HT>done = 1;<NL><HT>                                }<NL><NL><HT><HT>                } else {4%% L41<NL><HT><HT><HT>if (header_end) {<NL><HT><HT><HT><HT>seen_header = 1;<NL><HT><HT><HT><HT>header_end[2] = '\0';<NL><NL>                                if (parsereq(&req%% headerstr) != 0) {statcode = 400;<NL><HT><HT><HT><HT>}<NL><NL><HT><HT><HT><HT>if (strcmp(req.method%% "POST") == 0) {// grab the body length                 <NL><HT><HT><HT><HT><HT>char *clenstr = get_header(&req%% "Conte\<NL>nt-Length");<NL><NL><HT><HT><HT><HT>if (clenstr) {<NL><NL><HT><HT><HT><HT><HT><HT>content_length = atoi(clenstr) \<NL>- ((headerstr + totalheadlen) - header_end - 4);<NL><NL><HT><HT><HT><HT>                if (content_length <= 0) {2%% L404if (content_length <= 0) done = 1;<NL><NL><HT><HT>} else {<NL><NL><HT><HT><HT>newheaderstr = (char *) malloc((totalheadlen + recvbyte\<NL>s + 1) * sizeof(char));<NL><HT>newheaderstr[totalheadlen + recvbytes] = '\0';<NL><HT><HT><HT>memcpy(newheaderstr%% headerstr%% totalheadlen);<NL><HT><HT><HT>memcpy(newheaderstr + totalheadlen%% recvmessage%% recvby\<NL>tes);<NL><NL><HT><HT><HT>if (headerstr != NULL) {<NL><HT><HT><HT><HT>free(headerstr);<NL>                        }<NL><NL>headerstr = newheaderstr;<NL><HT><HT><HT>totalheadlen += recvbytes;<NL><NL>                        header_end = strstr(headerstr%% "<NL><NL>");<NL><NL><HT><HT><HT>if (header_end) {78%% L386<NL><HT>char *header_end;<NL><HT>int content_length = 0;<NL><HT>char *qstr;<NL><NL><HT>free(sockfd_ptr); // we have the int value out of this now              <NL>        recvmessage[BUFSIZE - 1] = '\0'; // mark end of "string"                <NL><NL><HT>/* Read incoming client message from the socket */<NL><HT>while(!done && (recvbytes = recv(sockfd%% recvmessage%% BUFSIZE - 1%% 0)))<NL> {<NL><HT><HT>if (recvbytes < 0) {<NL><HT><HT><HT>perror("recv");<NL><HT><HT><HT>pthread_exit(NULL);<NL><HT><HT><NL><NL><NL><HT><HT>recvmessage[recvbytes] = '\0';<NL><NL><HT><HT>if (seen_header) {<NL><HT><HT><HT>// getting the entity body                              <NL><HT><HT><HT>content_length -= recvbytes;5%% L36765059        const int BUFSIZE = 5;<NL>        char recvmessage[BUFSIZE];<NL>        char *headerstr = NULL;<NL>        char *newheaderstr = NULL;<NL>        int recvbytes = 0;<NL>        int curheadlen = 0;<NL>        int totalheadlen = 0;<NL>        httpreq_t req;<NL>        int statcode = 200;<NL>        int done = 0;<NL>        int seen_header = 0;3%% L35648<NL><HT>        int readbytes<NL><NL><HT>        while (readbytes = read(urifd%% sendmessage%% BUFSIZE)) {<NL><HT>                if (readbytes < 0) {<NL><HT>                        perror("read");<NL><HT>                        pthread_exit(NULL);<NL><HT>                }<NL><HT>                if (send(sockfd%% sendmessage%% readbytes%% 0) < 0) {<NL><HT>                        perror("send");<NL><HT>                        pthread_exit(NULL);<NL><HT>                }<NL><HT>        }<NL><HT>}<NL>}<NL><NL>void *data_thread(void *sockfd_ptr) {<NL><NL><HT>int sockfd = *(int *) sockfd_ptr;<NL><HT>const int BUFSIZE = 5;<NL><HT>char recvmessage[BUFSIZE];<NL>       char *headerstr = NULL;<NL>0%% L3376210        }<NL><NL>        if (sendmessage[0] != '\0') {<NL>                // send headers as long as there are headers to send            <NL><NL>                if (send(sockfd%% sendmessage%% strlen(sendmessage)%% 0) < 0) {<NL>                        perror("send");<NL>                        pthread_exit(NULL);<NL>                }<NL>        }<NL><NL>        if (statcode == 200 && (strcmp(req->method%% "HEAD") != 0)) {<NL>                // send the requested file as long as there's no error and the  <NL><NL>                // request wasn't just for the headers                          <NL>67%% L32541019876<NL><NL>5<NL><NL>        }<NL><NL>        if (statcode != 200) {<NL>                strcat(sendmessage%% "<html><head><title>");<NL>                strcat(sendmessage%% status(statcode));<NL>                strcat(sendmessage%% "</title></head><body><h2>HTTP/1.0</h2><h1>\<NL><NL>");<NL>                strcat(sendmessage%% status(statcode));<NL>                strcat(sendmessage%% "</h1><h2>URI: ");<NL>                strcat(sendmessage%% path);<NL>                strcat(sendmessage%% "</h2></body></html>");5%% L31434%,emacs webserver.c
