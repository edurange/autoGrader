CMBEGIN,Nov 21 12:06:26,/users/lclarkel,ls /usr/src/fhttpd,frobnick  index.html  Makefile<HT>webserver  webserver.c,ls /usr/src/fhttpd
CMBEGIN,,,cd,,
CMBEGIN,Nov 21 12:06:51,/usr/src/fhttpd,sudo make,make: Nothing to be done for 'project'.,sudo make
CMBEGIN,Nov 21 12:06:59,/usr/src/fhttpd,ls,frobnick  index.html  Makefile<HT>webserver  webserver.c,ls
CMBEGIN,,, sudo ./,^C,
CMBEGIN,,, s,home<NL><NL><C3><BF><C3><ACUTE><C3><BF><C3><BD><ACK><C3><BF><C3><ACUTE><C3><BF><C3><BD><ACK><C3><BF><C3><ACUTE><C3><BF><C3><BD><ACK><C3><BF><C3><ACUTE><C3><BF><C3><BD><ACK><C3><BF><C3><ACUTE><C3><BF><C3><BD><ACK><C3><BF><C3><ACUTE><C3><BF><C3><BD><ACK><C3><BF><C3><ACUTE><C3><BF><C3><BD><ACK><C3><BF><C3><ACUTE><C3><BF><C3><BD><ACK><NL>GET /index.html HTTP/1.1<NL><NL>User-Agent: Wget/1.17.1 (linux-gnu)<NL><NL>Accept: */*<NL><NL>Accept-Encoding: identity<NL><NL>Host: localhost:8080<NL><NL>Connection: Keep-Alive<NL><NL><NL>GET /conr.html HTTP/1.1<NL><NL>User-Agent: Wget/1.17.1 (linux-gnu)<NL><NL>Accept: */*<NL><NL>Accept-Encoding: identity<NL><NL>Host: localhost:8080<NL><NL>Connection: Keep-Alive<NL><NL><NL>GET /09876543123456789 HTTP/1.1<NL><NL>User-Agent: Wget/1.17.1 (linux-gnu)<NL><NL>Accept: */*<NL><NL>Accept-Encoding: identity<NL><NL>Host: localhost:8080<NL><NL>Connection: Keep-Alive<NL><NL><NL>GET /09876543123456789.html HTTP/1.1<NL><NL>User-Agent: Wget/1.17.1 (linux-gnu)<NL><NL>Accept: */*<NL><NL>Accept-Encoding: identity<NL><NL>Host: localhost:8080<NL><NL>Connection: Keep-Alive<NL><NL><NL>GET /0987654321234567890-09876543234567890987654321345678909876543234567890987654321234567890987654323456789009876543209876543210987654321 HTTP/1.1<NL><NL>User-Agent: Wget/1.17.1 (linux-gnu)<NL><NL>Accept: */*<NL><NL>Accept-Encoding: identity<NL><NL>Host: localhost:8080<NL><NL>Connection: Keep-Alive<NL><NL><NL>GET /0987654321234567890-098765432345678909876543213456789098765432345678909876543212345678909876543234567890098765432098765432109876543210987654321234567890-09876543234567890987654321345678909876543234567890987654321234567890987654323456789009876543209876543210987654321 HTTP/1.1<NL><NL>User-Agent: Wget/1.17.1 (linux-gnu)<NL><NL>Accept: */*<NL><NL>Accept-Encoding: identity<NL><NL>Host: localhost:8080<NL><NL>Connection: Keep-Alive<NL><NL><NL>GET /0987654321234567890-098765432345678909876543213456789098765432345678909876543212345678909876543234567890098765432098765432109876543210987654321234567890-098765432345678909876543213456789098765432345678909876543212345678909876543234567890098765432098765432109876543210987654321234567890-09876543234567890987654321345678909876543234567890987654321234567890987654323456789009876543209876543210987654321 HTTP/1.1<NL><NL>User-Agent: Wget/1.17.1 (linux-gnu)<NL><NL>Accept: */*<NL><NL>Accept-Encoding: identity<NL><NL>Host: localhost:8080<NL><NL>Connection: Keep-Alive<NL><NL><NL>GET /0987654321234567890-098765432345678909876543213456789098765432345678909876543212345678909876543234567890098765432098765432109876543210987654321234567890-098765432345678909876543213456789098765432345678909876543212345678909876543234567890098765432098765432109876543210987654321234567890-098765432345678909876543213456789098765432345678909876543212345678909876543234567890098765432098765432109876543210987654321234567890-09876543234567890987654321345678909876543234567890987654321234567890987654323456789009876543209876543210987654321 HTTP/1.1<NL><NL>User-Agent: Wget/1.17.1 (linux-gnu)<NL><NL>Accept: */*<NL><NL>Accept-Encoding: identity<NL><NL>Host: localhost:8080<NL><NL>Connection: Keep-Alive<NL><NL><NL>GET /0987654321234567890-098765432345678909876543213456789098765432345678909876543212345678909876543234567890098765432098765432109876543210987654321234567890-098765432345678909876543213456789098765432345678909876543212345678909876543234567890098765432098765432109876543210987654321234567890-098765432345678909876543213456789098765432345678909876543212345678909876543234567890098765432098765432109876543210987654321234567890-098765432345678909876543213456789098765432345678909876543212345678909876543234567890098765432098765432109876543210987654321234567890-09876543234567890987654321345678909876543234567890987654321234567890987654323456789009876543209876543210987654321 HTTP/1.1<NL><NL>User-Agent: Wget/1.17.1 (linux-gnu)<NL><NL>Accept: */*<NL><NL>Accept-Encoding: identity<NL><NL>Host: localhost:8080<NL><NL>Connection: Keep-Alive<NL><NL><NL>GET /0987654321234567890-098765432345678909876543213456789098765432345678909876543212345678909876543234567890098765432098765432109876543210987654321234567890-098765432345678909876543213456789098765432345678909876543212345678909876543234567890098765432098765432109876543210987654321234567890-098765432345678909876543213456789098765432345678909876543212345678909876543234567890098765432098765432109876543210987654321234567890-098765432345678909876543213456789098765432345678909876543212345678909876543234567890098765432098765432109876543210987654321234567890-098765432345678909876543213456789098765432345678909876543212345678909876543234567890098765432098765432109876543210987654321234567890-09876543234567890987654321345678909876543234567890987654321234567890987654323456789009876543209876543210987654321 HTTP/1.1<NL><NL>User-Agent: Wget/1.17.1 (linux-gnu)<NL><NL>Accept: */*<NL><NL>Accept-Encoding: identity<NL><NL>Host: localhost:8080<NL><NL>Connection: Keep-Alive<NL><NL><NL>send: Bad file descriptor<NL>^C,
CMBEGIN,Nov 21 12:11:38,/usr/src/fhttpd, sudo ./webserver 8080,bind: Address already in use,sudo ./webserver 8080
CMBEGIN,Nov 21 12:17:34,/usr/src/fhttpd, sudo ./webserver 8081,GET /conr.html HTTP/1.1<NL><NL>User-Agent: Wget/1.17.1 (linux-gnu)<NL><NL>Accept: */*<NL><NL>Accept-Encoding: identity<NL><NL>Host: localhost:8081<NL><NL>Connection: Keep-Alive<NL><NL><NL>^C,sudo ./webserver 8081
CMBEGIN,,,gdb,%GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.04) 7.11.1<NL>Copyright (C) 2016 Free Software Foundation%% Inc.<NL>License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html><NL>This is free software: you are free to change and redistribute it.<NL>There is NO WARRANTY%% to the extent permitted by law.  Type \"show copying\"<NL>and \"show warranty\" for details.<NL>This GDB was configured as \"x86_64-linux-gnu\".<NL>Type \"show configuration\" for configuration details.<NL>For bug reporting instructions%% please see:<NL><http://www.gnu.org/software/gdb/bugs/>.<NL>Find the GDB manual and other documentation resources online at:<NL><http://www.gnu.org/software/gdb/documentation/>.<NL>For help%% type \"help\".<NL>Type \"apropos word\" to search for commands related to \"word\"...<NL>Reading symbols from ./webserver...done.<NL>Attaching to program: /usr/src/fhttpd/webserver%% process 8080<NL>ptrace: No such process.<NL>/usr/src/fhttpd/8080: No such file or directory.<NL>(gdb) run<NL>Starting program: /usr/src/fhttpd/webserver <NL>[Thread debugging using libthread_db enabled]<NL>Using host libthread_db library \"/lib/x86_64-linux-gnu/libthread_db.so.1\".<NL>No port specified. Exiting!<NL>[Inferior 1 (process 22765) exited with code 01]%,
CMBEGIN,,,^C,,
CMBEGIN,,,telnet localhost 808,Trying 127.0.0.1...<NL>Connected to localhost.<NL>Escape character is '^]'.<NL>^[[C<BS> <BS><BS> <BS><BS> <BS><BS> <BS>home<NL>^C^C^C^C^C^C^C^C<C3><CENT><C2><EURO><C2><98><C3><CENT><C2><EURO><C2><98>^]<NL><NL>telnet> ^]<NL>?Invalid command<NL>telnet> exit<NL>?Invalid command<NL>telnet> quit<NL>Connection closed.,
CMBEGIN,Nov 21 12:13:17,/users/lclarkel,wget http://localhost:8080/index.html,%--2018-11-21 12:13:17--  http://localhost:8080/index.html<NL>Resolving localhost (localhost)... 127.0.0.1<NL>Connecting to localhost (localhost)|127.0.0.1|:8080... connected.<NL>HTTP request sent%% awaiting response... 200 OK<NL>Length: unspecified [text/html]<NL>Saving to: 'index.html'<NL><NL><NL>index.html              [<=>                 ]       0  --.-KB/s               <NL>index.html              [ <=>                ]   5.59K  --.-KB/s    in 0s      <NL><NL>2018-11-21 12:13:17 (186 MB/s) - 'index.html' saved [5725]<NL>%,wget http://localhost:8080/index.html
CMBEGIN,,,wget http://localhost:8080/conr,%--2018-11-21 12:14:18--  http://localhost:8080/conr.html<NL>Resolving localhost (localhost)... 127.0.0.1<NL>Connecting to localhost (localhost)|127.0.0.1|:8080... connected.<NL>HTTP request sent%% awaiting response... 404 Not Found<NL>2018-11-21 12:14:18 ERROR 404: Not Found.<NL>%,
CMBEGIN,Nov 21 12:15:11,/users/lclarkel,wget http://localhost:8080/09876543123456789,%--2018-11-21 12:15:11--  http://localhost:8080/09876543123456789<NL>Resolving localhost (localhost)... 127.0.0.1<NL>Connecting to localhost (localhost)|127.0.0.1|:8080... connected.<NL>HTTP request sent%% awaiting response... 404 Not Found<NL>2018-11-21 12:15:11 ERROR 404: Not Found.<NL>%,wget http://localhost:8080/09876543123456789
CMBEGIN,Nov 21 12:15:17,/users/lclarkel,wget http://localhost:8080/09876543123456789.html,%--2018-11-21 12:15:17--  http://localhost:8080/09876543123456789.html<NL>Resolving localhost (localhost)... 127.0.0.1<NL>Connecting to localhost (localhost)|127.0.0.1|:8080... connected.<NL>HTTP request sent%% awaiting response... 404 Not Found<NL>2018-11-21 12:15:17 ERROR 404: Not Found.<NL>%,wget http://localhost:8080/09876543123456789.html
CMBEGIN,,,wget http://localhost:8080/0987654321234567890-09876543234567 ,%89098765432134567890987654323456789098765432123456789098765432345678900987654320 <NL>9876543210987654321<NL>--2018-11-21 12:15:38--  http://localhost:8080/0987654321234567890-09876543234567890987654321345678909876543234567890987654321234567890987654323456789009876543209876543210987654321<NL>Resolving localhost (localhost)... 127.0.0.1<NL>Connecting to localhost (localhost)|127.0.0.1|:8080... connected.<NL>HTTP request sent%% awaiting response... 404 Not Found<NL>2018-11-21 12:15:38 ERROR 404: Not Found.<NL>%,
CMBEGIN,,,wget http://localhost:8080/0987654321234567890-098765432345678,%890987654321345678909876543234567890987654321234567890987654323456789009876543209<NL>98765432109876543210987654321234567890-09876543234567890987654321345678909876543 <NL>234567890987654321234567890987654323456789009876543209876543210987654321<NL>The name is too long%% 266 chars total.<NL>Trying to shorten...<NL>New name is 0987654321234567890-098765432345678909876543213456789098765432345678909876543212345678909876543234567890098765432098765432109876543210987654321234567890-09876543234567890987654321345678909876543234567890987654321234567890987654323456789.<NL>--2018-11-21 12:16:17--  http://localhost:8080/0987654321234567890-098765432345678909876543213456789098765432345678909876543212345678909876543234567890098765432098765432109876543210987654321234567890-09876543234567890987654321345678909876543234567890987654321234567890987654323456789009876543209876543210987654321<NL>Resolving localhost (localhost)... 127.0.0.1<NL>Connecting to localhost (localhost)|127.0.0.1|:8080... connected.<NL>HTTP request sent%% awaiting response... 500 Internal Server Error<NL>2018-11-21 12:16:17 ERROR 500: Internal Server Error.<NL>%,
CMBEGIN,,,wget http://localhost:8080/0987654321234567890-098765432345678,%890987654321345678909876543234567890987654321234567890987654323456789009876543209<NL>98765432109876543210987654321234567890-098765432345678909876543213456789098765432<NL>23456789098765432123456789098765432345678900987654320987654321098765432109876543 <NL>21234567890-09876543234567890987654321345678909876543234567890987654321234567890 <NL>987654323456789009876543209876543210987654321<NL>The name is too long%% 399 chars total.<NL>Trying to shorten...<NL>New name is 0987654321234567890-098765432345678909876543213456789098765432345678909876543212345678909876543234567890098765432098765432109876543210987654321234567890-09876543234567890987654321345678909876543234567890987654321234567890987654323456789.<NL>--2018-11-21 12:16:27--  http://localhost:8080/0987654321234567890-098765432345678909876543213456789098765432345678909876543212345678909876543234567890098765432098765432109876543210987654321234567890-098765432345678909876543213456789098765432345678909876543212345678909876543234567890098765432098765432109876543210987654321234567890-09876543234567890987654321345678909876543234567890987654321234567890987654323456789009876543209876543210987654321<NL>Resolving localhost (localhost)... 127.0.0.1<NL>Connecting to localhost (localhost)|127.0.0.1|:8080... connected.<NL>HTTP request sent%% awaiting response... 500 Internal Server Error<NL>2018-11-21 12:16:27 ERROR 500: Internal Server Error.<NL>%,
CMBEGIN,,,wget http://localhost:8080/0987654321234567890-098765432345678,%890987654321345678909876543234567890987654321234567890987654323456789009876543209<NL>98765432109876543210987654321234567890-098765432345678909876543213456789098765432<NL>234567890987654321234567890987654323456789009876543209876543210987654321098765432<NL>21234567890-098765432345678909876543213456789098765432345678909876543212345678909<NL>9876543234567890098765432098765432109876543210987654321234567890-098765432345678 <NL>90987654321345678909876543234567890987654321234567890987654323456789009876543209 <NL>876543210987654321<NL>The name is too long%% 532 chars total.<NL>Trying to shorten...<NL>New name is 0987654321234567890-098765432345678909876543213456789098765432345678909876543212345678909876543234567890098765432098765432109876543210987654321234567890-09876543234567890987654321345678909876543234567890987654321234567890987654323456789.<NL>--2018-11-21 12:16:50--  http://localhost:8080/0987654321234567890-098765432345678909876543213456789098765432345678909876543212345678909876543234567890098765432098765432109876543210987654321234567890-098765432345678909876543213456789098765432345678909876543212345678909876543234567890098765432098765432109876543210987654321234567890-098765432345678909876543213456789098765432345678909876543212345678909876543234567890098765432098765432109876543210987654321234567890-09876543234567890987654321345678909876543234567890987654321234567890987654323456789009876543209876543210987654321<NL>Resolving localhost (localhost)... 127.0.0.1<NL>Connecting to localhost (localhost)|127.0.0.1|:8080... connected.<NL>HTTP request sent%% awaiting response... 500 Internal Server Error<NL>2018-11-21 12:16:50 ERROR 500: Internal Server Error.<NL>%,
CMBEGIN,,,wget http://localhost:8080/0987654321234567890-098765432345678,%890987654321345678909876543234567890987654321234567890987654323456789009876543209<NL>98765432109876543210987654321234567890-098765432345678909876543213456789098765432<NL>234567890987654321234567890987654323456789009876543209876543210987654321098765432<NL>21234567890-098765432345678909876543213456789098765432345678909876543212345678909<NL>9876543234567890098765432098765432109876543210987654321234567890-0987654323456789<NL>909876543213456789098765432345678909876543212345678909876543234567890098765432098<NL>8765432109876543210987654321234567890-098765432345678909876543213456789098765432 <NL>34567890987654321234567890987654323456789009876543209876543210987654321<NL>The name is too long%% 665 chars total.<NL>Trying to shorten...<NL>New name is 0987654321234567890-098765432345678909876543213456789098765432345678909876543212345678909876543234567890098765432098765432109876543210987654321234567890-09876543234567890987654321345678909876543234567890987654321234567890987654323456789.<NL>--2018-11-21 12:16:59--  http://localhost:8080/0987654321234567890-098765432345678909876543213456789098765432345678909876543212345678909876543234567890098765432098765432109876543210987654321234567890-098765432345678909876543213456789098765432345678909876543212345678909876543234567890098765432098765432109876543210987654321234567890-098765432345678909876543213456789098765432345678909876543212345678909876543234567890098765432098765432109876543210987654321234567890-098765432345678909876543213456789098765432345678909876543212345678909876543234567890098765432098765432109876543210987654321234567890-09876543234567890987654321345678909876543234567890987654321234567890987654323456789009876543209876543210987654321<NL>Resolving localhost (localhost)... 127.0.0.1<NL>Connecting to localhost (localhost)|127.0.0.1|:8080... connected.<NL>HTTP request sent%% awaiting response... 500 Internal Server Error<NL>2018-11-21 12:16:59 ERROR 500: Internal Server Error.<NL>%,
CMBEGIN,,,wget http://localhost:8080/0987654321234567890-098765432345678,%890987654321345678909876543234567890987654321234567890987654323456789009876543209<NL>98765432109876543210987654321234567890-098765432345678909876543213456789098765432<NL>234567890987654321234567890987654323456789009876543209876543210987654321098765432<NL>21234567890-098765432345678909876543213456789098765432345678909876543212345678909<NL>9876543234567890098765432098765432109876543210987654321234567890-0987654323456789<NL>909876543213456789098765432345678909876543212345678909876543234567890098765432098<NL>8765432109876543210987654321234567890-0987654323456789098765432134567890987654323<NL>34567890987654321234567890987654323456789009876543209876543210987654321098765432 <NL>1234567890-098765432345678909876543213456789098765432345678909876543212345678909 <NL>87654323456789009876543209876543210987654321<NL>The name is too long%% 798 chars total.<NL>Trying to shorten...<NL>New name is 0987654321234567890-098765432345678909876543213456789098765432345678909876543212345678909876543234567890098765432098765432109876543210987654321234567890-09876543234567890987654321345678909876543234567890987654321234567890987654323456789.<NL>--2018-11-21 12:17:09--  http://localhost:8080/0987654321234567890-098765432345678909876543213456789098765432345678909876543212345678909876543234567890098765432098765432109876543210987654321234567890-098765432345678909876543213456789098765432345678909876543212345678909876543234567890098765432098765432109876543210987654321234567890-098765432345678909876543213456789098765432345678909876543212345678909876543234567890098765432098765432109876543210987654321234567890-098765432345678909876543213456789098765432345678909876543212345678909876543234567890098765432098765432109876543210987654321234567890-098765432345678909876543213456789098765432345678909876543212345678909876543234567890098765432098765432109876543210987654321234567890-09876543234567890987654321345678909876543234567890987654321234567890987654323456789009876543209876543210987654321<NL>Resolving localhost (localhost)... 127.0.0.1<NL>Connecting to localhost (localhost)|127.0.0.1|:8080... connected.<NL>HTTP request sent%% awaiting response... No data received.<NL>Retrying.<NL><NL>--2018-11-21 12:17:29--  (try: 2)  http://localhost:8080/0987654321234567890-098765432345678909876543213456789098765432345678909876543212345678909876543234567890098765432098765432109876543210987654321234567890-098765432345678909876543213456789098765432345678909876543212345678909876543234567890098765432098765432109876543210987654321234567890-098765432345678909876543213456789098765432345678909876543212345678909876543234567890098765432098765432109876543210987654321234567890-098765432345678909876543213456789098765432345678909876543212345678909876543234567890098765432098765432109876543210987654321234567890-098765432345678909876543213456789098765432345678909876543212345678909876543234567890098765432098765432109876543210987654321234567890-09876543234567890987654321345678909876543234567890987654321234567890987654323456789009876543209876543210987654321<NL>Connecting to localhost (localhost)|127.0.0.1|:8080... failed: Connection refused.<NL>Resolving localhost (localhost)... 127.0.0.1<NL>Connecting to localhost (localhost)|127.0.0.1|:8080... failed: Connection refused.%,
CMBEGIN,,,wget http://localhost:8080/0987654321234567890-098765432345678,890987654321345678909876543234567890987654321234567890987654323456789009876543209<NL>98765432109876543210987654321234567890-098765432345678909876543213456789098765432<NL>234567890987654321234567890987654323456789009876543209876543210987654321098765432<NL>21234567890-098765432345678909876543213456789098765432345678909876543212345678909<NL>9876543234567890098765432098765432109876543210987654321234567890-0987654323456789<NL>909876543213456789098765432345678909876543212345678909876543234567890098765432098<NL>8765432109876543210987654321234567890-0987654323456789098765432134567890987654323<NL>345678909876543212345678909876543234567890098765432098765432109876543210987654321<NL>1234567890-0987654323456789098765432134567890987654323456789098765432123456789098<NL>87654323456789009876543209876543210987654321<ESC>[A<ESC>[A876543209876543210987654321<ESC>[K<NL><NL><ESC>[K<NL><NL><ESC>[K<ESC>[A<ESC>[A34567890987654321234567890987654323456789009876543209876543210987654321<ESC>[A<NL>876543210987654321<ESC>[K<NL><NL><ESC>[K<ESC>[A876543210987654321<ESC>[A<ESC>[A876543209876543210987654321<ESC>[K<NL><NL><ESC>[K<NL><NL><ESC>[K<ESC>[A<ESC>[A987654323456789009876543209876543210987654321<ESC>[A<ESC>[A876543209876543210987654321<ESC>[K<NL><NL><ESC>[K<NL><NL><ESC>[K<ESC>[A<ESC>[A234567890987654321234567890987654323456789009876543209876543210987654321<ESC>[A<NL>9876543210987654321<ESC>[K<NL><NL><ESC>[K<ESC>[A9876543210987654321<ESC>[A<ESC>[Awget http://localhost:8080/09876543<ESC>[12P123456789.html<NL><NL><ESC>[K<NL>,
CMBEGIN,,,wget http://localhost:8081,%--2018-11-21 12:17:46--  http://localhost:8081/conr.html<NL>Resolving localhost (localhost)... 127.0.0.1<NL>Connecting to localhost (localhost)|127.0.0.1|:8081... connected.<NL>HTTP request sent%% awaiting response... 404 Not Found<NL>2018-11-21 12:17:46 ERROR 404: Not Found.<NL>%,
CMBEGIN,,,cd /usr/src/fhttpd,,
CMBEGIN,Nov 21 12:18:04,/usr/src/fhttpd,ls,frobnick  index.html  Makefile<HT>webserver  webserver.c,ls
CMBEGIN,Nov 21 12:18:34,/usr/src/fhttpd,emacs webserver.c,%=><NL>=-111:----F1  *scratch*      All L1     (Fundamental) ---------------------------<NL>Loading 00debian-vars...done<NL>/etc/emacs/site-start.d/50autoconf.el (source)...<NL>done<NL>Loading /etc/emacs/site-start.d/50autoconf.el (source)...doneFile Edit Options Buffers Tools Lisp-Interaction Help                           <NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL>-111:----F1  *scratch*      All L1     (Lisp Interaction) ----------------------<NL>For information about GNU Emacs and the GNU system%% type C-h C-a.<NL>Note: file is write protected<NL>Note: file is write protectedFile Edit Options Buffers Tools C Help                                          <NL><NL>// webserver.c                                                                  <NL><NL>// FrobozzCo Official Webserver                                                 <NL><NL>// Barbazzo Fernap barbazzo@gue.com                                             <NL><NL>// Gustar Woomax gustar@gue.com                                                 <NL><NL>// Wilbar Memboob wilbar@gue.com                                                <NL><NL><NL>// By the Frobozz Magic Webserver Company                                       <NL><NL>// Released under the Grue Public License                                       <NL><NL>// Frobruary 14th%% 1067 GUE                                                     <NL><NL><NL>// THERE IS NO WARRANTY FOR THE PROGRAM%% TO THE EXTENT PERMITTED                <NL><NL>// BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE               <NL><NL>// COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \u201CAS IS\u201D\<NL><NL>                                                                                <NL><NL>// WITHOUT WARRANTY OF ANY KIND%% EITHER EXPRESSED OR IMPLIED%% INCLUDING%%        <NL><NL>// BUT NOT LIMITED TO%% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND            <NL><NL>// FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY          <NL><NL>// AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE         <NL><NL>// DEFECTIVE%% *AND IT WILL*%% YOU ASSUME THE COST OF ALL NECESSARY               <NL><NL>// SERVICING%% REPAIR OR CORRECTION.                                             <NL><NL><NL>-11U:%%%%--F1  webserver.c    Top L1     (C/l Abbrev) ----------------------------<NL>2<NL><NL>345678910123<NL>45678920<NL><NL>#include <stdio.h><NL>#include <errno.h><NL>#include <string.h><NL>#include <stdlib.h><NL>#include <netdb.h><NL>#include <sys/stat.h><NL>#include <sys/types.h><NL>#include <sys/socket.h><NL>#include <netinet/in.h><NL>#include <arpa/inet.h> 2%% L212345678930<NL>#include <unistd.h><NL>#include <fcntl.h><NL>#include <time.h><NL>#include <pthread.h><NL><NL>#define _XOPEN_SOURCE<NL><NL>typedef struct {<NL>        char *method;<NL>        char *uri;<NL>        char *version;7%% L3123456789401<NL>fcntl<NL>time.h>pthread.h><NL><NL>define _XOPEN_SOURCE<NL><NL>typedef struct {<NL>        char *method;<NL>        char *uri;<NL>        char *version;<NL>        char *headers;<NL>} httpreq_t;<NL><NL><NL>/* NOTE: this function is based on a function provided in the GNU "timegm" man  <NL>   page. timegm is a GNU extension to time.h that returns the given tm struct a\<NL>s                                                                               <NL>   a UNIX timestamp in GMT/UTC%% rather than local time. The man page suggests a<NL>   function similar to the one below as a portable equivalent.                  <NL> */<NL>time_t my_timegm(struct tm *tm) {<NL>9%% L4234567<NL>89501<NL>        time_t ret;<NL>        char *tz;<NL><NL>        tz = getenv("TZ");<NL>        putenv("TZ=GMT");<NL>        tzset();<NL>        ret = mktime(tm);<NL>        if (tz) {<NL>                char envstr[strlen(tz) + 4];<NL>                envstr[0] = '\0';<NL>10%% L5214976543<NL><NL>2<NL>#include <unistd.h><NL>#include <fcntl.h><NL>#include <time.h><NL>#include <pthread.h><NL><NL>#define _XOPEN_SOURCE<NL><NL>typedef struct {<NL>        char *method;<NL>        char *uri;<NL>        char *version; 9%% L4103940123File Edit Options Buffers Tools C Help                                                             <NL><NL>#include <unistd.h><NL>#include <fcntl.h><NL>#include <time.h><NL>#include <pthread.h><NL><NL>#define _XOPEN_SOURCE<NL><NL>typedef struct {<NL>        char *method;<NL>        char *uri;<NL>        char *version;<NL>        char *headers;<NL>} httpreq_t;<NL><NL><NL>/* NOTE: this function is based on a function provided in the GNU "timegm" man                     <NL><NL>   page. timegm is a GNU extension to time.h that returns the given tm struct as                   <NL><NL>   a UNIX timestamp in GMT/UTC%% rather than local time. The man page suggests a                    <NL><NL>   function similar to the one below as a portable equivalent.                                     <NL><NL> */<NL>time_t my_timegm(struct tm *tm) {<NL>-11U:%%%%--F1  webserver.c     9%% L43    (C/l Abbrev) -----------------------------------------------<NL>File Edit Options Buffers Tools C Help                                                                <NL><NL>#include <unistd.h><NL>#include <fcntl.h><NL>#include <time.h><NL>#include <pthread.h><NL><NL>#define _XOPEN_SOURCE<NL><NL>typedef struct {<NL>        char *method;<NL>        char *uri;<NL>        char *version;<NL>        char *headers;<NL>} httpreq_t;<NL><NL><NL>/* NOTE: this function is based on a function provided in the GNU "timegm" man                        <NL><NL>   page. timegm is a GNU extension to time.h that returns the given tm struct as                      <NL><NL>   a UNIX timestamp in GMT/UTC%% rather than local time. The man page suggests a                       <NL><NL>   function similar to the one below as a portable equivalent.                                        <NL><NL> */<NL>time_t my_timegm(struct tm *tm) {<NL>-11U:%%%%--F1  webserver.c     9%% L43    (C/l Abbrev) --------------------------------------------------<NL>File Edit Options Buffers Tools C Help                                                                     <NL><NL>#include <unistd.h><NL>#include <fcntl.h><NL>#include <time.h><NL>#include <pthread.h><NL><NL>#define _XOPEN_SOURCE<NL><NL>typedef struct {<NL>        char *method;<NL>        char *uri;<NL>        char *version;<NL>        char *headers;<NL>} httpreq_t;<NL><NL><NL>/* NOTE: this function is based on a function provided in the GNU "timegm" man                             <NL><NL>   page. timegm is a GNU extension to time.h that returns the given tm struct as                           <NL><NL>   a UNIX timestamp in GMT/UTC%% rather than local time. The man page suggests a                            <NL><NL>   function similar to the one below as a portable equivalent.                                             <NL><NL> */<NL>time_t my_timegm(struct tm *tm) {<NL>-11U:%%%%--F1  webserver.c     9%% L43    (C/l Abbrev) -------------------------------------------------------<NL>File Edit Options Buffers Tools C Help                                                                       <NL><NL>#include <unistd.h><NL>#include <fcntl.h><NL>#include <time.h><NL>#include <pthread.h><NL><NL>#define _XOPEN_SOURCE<NL><NL>typedef struct {<NL>        char *method;<NL>        char *uri;<NL>        char *version;<NL>        char *headers;<NL>} httpreq_t;<NL><NL><NL>/* NOTE: this function is based on a function provided in the GNU "timegm" man                               <NL><NL>   page. timegm is a GNU extension to time.h that returns the given tm struct as                             <NL><NL>   a UNIX timestamp in GMT/UTC%% rather than local time. The man page suggests a                              <NL><NL>   function similar to the one below as a portable equivalent.                                               <NL><NL> */<NL>time_t my_timegm(struct tm *tm) {<NL>-11U:%%%%--F1  webserver.c     9%% L43    (C/l Abbrev) ---------------------------------------------------------<NL>File Edit Options Buffers Tools C Help                                                                               <NL><NL>#include <unistd.h><NL>#include <fcntl.h><NL>#include <time.h><NL>#include <pthread.h><NL><NL>#define _XOPEN_SOURCE<NL><NL>typedef struct {<NL>        char *method;<NL>        char *uri;<NL>        char *version;<NL>        char *headers;<NL>} httpreq_t;<NL><NL><NL>/* NOTE: this function is based on a function provided in the GNU "timegm" man                                       <NL><NL>   page. timegm is a GNU extension to time.h that returns the given tm struct as                                     <NL><NL>   a UNIX timestamp in GMT/UTC%% rather than local time. The man page suggests a                                      <NL><NL>   function similar to the one below as a portable equivalent.                                                       <NL><NL> */<NL>time_t my_timegm(struct tm *tm) {<NL>-11U:%%%%--F1  webserver.c     9%% L43    (C/l Abbrev) -----------------------------------------------------------------<NL>File Edit Options Buffers Tools C Help                                                                                  <NL><NL>#include <unistd.h><NL>#include <fcntl.h><NL>#include <time.h><NL>#include <pthread.h><NL><NL>#define _XOPEN_SOURCE<NL><NL>typedef struct {<NL>        char *method;<NL>        char *uri;<NL>        char *version;<NL>        char *headers;<NL>} httpreq_t;<NL><NL><NL>/* NOTE: this function is based on a function provided in the GNU "timegm" man                                          <NL><NL>   page. timegm is a GNU extension to time.h that returns the given tm struct as                                        <NL><NL>   a UNIX timestamp in GMT/UTC%% rather than local time. The man page suggests a                                         <NL><NL>   function similar to the one below as a portable equivalent.                                                          <NL><NL> */<NL>time_t my_timegm(struct tm *tm) {<NL>-11U:%%%%--F1  webserver.c     9%% L43    (C/l Abbrev) --------------------------------------------------------------------<NL>File Edit Options Buffers Tools C Help                                                                                        <NL><NL>#include <unistd.h><NL>#include <fcntl.h><NL>#include <time.h><NL>#include <pthread.h><NL><NL>#define _XOPEN_SOURCE<NL><NL>typedef struct {<NL>        char *method;<NL>        char *uri;<NL>        char *version;<NL>        char *headers;<NL>} httpreq_t;<NL><NL><NL>/* NOTE: this function is based on a function provided in the GNU "timegm" man                                                <NL><NL>   page. timegm is a GNU extension to time.h that returns the given tm struct as                                              <NL><NL>   a UNIX timestamp in GMT/UTC%% rather than local time. The man page suggests a                                               <NL><NL>   function similar to the one below as a portable equivalent.                                                                <NL><NL> */<NL>time_t my_timegm(struct tm *tm) {<NL>-11U:%%%%--F1  webserver.c     9%% L43    (C/l Abbrev) --------------------------------------------------------------------------<NL>File Edit Options Buffers Tools C Help                                                                                                 <NL><NL>#include <unistd.h><NL>#include <fcntl.h><NL>#include <time.h><NL>#include <pthread.h><NL><NL>#define _XOPEN_SOURCE<NL><NL>typedef struct {<NL>        char *method;<NL>        char *uri;<NL>        char *version;<NL>        char *headers;<NL>} httpreq_t;<NL><NL><NL>/* NOTE: this function is based on a function provided in the GNU "timegm" man                                                         <NL><NL>   page. timegm is a GNU extension to time.h that returns the given tm struct as                                                       <NL><NL>   a UNIX timestamp in GMT/UTC%% rather than local time. The man page suggests a                                                        <NL><NL>   function similar to the one below as a portable equivalent.                                                                         <NL><NL> */<NL>time_t my_timegm(struct tm *tm) {<NL>-11U:%%%%--F1  webserver.c     9%% L43    (C/l Abbrev) -----------------------------------------------------------------------------------<NL>File Edit Options Buffers Tools C Help                                                                                                      <NL><NL>#include <unistd.h><NL>#include <fcntl.h><NL>#include <time.h><NL>#include <pthread.h><NL><NL>#define _XOPEN_SOURCE<NL><NL>typedef struct {<NL>        char *method;<NL>        char *uri;<NL>        char *version;<NL>        char *headers;<NL>} httpreq_t;<NL><NL><NL>/* NOTE: this function is based on a function provided in the GNU "timegm" man                                                              <NL><NL>   page. timegm is a GNU extension to time.h that returns the given tm struct as                                                            <NL><NL>   a UNIX timestamp in GMT/UTC%% rather than local time. The man page suggests a                                                             <NL><NL>   function similar to the one below as a portable equivalent.                                                                              <NL><NL> */<NL>time_t my_timegm(struct tm *tm) {<NL>-11U:%%%%--F1  webserver.c     9%% L43    (C/l Abbrev) ----------------------------------------------------------------------------------------<NL>File Edit Options Buffers Tools C Help                                                                                                       <NL><NL>#include <unistd.h><NL>#include <fcntl.h><NL>#include <time.h><NL>#include <pthread.h><NL><NL>#define _XOPEN_SOURCE<NL><NL>typedef struct {<NL>        char *method;<NL>        char *uri;<NL>        char *version;<NL>        char *headers;<NL>} httpreq_t;<NL><NL><NL>/* NOTE: this function is based on a function provided in the GNU "timegm" man                                                               <NL><NL>   page. timegm is a GNU extension to time.h that returns the given tm struct as                                                             <NL><NL>   a UNIX timestamp in GMT/UTC%% rather than local time. The man page suggests a                                                              <NL><NL>   function similar to the one below as a portable equivalent.                                                                               <NL><NL> */<NL>time_t my_timegm(struct tm *tm) {<NL>-11U:%%%%--F1  webserver.c     9%% L43    (C/l Abbrev) -----------------------------------------------------------------------------------------<NL>File Edit Options Buffers Tools C Help                                                                                                           <NL><NL>#include <unistd.h><NL>#include <fcntl.h><NL>#include <time.h><NL>#include <pthread.h><NL><NL>#define _XOPEN_SOURCE<NL><NL>typedef struct {<NL>        char *method;<NL>        char *uri;<NL>        char *version;<NL>        char *headers;<NL>} httpreq_t;<NL><NL><NL>/* NOTE: this function is based on a function provided in the GNU "timegm" man                                                                   <NL><NL>   page. timegm is a GNU extension to time.h that returns the given tm struct as                                                                 <NL><NL>   a UNIX timestamp in GMT/UTC%% rather than local time. The man page suggests a                                                                  <NL><NL>   function similar to the one below as a portable equivalent.                                                                                   <NL><NL> */<NL>time_t my_timegm(struct tm *tm) {<NL>-11U:%%%%--F1  webserver.c     9%% L43    (C/l Abbrev) ---------------------------------------------------------------------------------------------<NL>File Edit Options Buffers Tools C Help                                                                                                             <NL><NL>#include <unistd.h><NL>#include <fcntl.h><NL>#include <time.h><NL>#include <pthread.h><NL><NL>#define _XOPEN_SOURCE<NL><NL>typedef struct {<NL>        char *method;<NL>        char *uri;<NL>        char *version;<NL>        char *headers;<NL>} httpreq_t;<NL><NL><NL>/* NOTE: this function is based on a function provided in the GNU "timegm" man                                                                     <NL><NL>   page. timegm is a GNU extension to time.h that returns the given tm struct as                                                                   <NL><NL>   a UNIX timestamp in GMT/UTC%% rather than local time. The man page suggests a                                                                    <NL><NL>   function similar to the one below as a portable equivalent.                                                                                     <NL><NL> */<NL>time_t my_timegm(struct tm *tm) {<NL>-11U:%%%%--F1  webserver.c     9%% L43    (C/l Abbrev) -----------------------------------------------------------------------------------------------<NL>File Edit Options Buffers Tools C Help                                                                                                              <NL><NL>#include <unistd.h><NL>#include <fcntl.h><NL>#include <time.h><NL>#include <pthread.h><NL><NL>#define _XOPEN_SOURCE<NL><NL>typedef struct {<NL>        char *method;<NL>        char *uri;<NL>        char *version;<NL>        char *headers;<NL>} httpreq_t;<NL><NL><NL>/* NOTE: this function is based on a function provided in the GNU "timegm" man                                                                      <NL><NL>   page. timegm is a GNU extension to time.h that returns the given tm struct as                                                                    <NL><NL>   a UNIX timestamp in GMT/UTC%% rather than local time. The man page suggests a                                                                     <NL><NL>   function similar to the one below as a portable equivalent.                                                                                      <NL><NL> */<NL>time_t my_timegm(struct tm *tm) {<NL>-11U:%%%%--F1  webserver.c     9%% L43    (C/l Abbrev) ------------------------------------------------------------------------------------------------<NL>File Edit Options Buffers Tools C Help                                                                                                               <NL><NL>#include <unistd.h><NL>#include <fcntl.h><NL>#include <time.h><NL>#include <pthread.h><NL><NL>#define _XOPEN_SOURCE<NL><NL>typedef struct {<NL>        char *method;<NL>        char *uri;<NL>        char *version;<NL>        char *headers;<NL>} httpreq_t;<NL><NL><NL>/* NOTE: this function is based on a function provided in the GNU "timegm" man                                                                       <NL><NL>   page. timegm is a GNU extension to time.h that returns the given tm struct as                                                                     <NL><NL>   a UNIX timestamp in GMT/UTC%% rather than local time. The man page suggests a                                                                      <NL><NL>   function similar to the one below as a portable equivalent.                                                                                       <NL><NL> */<NL>time_t my_timegm(struct tm *tm) {<NL>-11U:%%%%--F1  webserver.c     9%% L43    (C/l Abbrev) -------------------------------------------------------------------------------------------------<NL>File Edit Options Buffers Tools C Help                                                                                                              <NL><NL>#include <unistd.h><NL>#include <fcntl.h><NL>#include <time.h><NL>#include <pthread.h><NL><NL>#define _XOPEN_SOURCE<NL><NL>typedef struct {<NL>        char *method;<NL>        char *uri;<NL>        char *version;<NL>        char *headers;<NL>} httpreq_t;<NL><NL><NL>/* NOTE: this function is based on a function provided in the GNU "timegm" man                                                                      <NL><NL>   page. timegm is a GNU extension to time.h that returns the given tm struct as                                                                    <NL><NL>   a UNIX timestamp in GMT/UTC%% rather than local time. The man page suggests a                                                                     <NL><NL>   function similar to the one below as a portable equivalent.                                                                                      <NL><NL> */<NL>time_t my_timegm(struct tm *tm) {<NL>-11U:%%%%--F1  webserver.c     9%% L43    (C/l Abbrev) ------------------------------------------------------------------------------------------------<NL>File Edit Options Buffers Tools C Help                                                                                                             <NL><NL>#include <unistd.h><NL>#include <fcntl.h><NL>#include <time.h><NL>#include <pthread.h><NL><NL>#define _XOPEN_SOURCE<NL><NL>typedef struct {<NL>        char *method;<NL>        char *uri;<NL>        char *version;<NL>        char *headers;<NL>} httpreq_t;<NL><NL><NL>/* NOTE: this function is based on a function provided in the GNU "timegm" man                                                                     <NL><NL>   page. timegm is a GNU extension to time.h that returns the given tm struct as                                                                   <NL><NL>   a UNIX timestamp in GMT/UTC%% rather than local time. The man page suggests a                                                                    <NL><NL>   function similar to the one below as a portable equivalent.                                                                                     <NL><NL> */<NL>time_t my_timegm(struct tm *tm) {<NL>-11U:%%%%--F1  webserver.c     9%% L43    (C/l Abbrev) -----------------------------------------------------------------------------------------------<NL>File Edit Options Buffers Tools C Help                                                                                                            <NL><NL>#include <unistd.h><NL>#include <fcntl.h><NL>#include <time.h><NL>#include <pthread.h><NL><NL>#define _XOPEN_SOURCE<NL><NL>typedef struct {<NL>        char *method;<NL>        char *uri;<NL>        char *version;<NL>        char *headers;<NL>} httpreq_t;<NL><NL><NL>/* NOTE: this function is based on a function provided in the GNU "timegm" man                                                                    <NL><NL>   page. timegm is a GNU extension to time.h that returns the given tm struct as                                                                  <NL><NL>   a UNIX timestamp in GMT/UTC%% rather than local time. The man page suggests a                                                                   <NL><NL>   function similar to the one below as a portable equivalent.                                                                                    <NL><NL> */<NL>time_t my_timegm(struct tm *tm) {<NL>-11U:%%%%--F1  webserver.c     9%% L43    (C/l Abbrev) ----------------------------------------------------------------------------------------------<NL>File Edit Options Buffers Tools C Help                                                                                                          <NL><NL>#include <unistd.h><NL>#include <fcntl.h><NL>#include <time.h><NL>#include <pthread.h><NL><NL>#define _XOPEN_SOURCE<NL><NL>typedef struct {<NL>        char *method;<NL>        char *uri;<NL>        char *version;<NL>        char *headers;<NL>} httpreq_t;<NL><NL><NL>/* NOTE: this function is based on a function provided in the GNU "timegm" man                                                                  <NL><NL>   page. timegm is a GNU extension to time.h that returns the given tm struct as                                                                <NL><NL>   a UNIX timestamp in GMT/UTC%% rather than local time. The man page suggests a                                                                 <NL><NL>   function similar to the one below as a portable equivalent.                                                                                  <NL><NL> */<NL>time_t my_timegm(struct tm *tm) {<NL>-11U:%%%%--F1  webserver.c     9%% L43    (C/l Abbrev) --------------------------------------------------------------------------------------------<NL>File Edit Options Buffers Tools C Help                                                                                                         <NL><NL>#include <unistd.h><NL>#include <fcntl.h><NL>#include <time.h><NL>#include <pthread.h><NL><NL>#define _XOPEN_SOURCE<NL><NL>typedef struct {<NL>        char *method;<NL>        char *uri;<NL>        char *version;<NL>        char *headers;<NL>} httpreq_t;<NL><NL><NL>/* NOTE: this function is based on a function provided in the GNU "timegm" man                                                                 <NL><NL>   page. timegm is a GNU extension to time.h that returns the given tm struct as                                                               <NL><NL>   a UNIX timestamp in GMT/UTC%% rather than local time. The man page suggests a                                                                <NL><NL>   function similar to the one below as a portable equivalent.                                                                                 <NL><NL> */<NL>time_t my_timegm(struct tm *tm) {<NL>-11U:%%%%--F1  webserver.c     9%% L43    (C/l Abbrev) -------------------------------------------------------------------------------------------<NL>File Edit Options Buffers Tools C Help                                                                                                        <NL><NL>#include <unistd.h><NL>#include <fcntl.h><NL>#include <time.h><NL>#include <pthread.h><NL><NL>#define _XOPEN_SOURCE<NL><NL>typedef struct {<NL>        char *method;<NL>        char *uri;<NL>        char *version;<NL>        char *headers;<NL>} httpreq_t;<NL><NL><NL>/* NOTE: this function is based on a function provided in the GNU "timegm" man                                                                <NL><NL>   page. timegm is a GNU extension to time.h that returns the given tm struct as                                                              <NL><NL>   a UNIX timestamp in GMT/UTC%% rather than local time. The man page suggests a                                                               <NL><NL>   function similar to the one below as a portable equivalent.                                                                                <NL><NL> */<NL>time_t my_timegm(struct tm *tm) {<NL>-11U:%%%%--F1  webserver.c     9%% L43    (C/l Abbrev) ------------------------------------------------------------------------------------------<NL>File Edit Options Buffers Tools C Help                                                                                                      <NL><NL>#include <unistd.h><NL>#include <fcntl.h><NL>#include <time.h><NL>#include <pthread.h><NL><NL>#define _XOPEN_SOURCE<NL><NL>typedef struct {<NL>        char *method;<NL>        char *uri;<NL>        char *version;<NL>        char *headers;<NL>} httpreq_t;<NL><NL><NL>/* NOTE: this function is based on a function provided in the GNU "timegm" man                                                              <NL><NL>   page. timegm is a GNU extension to time.h that returns the given tm struct as                                                            <NL><NL>   a UNIX timestamp in GMT/UTC%% rather than local time. The man page suggests a                                                             <NL><NL>   function similar to the one below as a portable equivalent.                                                                              <NL><NL> */<NL>time_t my_timegm(struct tm *tm) {<NL>-11U:%%%%--F1  webserver.c     9%% L43    (C/l Abbrev) ----------------------------------------------------------------------------------------<NL>File Edit Options Buffers Tools C Help                                                                                                     <NL><NL>#include <unistd.h><NL>#include <fcntl.h><NL>#include <time.h><NL>#include <pthread.h><NL><NL>#define _XOPEN_SOURCE<NL><NL>typedef struct {<NL>        char *method;<NL>        char *uri;<NL>        char *version;<NL>        char *headers;<NL>} httpreq_t;<NL><NL><NL>/* NOTE: this function is based on a function provided in the GNU "timegm" man                                                             <NL><NL>   page. timegm is a GNU extension to time.h that returns the given tm struct as                                                           <NL><NL>   a UNIX timestamp in GMT/UTC%% rather than local time. The man page suggests a                                                            <NL><NL>   function similar to the one below as a portable equivalent.                                                                             <NL><NL> */<NL>time_t my_timegm(struct tm *tm) {<NL>-11U:%%%%--F1  webserver.c     9%% L43    (C/l Abbrev) ---------------------------------------------------------------------------------------<NL>File Edit Options Buffers Tools C Help                                                                                                    <NL><NL>#include <unistd.h><NL>#include <fcntl.h><NL>#include <time.h><NL>#include <pthread.h><NL><NL>#define _XOPEN_SOURCE<NL><NL>typedef struct {<NL>        char *method;<NL>        char *uri;<NL>        char *version;<NL>        char *headers;<NL>} httpreq_t;<NL><NL><NL>/* NOTE: this function is based on a function provided in the GNU "timegm" man                                                            <NL><NL>   page. timegm is a GNU extension to time.h that returns the given tm struct as                                                          <NL><NL>   a UNIX timestamp in GMT/UTC%% rather than local time. The man page suggests a                                                           <NL><NL>   function similar to the one below as a portable equivalent.                                                                            <NL><NL> */<NL>time_t my_timegm(struct tm *tm) {<NL>-11U:%%%%--F1  webserver.c     9%% L43    (C/l Abbrev) --------------------------------------------------------------------------------------<NL>File Edit Options Buffers Tools C Help                                                                                                   <NL><NL>#include <unistd.h><NL>#include <fcntl.h><NL>#include <time.h><NL>#include <pthread.h><NL><NL>#define _XOPEN_SOURCE<NL><NL>typedef struct {<NL>        char *method;<NL>        char *uri;<NL>        char *version;<NL>        char *headers;<NL>} httpreq_t;<NL><NL><NL>/* NOTE: this function is based on a function provided in the GNU "timegm" man                                                           <NL><NL>   page. timegm is a GNU extension to time.h that returns the given tm struct as                                                         <NL><NL>   a UNIX timestamp in GMT/UTC%% rather than local time. The man page suggests a                                                          <NL><NL>   function similar to the one below as a portable equivalent.                                                                           <NL><NL> */<NL>time_t my_timegm(struct tm *tm) {<NL>-11U:%%%%--F1  webserver.c     9%% L43    (C/l Abbrev) -------------------------------------------------------------------------------------<NL>File Edit Options Buffers Tools C Help                                                                                                  <NL><NL>#include <unistd.h><NL>#include <fcntl.h><NL>#include <time.h><NL>#include <pthread.h><NL><NL>#define _XOPEN_SOURCE<NL><NL>typedef struct {<NL>        char *method;<NL>        char *uri;<NL>        char *version;<NL>        char *headers;<NL>} httpreq_t;<NL><NL><NL>/* NOTE: this function is based on a function provided in the GNU "timegm" man                                                          <NL><NL>   page. timegm is a GNU extension to time.h that returns the given tm struct as                                                        <NL><NL>   a UNIX timestamp in GMT/UTC%% rather than local time. The man page suggests a                                                         <NL><NL>   function similar to the one below as a portable equivalent.                                                                          <NL><NL> */<NL>time_t my_timegm(struct tm *tm) {<NL>-11U:%%%%--F1  webserver.c     9%% L43    (C/l Abbrev) ------------------------------------------------------------------------------------<NL>File Edit Options Buffers Tools C Help                                                                                                 <NL><NL>#include <unistd.h><NL>#include <fcntl.h><NL>#include <time.h><NL>#include <pthread.h><NL><NL>#define _XOPEN_SOURCE<NL><NL>typedef struct {<NL>        char *method;<NL>        char *uri;<NL>        char *version;<NL>        char *headers;<NL>} httpreq_t;<NL><NL><NL>/* NOTE: this function is based on a function provided in the GNU "timegm" man                                                         <NL><NL>   page. timegm is a GNU extension to time.h that returns the given tm struct as                                                       <NL><NL>   a UNIX timestamp in GMT/UTC%% rather than local time. The man page suggests a                                                        <NL><NL>   function similar to the one below as a portable equivalent.                                                                         <NL><NL> */<NL>time_t my_timegm(struct tm *tm) {<NL>-11U:%%%%--F1  webserver.c     9%% L43    (C/l Abbrev) -----------------------------------------------------------------------------------<NL>File Edit Options Buffers Tools C Help                                                                                                <NL><NL>#include <unistd.h><NL>#include <fcntl.h><NL>#include <time.h><NL>#include <pthread.h><NL><NL>#define _XOPEN_SOURCE<NL><NL>typedef struct {<NL>        char *method;<NL>        char *uri;<NL>        char *version;<NL>        char *headers;<NL>} httpreq_t;<NL><NL><NL>/* NOTE: this function is based on a function provided in the GNU "timegm" man                                                        <NL><NL>   page. timegm is a GNU extension to time.h that returns the given tm struct as                                                      <NL><NL>   a UNIX timestamp in GMT/UTC%% rather than local time. The man page suggests a                                                       <NL><NL>   function similar to the one below as a portable equivalent.                                                                        <NL><NL> */<NL>time_t my_timegm(struct tm *tm) {<NL>-11U:%%%%--F1  webserver.c     9%% L43    (C/l Abbrev) ----------------------------------------------------------------------------------<NL> */<NL>time_t my_timegm(struct tm *tm) {<NL>        time_t ret;<NL>        char *tz;<NL><NL>        tz = getenv("TZ");<NL><HT>putenv("TZ=GMT");<NL>        tzset();<NL><HT>ret = mktime(tm);<NL><HT>if (tz) {<NL><HT>        char envstr[strlen(tz) + 4];<NL><HT>        envstr[0] = '\0';<NL>                strcat(envstr%% "TZ=");<NL><HT><HT>strcat(envstr%% tz);<NL><HT><HT>putenv(envstr);<NL>        } else {<NL>                putenv("TZ=");<NL>        }<NL><NL>        tzset();<NL>12%% L50<NL>        tzset();<NL><NL><HT>return ret<NL>}<NL><NL>char *get_header(const httpreq_t *req%% const char* headername) {<NL><HT>char *hdrptr;<NL><HT>char *hdrend;<NL><HT>char *retval = NULL;<NL><NL><HT>char searchstr[strlen(headername) + 5];<NL><HT>strcpy(searchstr%% "<NL>");<NL><HT>strcat(searchstr%% headername);<NL><HT>strcat(searchstr%% ": ");<NL><NL><HT>if (hdrptr = strstr(req->headers%% searchstr)) {<NL><HT><HT>hdrptr += strlen(searchstr);<NL><HT>        if (hdrend = strstr(hdrptr%% "<NL>")) {<NL><HT><HT><HT>char hdrval[1024]; // temporary return value                                                                  <NL><HT>                memcpy((char *)hdrval%% hdrptr%% (hdrend - hdrptr));<NL><HT><HT><HT>hdrval[hdrend - hdrptr] = '\0'; // tack null onto end of header value                                         <NL>5%% L69<NL><HT>                memcpy((char *)hdrval%% hdrptr%% (hdrend - hdrptr));<NL><HT><HT><HT>hdrval[hdrend - hdrptr] = '\0'; // tack null onto end of header value                                         <NL><HT>                int hdrvallen = strlen(hdrval);<NL>                        retval = (char *)malloc((hdrvallen + 1) * sizeof(char)); // malloc a space for retval                         <NL><HT><HT><HT>strcpy(retval%% (char *)hdrval);<NL>                } else {<NL><HT>                retval = (char *)malloc((strlen(hdrptr) + 1) * sizeof(char)); //                                              <NL><HT>                strcpy(retval%% hdrptr);<NL><HT>        }<NL><HT>}<NL><NL><HT>return retval;<NL>}<NL><NL>/* As long as str begins with a proper HTTP-Version followed by delim%% returns a                                                      <NL>   pointer to the start of the version number (e.g.%% 1.0). Returns NULL otherwise.                                                    <NL> */<NL>char *http_version_str(char *str%% char *delim) {<NL><HT>char *vstart = strstr(str%% "HTTP/");<NL><HT>char *vnumstart = str + 5;<NL><HT>char *vdot = strchr(str%% '.');8%% L88<NL>9<NL><NL>90123456789100Buffer is read-only: #<buffer webserver.c>99 876545642088<NL>        char *hdrend;<NL>        char *retval = NULL;<NL><NL>        char searchstr[strlen(headername) + 5];<NL>        strcpy(searchstr%% "<NL>");<NL>        strcat(searchstr%% headername);<NL>        strcat(searchstr%% ": ");<NL><NL>        if (hdrptr = strstr(req->headers%% searchstr)) {<NL>                hdrptr += strlen(searchstr);<NL>                if (hdrend = strstr(hdrptr%% "<NL>")) {<NL>                        char hdrval[1024]; // temporary return value                                                                  <NL>5%% L865432<NL><HT>                strcpy(retval%% hdrptr);<NL><HT>        }<NL><HT>}<NL><NL><HT>return retval;<NL>}<NL><NL>/* As long as str begins with a proper HTTP-Version followed by delim%% returns a                                                      <NL>   pointer to the start of the version number (e.g.%% 1.0). Returns NULL otherwise.                                                    <NL> */<NL>char *http_version_str(char *str%% char *delim) {<NL><HT>char *vstart = strstr(str%% "HTTP/");<NL><HT>char *vnumstart = str + 5;<NL><HT>char *vdot = strchr(str%% '.');<NL><HT>char *vend = strstr(str%% delim);<NL><HT>char *digits = "0123456789";<NL><HT>int majvlen = 0;<NL><HT>int minvlen = 0;<NL><NL><HT>if (!vstart || !vdot // something's missing                                                                                   <NL><HT><HT>|| vstart != str) // str doesn't start with "HTTP/"                                                                   <NL>21%% L95<NL>                return NULL;<NL><NL>        majvlen = strspn(vnumstart%% digits);<NL>        minvlen = strspn(vdot + 1%% digits);<NL><NL>        if (majvlen < 1 || (vnumstart + majvlen) != vdot // bad major version                                                         <NL><NL>                || minvlen < 1 || (vdot + minvlen + 1) != vend) // bad minor version                                                  <NL><NL>                return NULL;<NL><NL>        return vnumstart;<NL>}<NL><NL>/* Fills req with the request data from datastr. Returns 0 on success.                                                                <NL><NL> */<NL><NL>int parsereq(httpreq_t *req%% char *datastr) {<NL>        char *position;<NL>        char *last_position = datastr;<NL>        char *temp_position;<NL>4%% L114<NL><HT>char *last_position = datastr;<NL><HT>char *temp_position;<NL><HT>int matchlen;<NL><NL><HT>req->method = "";<NL><HT>req->uri = "";<NL><HT>req->version = "";<NL><HT>req->headers = "";<NL><NL><HT>if (!(position = strchr(last_position%% ' '))) {<NL><HT><HT>return 1;<NL><HT>}<NL>        matchlen = (int)(position - last_position);<NL><HT>req->method = (char *)malloc((matchlen + 1) * sizeof(char));<NL>        memcpy(req->method%% last_position%% matchlen);<NL>        req->method[matchlen] = '\0';<NL><HT>last_position = position + 1;<NL><NL><HT>if (!(position = strchr(last_position%% ' '))<NL><HT>        && !(position = strstr(last_position%% "<NL>"))) {<NL><HT>        return 1;8%% L133<NL><HT>        && !(position = strstr(last_position%% "<NL>"))) {<NL><HT>        return 1;<NL><HT>}<NL><NL>// strip any query string out of the URI                                                                                      <NL><HT>if ((temp_position = strchr(last_position%% '?')) && temp_position < position)<NL><HT>        matchlen = (int)(temp_position - last_position);<NL><HT>else<NL><HT>matchlen = (int)(position - last_position);<NL><NL><HT>req->uri = (char *)malloc((matchlen + 1) * sizeof(char));<NL><HT>memcpy(req->uri%% last_position%% matchlen);<NL><HT>req->uri[matchlen] = '\0';<NL><HT>if (position[0] == '<NL>') {<NL><HT>        req->version = "0.9";<NL><HT>        req->headers = "";<NL><HT>        return 0; // simple req -- uri only                                                                                   <NL><HT>}<NL><NL><HT>// If we get here%% it's a full request%% get the HTTP version and headers                                                      <NL><HT>last_position = position + 1;32%% L152<NL><HT>// If we get here%% it's a full request%% get the HTTP version and headers                                                      <NL><HT>last_position = position + 1;<NL><NL><HT>if (!(position = strstr(last_position%% "<NL>"))<NL><HT>        || !(last_position = http_version_str(last_position%% "<NL>"))) {<NL><HT>        return 1;<NL><HT>}<NL><NL><HT><NL>req->version = (char *)malloc((matchlen + 1) * sizeof(char));<NL><HT>memcpy(req->version%% last_position%% matchlen);<NL><HT>req->version[matchlen] = '\0';<NL><HT>last_position = position;<NL><NL><HT>req->headers = (char *)malloc(strlen(last_position) * sizeof(char));<NL><HT>strcpy(req->headers%% last_position);<NL><NL><HT>return 0;<NL>}<NL><NL>char *contype(char *ext) {6%% L171<NL><NL>char *contype(char *ext) {<NL><HT>if (strcmp(ext%% "html") == 0) return "text/html";<NL><HT>else if (strcmp(ext%% "htm") == 0) return "text/html";<NL><HT>else if (strcmp(ext%% "jpeg") == 0) return "image/jpeg";<NL><HT>else if (strcmp(ext%% "jpg") == 0) return "image/jpeg";<NL><HT>else if (strcmp(ext%% "gif") == 0) return "image/gif";<NL><HT>else if (strcmp(ext%% "txt") == 0) return "text/plain";<NL><HT>else return "application/octet-stream";<NL><NL>}<NL><NL>char *status(int statcode) {<NL><HT>if (statcode == 200)    return "200 OK";<NL><HT>else if (statcode == 304) return "304 Not Modified";<NL><HT>else if (statcode == 400) return "400 Bad Request";<NL><HT>else if (statcode == 403) return "403 Forbidden";<NL><HT>else if (statcode == 404) return "404 Not Found";<NL>        else if (statcode == 500) return "500 Internal Server Error";<NL><HT>else if (statcode == 501) return "501 Not Implemented";<NL>        else return "";40%% L190<NL><HT>else if (statcode == 501) return "501 Not Implemented";<NL>        else return "";<NL>}<NL><NL>int send_response(int sockfd%% httpreq_t *req%% int statcode) {<NL><HT>int urifd;<NL><HT>const int BUFSIZE = 1024;<NL><HT>char sendmessage[BUFSIZE];<NL><HT>char *path = req->uri;<NL><NL>        if (req->uri == NULL || req->method == NULL ||<NL><HT><HT>req->headers == NULL || req->version == NULL) {<NL>                return 0;<NL><HT>}<NL><NL><NL><HT>if ((path[0] == '/') || ((strstr(path%% "http://") == path)<NL><HT>                                                 && (path = strchr(path + 7%%  '/')))) {<NL><HT>        path += 1; // remove leading slash                                                                                    <NL><HT>        if (path[0] == '\0') {  // substituting in index.html for a blank URL!                                                <NL><HT>                path = "index.html";6%% L209<NL><HT>        if (path[0] == '\0') {  // substituting in index.html for a blank URL!                                                <NL><HT>                path = "index.html";<NL>                } else if (path[strlen(path) - 1] == '/') {<NL><HT><HT><HT>//concatenating index.html for a /-terminated URL!                                                            <NL>                        strcat(path%% "index.html");<NL><HT>        }<NL><HT>} else {<NL><HT>        statcode = 400;<NL><HT>}statcode == 200 && (urifd = open(path%% O_RDONLY%% 0)) < 0) {<NL><HT><HT>if (errno == ENOENT || errno == ENOTDIR) { // file or directory doesn't exist                                         <NL><HT><HT>        statcode = 404;<NL><HT>        } else if (errno == EACCES) { // access denied                                                                        <NL><HT><HT><HT>statcode = 403;<NL><HT><HT>} else {<NL><HT>                // some other file access problem                                                                             <NL><HT><HT><HT>statcode = 500;<NL><HT><HT>}<NL><HT>}<NL>9%% L228<NL>Buffer is read-only: #<buffer webserver.c><NL>        char *path = req->uri;<NL><NL>        if (req->uri == NULL || req->method == NULL ||<NL>                req->headers == NULL || req->version == NULL) {<NL>                return 0;<NL>        }<NL><NL><NL>        if ((path[0] == '/') || ((strstr(path%% "http://") == path)<NL>                                                         && (path = strchr(path + 7%%  '/')))) {<NL>                path += 1; // remove leading slash                                                                                    <NL>7%% L227531019        else if (statcode == 403) return "403 Forbidden";<NL>        else if (statcode == 404) return "404 Not Found";<NL>        else if (statcode == 500) return "500 Internal Server Error";<NL>        else if (statcode == 501) return "501 Not Implemented";<NL>        else return "";<NL>}<NL><NL>int send_response(int sockfd%% httpreq_t *req%% int statcode) {<NL>        int urifd;<NL>        const int BUFSIZE = 1024;<NL>        char sendmessage[BUFSIZE];4%% L216507<NL><NL><HT>        return 0; // simple req -- uri only                                                                                   <NL><HT>}<NL><NL><HT>// If we get here%% it's a full request%% get the HTTP version and headers                                                      <NL><HT>last_position = position + 1;<NL><NL><HT>if (!(position = strstr(last_position%% "<NL>"))<NL>                || !(last_position = http_version_str(last_position%% "<NL>"))) {<NL><HT>        return 1;<NL><HT>}<NL><NL><HT>matchlen = (int)(position - last_position);<NL><HT>req->version = (char *)malloc((matchlen + 1) * sizeof(char));<NL><HT>memcpy(req->version%% last_position%% matchlen);<NL><HT>req->version[matchlen] = '\0';<NL><HT>last_position = position;<NL><NL><HT>req->headers = (char *)malloc(strlen(last_position) * sizeof(char));<NL><HT>strcpy(req->headers%% last_position);<NL><NL><HT>return 0;35%% L1785        }<NL><NL>        // strip any query string out of the URI                                                                                      <NL><NL>        if ((temp_position = strchr(last_position%% '?')) && temp_position < position)<NL>                matchlen = (int)(temp_position - last_position);<NL>        else<NL>                matchlen = (int)(position - last_position);<NL><NL>        req->uri = (char *)malloc((matchlen + 1) * sizeof(char));<NL>        memcpy(req->uri%% last_position%% matchlen);<NL>        req->uri[matchlen] = '\0';<NL>        if (position[0] == '<NL>') {<NL>                req->version = "0.9";<NL>                req->headers = "";2%% L164        req->headers = "";<NL><NL>        if (!(position = strchr(last_position%% ' '))) {<NL>                return 1;<NL>        }<NL>        matchlen = (int)(position - last_position);<NL>        req->method = (char *)malloc((matchlen + 1) * sizeof(char));<NL>        memcpy(req->method%% last_position%% matchlen);<NL>        req->method[matchlen] = '\0';<NL>        last_position = position + 1;<NL><NL>        if (!(position = strchr(last_position%% ' '))<NL>                && !(position = strstr(last_position%% "<NL>"))) {<NL>                return 1;29%% L15049<NL><HT>        strcat(envstr%% "TZ=");<NL><HT><HT>strcat(envstr%% tz);<NL><HT>        putenv(envstr);<NL><HT>} else {<NL><HT>        putenv("TZ=");<NL><HT>}<NL><NL><HT>tzset();<NL><NL><HT>return ret;<NL>}<NL><NL>char *get_header(const httpreq_t *req%% const char* headername) {<NL><HT>char *hdrptr;<NL><HT>char *hdrend;<NL><HT>char *retval = NULL;<NL><NL><HT>char searchstr[strlen(headername) + 5];<NL><HT>strcpy(searchstr%% "<NL>");<NL><HT>strcat(searchstr%% headername);<NL><HT>strcat(searchstr%% ": ");<NL>14%% L72 time_t my_timegm(struct tm *tm) {<NL><HT>time_t ret;<NL><HT>char *tz;<NL><NL><HT>tz = getenv("TZ");<NL><HT>putenv("TZ=GMT");<NL><HT>tzset();<NL><HT>ret = mktime(tm);<NL><HT>if (tz) {<NL><HT>        char envstr[strlen(tz) + 4];<NL>                envstr[0] = '\0';<NL><HT><HT>strcat(envstr%% "TZ=");<NL>                strcat(envstr%% tz);<NL><HT>        putenv(envstr);<NL><HT>} else {<NL><HT>        putenv("TZ=");<NL><HT>}<NL><NL><HT>tzset();<NL><NL><HT>return ret;2%% L615<NL>#include <unistd.h><NL>#include <fcntl.h><NL>#include <time.h><NL>#include <pthread.h><NL><NL>#define _XOPEN_SOURCE<NL><NL>typedef struct {<NL><HT>char *method;<NL><HT>char *uri;<NL><HT>char *version;<NL><HT>char *headers;<NL>} httpreq_t;<NL><NL><NL>/* NOTE: this function is based on a function provided in the GNU "timegm" man                                                        <NL>   page. timegm is a GNU extension to time.h that returns the given tm struct as                                                      <NL>   a UNIX timestamp in GMT/UTC%% rather than local time. The man page suggests a                                                       <NL>   function similar to the one below as a portable equivalent.                                                                        <NL> */<NL>time_t my_timegm(struct tm *tm) {<NL> 9%% L432<NL><NL>// WITHOUT WARRANTY OF ANY KIND%% EITHER EXPRESSED OR IMPLIED%% INCLUDING%%                                                              <NL>// BUT NOT LIMITED TO%% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND                                                                  <NL>// FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY                                                                <NL>// AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE                                                               <NL>// DEFECTIVE%% *AND IT WILL*%% YOU ASSUME THE COST OF ALL NECESSARY                                                                     <NL>// SERVICING%% REPAIR OR CORRECTION.                                                                                                   <NL><NL>#include <stdio.h><NL>#include <errno.h><NL>#include <string.h><NL>#include <stdlib.h><NL>#include <netdb.h><NL>#include <sys/stat.h><NL>#include <sys/types.h><NL>#include <sys/socket.h><NL>#include <netinet/in.h><NL>#include <arpa/inet.h><NL>#include <unistd.h><NL>#include <fcntl.h><NL>#include <time.h><NL>#include <pthread.h>4%% L24317// webserver.c                                                                                                                        <NL><NL>// FrobozzCo Official Webserver                                                                                                       <NL><NL>// Barbazzo Fernap barbazzo@gue.com                                                                                                   <NL><NL>// Gustar Woomax gustar@gue.com                                                                                                       <NL><NL>// Wilbar Memboob wilbar@gue.com                                                                                                      <NL><NL><NL>// By the Frobozz Magic Webserver Company                                                                                             <NL><NL>// Released under the Grue Public License                                                                                             <NL><NL>// Frobruary 14th%% 1067 GUE                                                                                                           <NL><NL><NL>// THERE IS NO WARRANTY FOR THE PROGRAM%% TO THE EXTENT PERMITTED                                                                      <NL><NL>// BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE                                                                     <NL><NL>// COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \u201CAS IS\u201D                                                       <NL>Top L109 42<NL><NL>Beginning of buffer1<NL>2<NL><NL>357891013456789201<NL>#include <errno.h><NL>#include <string.h><NL>#include <stdlib.h><NL>#include <netdb.h><NL>#include <sys/stat.h><NL>#include <sys/types.h><NL>#include <sys/socket.h><NL>#include <netinet/in.h><NL>#include <arpa/inet.h><NL>#include <unistd.h><NL>#include <fcntl.h><NL>#include <time.h> 3%% L2356754321012356783012<NL><NL><NL>Buffer is read-only: #<buffer webserver.c><NL><NL><NL><NL><NL><NL>ESC- ESC<NL><NL><NL>-<NL><NL><NL> ESC<NL><NL><NL><NL><NL><NL>ESC-<NL><NL><NL>C-M-g is undefined<NL><NL><NL>Quit<NL><NL><NL>#include <fcntl.h><NL>#include <time.h><NL>#include <pthread.h><NL><NL>#define _XOPEN_SOURCE<NL><NL>typedef struct {<NL><HT>char *method;<NL>        char *uri;<NL>        char *version;<NL>        char *headers;<NL>} httpreq_t;<NL><NL><NL>/* NOTE: this function is based on a function provided in the GNU "timegm" man                                                        <NL>   page. timegm is a GNU extension to time.h that returns the given tm struct as                                                      <NL>   a UNIX timestamp in GMT/UTC%% rather than local time. The man page suggests a                                                       <NL>   function similar to the one below as a portable equivalent.                                                                        <NL> */<NL>time_t my_timegm(struct tm *tm) {<NL>        time_t ret;9<NL>time_t my_timegm(struct tm *tm) {<NL>        time_t ret;<NL>        char *tz;<NL><NL>        tz = getenv("TZ");<NL><HT>putenv("TZ=GMT");<NL>        tzset();<NL><HT>ret = mktime(tm);<NL><HT>if (tz) {<NL><HT>        char envstr[strlen(tz) + 4];<NL><HT>        envstr[0] = '\0';<NL>                strcat(envstr%% "TZ=");<NL><HT><HT>strcat(envstr%% tz);<NL><HT><HT>putenv(envstr);<NL>        } else {<NL>                putenv("TZ=");<NL>        }<NL><NL>        tzset();<NL><NL><HT>return ret12%% L51<NL><NL><HT>return ret<NL>}<NL><NL>char *get_header(const httpreq_t *req%% const char* headername) {<NL><HT>char *hdrptr;<NL><HT>char *hdrend;<NL><HT>char *retval = NULL;<NL><NL><HT>char searchstr[strlen(headername) + 5];<NL><HT>strcpy(searchstr%% "<NL>");<NL><HT>strcat(searchstr%% headername);<NL><HT>strcat(searchstr%% ": ");<NL><NL><HT>if (hdrptr = strstr(req->headers%% searchstr)) {<NL><HT><HT>hdrptr += strlen(searchstr);<NL><HT>        if (hdrend = strstr(hdrptr%% "<NL>")) {<NL><HT><HT><HT>char hdrval[1024]; // temporary return value                                                                  <NL><HT>                memcpy((char *)hdrval%% hdrptr%% (hdrend - hdrptr));<NL><HT><HT><HT>hdrval[hdrend - hdrptr] = '\0'; // tack null onto end of header value                                         <NL><HT>                int hdrvallen = strlen(hdrval);5%% L70<NL><HT><HT><HT>hdrval[hdrend - hdrptr] = '\0'; // tack null onto end of header value                                         <NL><HT>                int hdrvallen = strlen(hdrval);<NL>                        retval = (char *)malloc((hdrvallen + 1) * sizeof(char)); // malloc a space for retval                         <NL><HT><HT><HT>strcpy(retval%% (char *)hdrval);<NL>                } else {<NL><HT>                retval = (char *)malloc((strlen(hdrptr) + 1) * sizeof(char)); //                                              <NL><HT>                strcpy(retval%% hdrptr);<NL><HT>        }<NL><HT>}<NL><NL><HT>return retval;<NL>}<NL><NL>/* As long as str begins with a proper HTTP-Version followed by delim%% returns a                                                      <NL>   pointer to the start of the version number (e.g.%% 1.0). Returns NULL otherwise.                                                    <NL> */<NL>char *http_version_str(char *str%% char *delim) {<NL><HT>char *vstart = strstr(str%% "HTTP/");<NL><HT>char *vnumstart = str + 5;<NL><HT>char *vdot = strchr(str%% '.');<NL><HT>char *vend = strstr(str%% delim);8%% L89<NL><HT>char *vdot = strchr(str%% '.');<NL><HT>char *vend = strstr(str%% delim);<NL><HT>char *digits = "0123456789";<NL><HT>int majvlen = 0;<NL><HT>int minvlen = 0;<NL><NL><HT>if (!vstart || !vdot // something's missing                                                                                   <NL><HT><HT>|| vstart != str) // str doesn't start with "HTTP/"                                                                   <NL><HT>        return NULL;<NL><NL><HT>majvlen = strspn(vnumstart%% digits);<NL>        minvlen = strspn(vdot + 1%% digits);<NL><NL>        if (majvlen < 1 || (vnumstart + majvlen) != vdot // bad major version   <NL>                || minvlen < 1 || (vdot + minvlen + 1) != vend) // bad minor version<NL>                return NULL;<NL><NL><HT>return vnumstart;<NL>}<NL><NL>/* Fills req with the request data from datastr. Returns 0 on success.                                                                <NL>23%% L108<NL><NL>/* Fills req with the request data from datastr. Returns 0 on success.                                                                <NL> */<NL><NL>int parsereq(httpreq_t *req%% char *datastr) {<NL><HT>char *position;<NL><HT>char *last_position = datastr;<NL><HT>char *temp_position;<NL><HT>int matchlen;<NL><NL><HT>req->method = "";<NL><HT>req->uri = "";<NL><HT>req->version = "";<NL><HT>req->headers = "";<NL><NL><HT>if (!(position = strchr(last_position%% ' '))) {<NL><HT><HT>return 1;<NL><HT>}<NL>        matchlen = (int)(position - last_position);<NL><HT>req->method = (char *)malloc((matchlen + 1) * sizeof(char));<NL>        memcpy(req->method%% last_position%% matchlen);7%% L127<NL><HT>req->method = (char *)malloc((matchlen + 1) * sizeof(char));<NL>        memcpy(req->method%% last_position%% matchlen);<NL>        req->method[matchlen] = '\0';<NL><HT>last_position = position + 1;<NL><NL><HT>if (!(position = strchr(last_position%% ' '))<NL><HT>        && !(position = strstr(last_position%% "<NL>"))) {<NL><HT>        return 1;<NL><HT>}<NL><NL>// strip any query string out of the URI                                                                                      <NL><HT>if ((temp_position = strchr(last_position%% '?')) && temp_position < position)<NL><HT>        matchlen = (int)(temp_position - last_position);<NL><HT>else<NL><HT>matchlen = (int)(position - last_position);<NL><NL><HT>req->uri = (char *)malloc((matchlen + 1) * sizeof(char));<NL><HT>memcpy(req->uri%% last_position%% matchlen);<NL><HT>req->uri[matchlen] = '\0';<NL><HT>if (position[0] == '<NL>') {<NL><HT>        req->version = "0.9";30%% L146<NL><HT>if (position[0] == '<NL>') {<NL><HT>        req->version = "0.9";<NL><HT>        req->headers = "";<NL><HT>        return 0; // simple req -- uri only                                                                                   <NL><HT>}<NL><NL><HT>// If we get here%% it's a full request%% get the HTTP version and headers                                                      <NL><HT>last_position = position + 1;<NL><NL><HT>if (!(position = strstr(last_position%% "<NL>"))<NL><HT>        || !(last_position = http_version_str(last_position%% "<NL>"))) {<NL><HT>        return 1;<NL><HT>}<NL><NL><HT><NL>req->version = (char *)malloc((matchlen + 1) * sizeof(char));<NL><HT>memcpy(req->version%% last_position%% matchlen);<NL><HT>req->version[matchlen] = '\0';<NL><HT>last_position = position;<NL><NL><HT>req->headers = (char *)malloc(strlen(last_position) * sizeof(char));5%% L165<NL><NL><HT>req->headers = (char *)malloc(strlen(last_position) * sizeof(char));<NL><HT>strcpy(req->headers%% last_position);<NL><NL><HT>return 0;<NL>}<NL><NL>char *contype(char *ext) {<NL><HT>if (strcmp(ext%% "html") == 0) return "text/html";<NL><HT>else if (strcmp(ext%% "htm") == 0) return "text/html";<NL><HT>else if (strcmp(ext%% "jpeg") == 0) return "image/jpeg";<NL><HT>else if (strcmp(ext%% "jpg") == 0) return "image/jpeg";<NL><HT>else if (strcmp(ext%% "gif") == 0) return "image/gif";<NL><HT>else if (strcmp(ext%% "txt") == 0) return "text/plain";<NL><HT>else return "application/octet-stream";<NL><NL>}<NL><NL>char *status(int statcode) {<NL><HT>if (statcode == 200)    return "200 OK";<NL><HT>else if (statcode == 304) return "304 Not Modified";9%% L184<NL><HT>if (statcode == 200)    return "200 OK";<NL><HT>else if (statcode == 304) return "304 Not Modified";<NL><HT>else if (statcode == 400) return "400 Bad Request";<NL><HT>else if (statcode == 403) return "403 Forbidden";<NL><HT>else if (statcode == 404) return "404 Not Found";<NL>        else if (statcode == 500) return "500 Internal Server Error";<NL><HT>else if (statcode == 501) return "501 Not Implemented";<NL>        else return "";<NL>}<NL><NL>int send_response(int sockfd%% httpreq_t *req%% int statcode) {<NL><HT>int urifd;<NL><HT>const int BUFSIZE = 1024;<NL><HT>char sendmessage[BUFSIZE];<NL><HT>char *path = req->uri;<NL><NL>        if (req->uri == NULL || req->method == NULL ||<NL><HT><HT>req->headers == NULL || req->version == NULL) {<NL>                return 0;<NL><HT>}<NL>43%% L203<NL><HT>}<NL><NL><NL><HT>if ((path[0] == '/') || ((strstr(path%% "http://") == path)<NL><HT>                                                 && (path = strchr(path + 7%%  '/')))) {<NL><HT>        path += 1; // remove leading slash                                                                                    <NL><HT>        if (path[0] == '\0') {  // substituting in index.html for a blank URL!                                                <NL><HT>                path = "index.html";<NL>                } else if (path[strlen(path) - 1] == '/') {<NL><HT><HT><HT>//concatenating index.html for a /-terminated URL!                                                            <NL>                        strcat(path%% "index.html");<NL><HT>        }<NL><HT>} else {<NL><HT>        statcode = 400;<NL><HT>}statcode == 200 && (urifd = open(path%% O_RDONLY%% 0)) < 0) {<NL><HT><HT>if (errno == ENOENT || errno == ENOTDIR) { // file or directory doesn't exist                                         <NL><HT><HT>        statcode = 404;<NL><HT>        } else if (errno == EACCES) { // access denied                                                                        <NL><HT><HT><HT>statcode = 403;8%% L222<NL><HT>        } else if (errno == EACCES) { // access denied                                                                        <NL><HT><HT><HT>statcode = 403;<NL><HT><HT>} else {<NL><HT>                // some other file access problem                                                                             <NL><HT><HT><HT>statcode = 500;<NL><HT><HT>}<NL><HT>}<NL><NL><HT>if (strstr(path%% "..") != NULL) {<NL><HT><HT>statcode = 500;<NL><HT>}<NL><NL><NL><HT>sendmessage[0] = '\0';<NL><HT>if (strcmp(req->version%% "0.9") != 0) { // full request                                                                       <NL><HT><HT>char *ext; // file extension                                                                                          <NL><HT>        time_t curtime;<NL><HT><HT>char *imstime;<NL><HT><HT>struct tm tm;<NL><HT><HT>struct stat stbuf;<NL>53%% L241<NL><HT><HT>struct stat stbuf;<NL><NL><NL><HT><HT>if (statcode == 200) {<NL><HT><HT><HT>if (ext = strrchr(path%% '.')) ext++; // skip the '.'                                                          <NL><HT><HT>        else ext = "";<NL><HT>        } else {<NL>// errors are always html messages                                                                            <NL><HT>                ext = "html";<NL><HT><HT>}<NL><NL><HT><HT>// Conditional GET                                                                                                    <NL><HT><HT>if ((strcmp(req->method%% "GET") == 0)<NL><HT>                && (statcode == 200)<NL><HT>                && (imstime = get_header(req%% "If-Modified-Since"))) {<NL><NL><HT><HT>        // Get statistics about the requested URI from the local filesystem                                           <NL><HT><HT>        if (stat(path%% &stbuf) == -1) {<NL><HT><HT>                statcode = 500;<NL><HT><HT>        }5%% L260<NL><NL>        if (strstr(path%% "..") != NULL) {<NL>                statcode = 500;<NL>        }<NL><NL><NL>        sendmessage[0] = '\0';<NL>        if (strcmp(req->version%% "0.9") != 0) { // full request                                                                       <NL><NL>                char *ext; // file extension                                                                                          <NL><NL>                time_t curtime;<NL>                char *imstime;<NL>                struct tm tm;4%% L2586432048<NL>}<NL><NL>        if (statcode == 200 && (urifd = open(path%% O_RDONLY%% 0)) < 0) {<NL>                if (errno == ENOENT || errno == ENOTDIR) { // file or directory doesn't exist                                         <NL><NL>                        statcode = 404;<NL>                } else if (errno == EACCES) { // access denied                                                                        <NL><NL>                        statcode = 403;<NL>                } else {<NL>                        // some other file access problem                                                                             <NL><NL>                        statcode = 500;<NL>                }<NL>        }<NL>1%% L246420                time_t curtime;<NL>                char *imstime;<NL>                struct tm tm;<NL>                struct stat stbuf;<NL><NL><NL>                if (statcode == 200) {<NL>                        if (ext = strrchr(path%% '.')) ext++; // skip the '.'                                                          <NL><NL>                        else ext = "";<NL>                } else {<NL>                        // errors are always html messages                                                                            <NL><NL>                        ext = "html";<NL>                }<NL><NL>                // Conditional GET                                                                                                    <NL><NL>                if ((strcmp(req->method%% "GET") == 0)<NL>                        && (statcode == 200)<NL>                        && (imstime = get_header(req%% "If-Modified-Since"))) {<NL>4%% L255<NL><HT>                && (imstime = get_header(req%% "If-Modified-Since"))) {<NL><NL><HT><HT>        // Get statistics about the requested URI from the local filesystem                                           <NL><HT><HT>        if (stat(path%% &stbuf) == -1) {<NL><HT><HT>                statcode = 500;<NL><HT><HT>        }<NL><NL>if (!strptime(imstime%% "%%a%% %%d %%b %%Y %%H:%%M:%%S GMT"%% &tm)<NL><HT><HT>                && !strptime(imstime%% "%%a%% %%d-%%b-%%y %%H:%%M:%%S GMT"%% &tm)<NL><HT><HT><HT>        && !strptime(imstime%% "%%a %%b %%d %%H:%%M:%%S %%Y"%% &tm)) {<NL><HT><HT><HT>        // badly formatted date                                                                               <NL><HT><HT>                statcode = 400;<NL><HT><HT><HT>}<NL><NL><HT><HT>        if (stbuf.st_mtime <= my_timegm(&tm)) {<NL><HT><HT><HT><HT>// Not Modified                                                                                       <NL><HT><HT>                statcode = 304;<NL><HT><HT>        }<NL><HT><HT>}<NL><NL><HT><HT>time(&curtime); // time for Date: header                                                                              <NL>7%% L274<NL><NL><HT><HT>time(&curtime); // time for Date: header                                                                              <NL><HT><HT>strcat(sendmessage%% "HTTP/1.0 ");<NL><HT><HT>strcat(sendmessage%% status(statcode));<NL><HT><HT>strcat(sendmessage%% "<NL>Date: ");<NL><HT><HT>strncat(sendmessage%% asctime(gmtime(&curtime))%% 24);<NL><HT><HT>strcat(sendmessage%% "<NL>Server: Frobozz Magic Software Company Webserver v.002");<NL><HT><HT>strcat(sendmessage%% "<NL>Connection: close");<NL><HT><HT>strcat(sendmessage%% "<NL>Content-Type: ");<NL><HT><HT>strcat(sendmessage%% contype(ext));<NL><HT><HT>strcat(sendmessage%% "<NL><NL>");<NL><NL><HT><NL><NL>if (statcode != 200) {<NL><HT><HT>strcat(sendmessage%% "<html><head><title>");<NL><HT><HT>strcat(sendmessage%% status(statcode));<NL><HT><HT>strcat(sendmessage%% "</title></head><body><h2>HTTP/1.0</h2><h1>");<NL><HT><HT>strcat(sendmessage%% status(statcode));<NL><HT><HT>strcat(sendmessage%% "</h1><h2>URI: ");<NL><HT><HT>strcat(sendmessage%% path);61%% L293<NL><HT><HT>strcat(sendmessage%% "</h1><h2>URI: ");<NL><HT><HT>strcat(sendmessage%% path);<NL></h2></body></html>");<NL><HT>}<NL><NL><HT>if (sendmessage[0] != '\0') {<NL><HT><HT>// send headers as long as there are headers to send                                                                  <NL><HT><HT>if (send(sockfd%% sendmessage%% strlen(sendmessage)%% 0) < 0) {<NL><HT><HT>        perror("send");<NL><HT><HT>        pthread_exit(NULL);<NL><HT><HT>}<NL><HT>}<NL><NL><HT>if (statcode == 200 && (strcmp(req->method%% "HEAD") != 0)) {<NL><HT>        // send the requested file as long as there's no error and the                                                        <NL><HT><HT>// request wasn't just for the headers                                                                                <NL><HT><HT>int readbytes;<NL><NL><HT><HT>while (readbytes = read(urifd%% sendmessage%% BUFSIZE)) {<NL><HT><HT>        if (readbytes < 0) {<NL><HT><HT>                perror("read");7%% L312<NL><HT><HT>        if (readbytes < 0) {<NL><HT><HT>                perror("read");<NL><HT><HT>                pthread_exit(NULL);<NL><HT><NL><HT><HT>if (send(sockfd%% sendmessage%% readbytes%% 0) < 0) {<NL><HT>                        perror("send");<NL><HT><HT>                pthread_exit(NULL);<NL><HT><HT>        }<NL><HT><HT>}<NL><HT>}<NL><NL><NL>void *data_thread(void *sockfd_ptr) {<NL><NL><HT>int sockfd = *(int *) sockfd_ptr;<NL><HT>const int BUFSIZE = 5;<NL><HT>char recvmessage[BUFSIZE];<NL><HT>char *headerstr = NULL;<NL><HT>char *newheaderstr = NULL;<NL><HT>int recvbytes = 0;<NL><HT>int curheadlen = 0;<NL>71%% L331<NL><HT>int recvbytes = 0;<NL><HT>int curheadlen = 0;<NL><HT>int totalheadlen = 0;<NL><HT>httpreq_t req;<NL><HT>int statcode = 200;<NL><HT>int done = 0;<NL><HT>int seen_header = 0;<NL><HT>char *header_end;<NL><HT>int content_length = 0;<NL><HT>char *qstr;<NL><NL><HT>free(sockfd_ptr); // we have the int value out of this now                                                                    <NL>        recvmessage[BUFSIZE - 1] = '\0'; // mark end of "string"                                                                      <NL><NL><HT>/* Read incoming client message from the socket */<NL><HT>while(!done && (recvbytes = recv(sockfd%% recvmessage%% BUFSIZE - 1%% 0))) {<NL><HT>        if (recvbytes < 0) {<NL><HT>                perror("recv");<NL><HT>                pthread_exit(NULL);<NL><HT>        }<NL>4%% L350<NL><HT>        }<NL><NL><NL><HT>        recvmessage[recvbytes] = '\0';<NL><NL><HT>        if (seen_header) {<NL><HT>                // getting the entity body                                                                                    <NL><HT>                content_length -= recvbytes;<NL><HT>                if (content_length <= 0) done = 1;<NL><NL><HT><HT>} else {<NL><NL><HT>                newheaderstr = (char *) malloc((totalheadlen + recvbytes + 1) * sizeof(char));<NL><HT><HT><HT>newheaderstr[totalheadlen + recvbytes] = '\0';<NL><HT>                memcpy(newheaderstr%% headerstr%% totalheadlen);<NL><HT>                memcpy(newheaderstr + totalheadlen%% recvmessage%% recvbytes);<NL><NL><HT><HT><HT>if (headerstr != NULL) {<NL><HT><HT><HT>        free(headerstr);<NL><HT><HT>7%% L369<NL>        char *header_end;<NL>        int content_length = 0;<NL>        char *qstr;<NL><NL>        free(sockfd_ptr); // we have the int value out of this now                                                                    <NL><NL>        recvmessage[BUFSIZE - 1] = '\0'; // mark end of "string"                                                                      <NL><NL><NL>        /* Read incoming client message from the socket */<NL>        while(!done && (recvbytes = recv(sockfd%% recvmessage%% BUFSIZE - 1%% 0))) {<NL>                if (recvbytes < 0) {<NL>                        perror("recv");<NL>                        pthread_exit(NULL);5%% L36765432058<NL><NL>        const int BUFSIZE = 5;<NL>        char recvmessage[BUFSIZE];<NL>        char *headerstr = NULL;<NL>        char *newheaderstr = NULL;<NL>        int recvbytes = 0;<NL>        int curheadlen = 0;<NL>        int totalheadlen = 0;<NL>        httpreq_t req;<NL>        int statcode = 200;<NL>        int done = 0;<NL>        int seen_header = 0;3%% L3565420487<NL><NL>6<NL>                        }<NL>                        if (send(sockfd%% sendmessage%% readbytes%% 0) < 0) {<NL>                                perror("send");<NL>                                pthread_exit(NULL);<NL>                        }<NL>                }<NL>        }<NL>}<NL><NL>void *data_thread(void *sockfd_ptr) {<NL><NL>        int sockfd = *(int *) sockfd_ptr;1%% L344320389401357895134<NL>        int done = 0;<NL>        int seen_header = 0;<NL>        char *header_end;<NL>        int content_length = 0;<NL>        char *qstr;<NL><NL>        free(sockfd_ptr); // we have the int value out of this now                                                                    <NL><NL>        recvmessage[BUFSIZE - 1] = '\0'; // mark end of "string"                                                                      <NL><NL><NL>        /* Read incoming client message from the socket */<NL>        while(!done && (recvbytes = recv(sockfd%% recvmessage%% BUFSIZE - 1%% 0))) {<NL>                if (recvbytes < 0) {3%% L356789602456<NL>                        perror("recv");<NL>                        pthread_exit(NULL);<NL>                }<NL><NL><NL>                recvmessage[recvbytes] = '\0';<NL><NL>                if (seen_header) {<NL>                        // getting the entity body                                                                                    <NL><NL>                        content_length -= recvbytes;<NL>                        if (content_length <= 0) done = 1;<NL>5%% L36897012345678<NL><NL>                } else {<NL><NL>                        newheaderstr = (char *) malloc((totalheadlen + recvbytes + 1) * sizeof(char));<NL>                        newheaderstr[totalheadlen + recvbytes] = '\0';<NL>                        memcpy(newheaderstr%% headerstr%% totalheadlen);<NL>                        memcpy(newheaderstr + totalheadlen%% recvmessage%% recvbytes);<NL><NL>                        if (headerstr != NULL) {<NL>                                free(headerstr);<NL>                        }7%% L379801246789<NL><NL>                        headerstr = newheaderstr;<NL>                        totalheadlen += recvbytes;<NL><NL>                        header_end = strstr(headerstr%% "<NL><NL>");<NL><NL>                        if (header_end) {<NL>                                seen_header = 1;<NL>                                header_end[2] = '\0';<NL><NL>                                if (parsereq(&req%% headerstr) != 0) {<NL><HT><HT><HT><HT><HT>statcode = 400;9%% L390123456789400<NL>                                }<NL><NL>                                if (strcmp(req.method%% "POST") == 0) {<NL><NL>                                        // grab the body length                                                                       <NL><NL>                                        char *clenstr = get_header(&req%% "Content-Length");<NL><NL>                                        if (clenstr) {<NL><NL>                                                content_length = atoi(clenstr) - ((headerstr + totalheadlen) - header_end - 4);<NL>81%% L401345678911<NL><NL>                                                if (content_length <= 0) {<NL>                                                        done = 1;<NL>                                                }<NL><NL>                                                free(clenstr);<NL><NL>                                        } else {<NL><NL>                                                statcode = 400; // bad request -- no content length                                   <NL><NL>                                                done = 1;<NL><HT><HT><HT><HT><HT>}3%% L41235678202<NL>done = 1;<NL><HT><HT><HT><HT>                }        free(clenstr);<NL><NL><HT><HT><HT><HT><HT>} else {<NL>statcode = 400; // bad request -- no content length                                   <NL><HT><HT><HT><HT><HT><HT>done = 1;<NL><HT><HT><HT><HT><HT>}<NL><NL><HT><HT><HT><HT>} else {<NL><NL><HT><HT><HT><HT><HT>// This isn't a POST%% so there's no entity body                                               <NL><HT><HT><HT><HT><HT>done = 1;if (strcmp(req.method%% "GET") != 0&& strcmp(req.method%% "HEAD") != 0) {<NL><NL><HT><HT><HT><HT><HT><HT>statcode = 501; // unknown request method                                             <NL>5%% L423467930123<NL><NL>                                }<NL>                        } // end of "if (header)end)"                                                                                 <NL><NL>                }<NL>        } // end of recv while loop                                                                                                   <NL><NL><NL>        // used to deref a NULL pointer here... :(                                                                                    <NL><NL>        if (headerstr != NULL) {<NL>                printf("%%s<NL>"%% headerstr);<NL>                free(headerstr);<NL>        }6%% L434567894134<NL><NL>        send_response(sockfd%% &req%% statcode);<NL>        close(sockfd);<NL><NL>        return NULL;<NL><NL>}<NL><NL>int main(int argc%% char *argv[]) {<NL>        int acc%% sockfd%% clen%% port;<NL>        struct hostent *he;8%% L4456789535<NL>        struct sockaddr_in caddr%% saddr;<NL><NL>        if(argc <= 1) {<NL><NL>                fprintf(stderr%% "No port specified. Exiting!<NL>");<NL>                exit(1);<NL><NL>        }<NL><NL>        port = atoi(argv[1]);<NL>9%% L45689602346<NL><NL><HT>if(argc <= 1) {<NL><NL><HT>        fprintf(stderr%% "No port specified. Exiting!<NL>");<NL><HT><HT>exit(1);<NL><NL><HT>}<NL><NL><HT>port = atoi(argv[1]);<NL><NL><HT>/* Obtain name and address for the local host */<NL><HT>if((he=gethostbyname("localhost"))==NULL) {<NL><NL><HT><HT>herror("gethostbyname");<NL><HT><HT>exit(1);<NL><NL><HT>}<NL><NL><HT>/* Open a TCP (Internet Stream) socket */<NL><HT>if((sockfd=socket(AF_INET%%SOCK_STREAM%%0)) == -1) {91%% L467897012169765420598<NL><NL>960123456789701234567<NL><NL>                perror("socket");<NL>                exit(1);<NL><NL>        }<NL><NL>        /* Create socket address structure for the local host */<NL>        memset((char *) &saddr%% '\0'%% sizeof(saddr));<NL>        saddr.sin_family=AF_INET;<NL>        saddr.sin_port=htons(port);<NL>        saddr.sin_addr.s_addr=htonl(INADDR_ANY);2%% L47898012345678<NL><NL>        /* Bind our local address so that the client can send to us */<NL>        if(bind(sockfd%%(struct sockaddr *) &saddr%%sizeof(saddr)) == -1) {<NL>                perror("bind");<NL>                exit(1);<NL>        }<NL><NL>        if(listen(sockfd%%5) < 0) {<NL>                perror("listen");<NL>                exit(1);<NL>        }3%% L489901235789<NL><NL>        /* Infinite loop for receiving and processing client requests */<NL>        for(;;) {<NL>                clen=sizeof(caddr);<NL><NL>                /* Wait for a connection for a client process */<NL>                acc=accept(sockfd%%(struct sockaddr *) &caddr%%(socklen_t*)&clen);<NL>                if(acc < 0) {<NL>                        perror("accept");<NL>                        exit(1);<NL>                } else {<NL>pthread_t *thread = (pthread_t *) malloc(sizeof(pthread_t));6%% L50012345678910<NL>                        int *sockfd_ptr = (int *) malloc(sizeof(int));<NL><NL>                        *sockfd_ptr = acc;<NL>                        pthread_create(thread%% NULL%% data_thread%% sockfd_ptr);<NL>                }<NL>        }<NL><NL>        return 0;<NL>}<NL><NL>Bot L5112345678920<NL><NL><NL>End of buffer<NL><NL><NL><NL><NL><NL>(No files need saving)<NL><NL><NL>>%,emacs webserver.c
CMBEGIN,Nov 21 12:24:38,/usr/src/fhttpd,grep -n strcpy webserver.c,%80:<HT>strcpy(searchstr%% \"\<NL>\<NL>\");<NL>92:<HT><HT><HT>strcpy(retval%% (char *)hdrval);<NL>95:<HT><HT><HT>strcpy(retval%% hdrptr);<NL>186:<HT>strcpy(req->headers%% last_position);%,grep -n strcpy webserver.c
CMBEGIN,,,grep -n gets,,
CMBEGIN,,,grep -n printf,%442:<HT><HT>printf(\"%%s\<NL>\"%% headerstr);<NL>460:<HT><HT>fprintf(stderr%% \"No port specified. Exiting!\<NL>\");%,
CMBEGIN,,,grep -n strcat,%62:<HT><HT>strcat(envstr%% \"TZ=\");<NL>63:<HT><HT>strcat(envstr%% tz);<NL>81:<HT>strcat(searchstr%% headername);<NL>82:<HT>strcat(searchstr%% \": \");<NL>232:<HT><HT><HT>strcat(path%% \"index.html\");    <NL>295:<HT><HT>strcat(sendmessage%% \"HTTP/1.0 \");<NL>296:<HT><HT>strcat(sendmessage%% status(statcode));    <NL>297:<HT><HT>strcat(sendmessage%% \"\<NL>\<NL>Date: \");<NL>299:<HT><HT>strcat(sendmessage%% \"\<NL>\<NL>Server: Frobozz Magic Software Company Webserver v.002\");<NL>300:<HT><HT>strcat(sendmessage%% \"\<NL>\<NL>Connection: close\");<NL>301:<HT><HT>strcat(sendmessage%% \"\<NL>\<NL>Content-Type: \");    <NL>302:<HT><HT>strcat(sendmessage%% contype(ext));<NL>303:<HT><HT>strcat(sendmessage%% \"\<NL>\<NL>\<NL>\<NL>\");<NL>308:<HT><HT>strcat(sendmessage%% \"<html><head><title>\");<NL>309:<HT><HT>strcat(sendmessage%% status(statcode));<NL>310:<HT><HT>strcat(sendmessage%% \"</title></head><body><h2>HTTP/1.0</h2><h1>\");<NL>311:<HT><HT>strcat(sendmessage%% status(statcode));<NL>312:<HT><HT>strcat(sendmessage%% \"</h1><h2>URI: \");<NL>313:<HT><HT>strcat(sendmessage%% path);<NL>314:<HT><HT>strcat(sendmessage%% \"</h2></body></html>\");%,
CMBEGIN,Nov 21 12:29:29,/usr/src/fhttpd,emacs webserver.c,%=><NL>=-111:----F1  *scratch*      All L1     (Fundamental) ---------------------------------------------------------------------------------<NL>Loading 00debian-vars...done<NL>/etc/emacs/site-start.d/50autoconf.el (source)...<NL>done<NL>Loading /etc/emacs/site-start.d/50autoconf.el (source)...doneFile Edit Options Buffers Tools Lisp-Interaction Help                                                                                 <NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL>-111:----F1  *scratch*      All L1     (Lisp Interaction) ----------------------------------------------------------------------------<NL>For information about GNU Emacs and the GNU system%% type C-h C-a.<NL>Note: file is write protected<NL>Note: file is write protectedFile Edit Options Buffers Tools C Help                                                                                                <NL><NL>// webserver.c                                                                                                                        <NL><NL>// FrobozzCo Official Webserver                                                                                                       <NL><NL>// Barbazzo Fernap barbazzo@gue.com                                                                                                   <NL><NL>// Gustar Woomax gustar@gue.com                                                                                                       <NL><NL>// Wilbar Memboob wilbar@gue.com                                                                                                      <NL><NL><NL>// By the Frobozz Magic Webserver Company                                                                                             <NL><NL>// Released under the Grue Public License                                                                                             <NL><NL>// Frobruary 14th%% 1067 GUE                                                                                                           <NL><NL><NL>// THERE IS NO WARRANTY FOR THE PROGRAM%% TO THE EXTENT PERMITTED                                                                      <NL><NL>// BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE                                                                     <NL><NL>// COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \u201CAS IS\u201D                                                       <NL><NL>// WITHOUT WARRANTY OF ANY KIND%% EITHER EXPRESSED OR IMPLIED%% INCLUDING%%                                                              <NL><NL>// BUT NOT LIMITED TO%% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND                                                                  <NL><NL>// FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY                                                                <NL><NL>// AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE                                                               <NL><NL>// DEFECTIVE%% *AND IT WILL*%% YOU ASSUME THE COST OF ALL NECESSARY                                                                     <NL><NL>// SERVICING%% REPAIR OR CORRECTION.                                                                                                   <NL><NL><NL>#include <stdio.h><NL>-11U:%%%%--F1  webserver.c    Top L1     (C/l Abbrev) ----------------------------------------------------------------------------------<NL><NL>#include <stdio.h><NL>#include <errno.h><NL>#include <string.h><NL>#include <stdlib.h><NL>#include <netdb.h><NL>#include <sys/stat.h><NL>#include <sys/types.h><NL>#include <sys/socket.h><NL>#include <netinet/in.h><NL>#include <arpa/inet.h><NL>#include <unistd.h><NL>#include <fcntl.h><NL>#include <time.h><NL>#include <pthread.h><NL><NL>#define _XOPEN_SOURCE<NL><NL>typedef struct {<NL><HT>char *method;<NL>        char *uri; 7%% L20<NL><HT>char *method;<NL>        char *uri;<NL>        char *version;<NL>        char *headers;<NL>} httpreq_t;<NL><NL><NL>/* NOTE: this function is based on a function provided in the GNU "timegm" man                                                        <NL>   page. timegm is a GNU extension to time.h that returns the given tm struct as                                                      <NL>   a UNIX timestamp in GMT/UTC%% rather than local time. The man page suggests a                                                       <NL>   function similar to the one below as a portable equivalent.                                                                        <NL> */<NL>time_t my_timegm(struct tm *tm) {<NL>        time_t ret;<NL>        char *tz;<NL><NL>        tz = getenv("TZ");<NL><HT>putenv("TZ=GMT");<NL>        tzset();<NL><HT>ret = mktime(tm);<NL><HT>if (tz) {9%% L39<NL><HT>ret = mktime(tm);<NL><HT>if (tz) {<NL><HT>        char envstr[strlen(tz) + 4];<NL><HT>        envstr[0] = '\0';<NL>                strcat(envstr%% "TZ=");<NL><HT><HT>strcat(envstr%% tz);<NL><HT><HT>putenv(envstr);<NL>        } else {<NL>                putenv("TZ=");<NL>        }<NL><NL>        tzset();<NL><NL><HT>return ret<NL>}<NL><NL>char *get_header(const httpreq_t *req%% const char* headername) {<NL><HT>char *hdrptr;<NL><HT>char *hdrend;<NL><HT>char *retval = NULL;<NL>13%% L58<NL><HT>char *retval = NULL;<NL><NL><HT>char searchstr[strlen(headername) + 5];<NL><HT>strcpy(searchstr%% "<NL>");<NL><HT>strcat(searchstr%% headername);<NL><HT>strcat(searchstr%% ": ");<NL><NL><HT>if (hdrptr = strstr(req->headers%% searchstr)) {<NL><HT><HT>hdrptr += strlen(searchstr);<NL><HT>        if (hdrend = strstr(hdrptr%% "<NL>")) {<NL><HT><HT><HT>char hdrval[1024]; // temporary return value                                                                  <NL><HT>                memcpy((char *)hdrval%% hdrptr%% (hdrend - hdrptr));<NL><HT><HT><HT>hdrval[hdrend - hdrptr] = '\0'; // tack null onto end of header value                                         <NL><HT>                int hdrvallen = strlen(hdrval);<NL>                        retval = (char *)malloc((hdrvallen + 1) * sizeof(char)); // malloc a space for retval                         <NL><HT><HT><HT>strcpy(retval%% (char *)hdrval);<NL>                } else {<NL><HT>                retval = (char *)malloc((strlen(hdrptr) + 1) * sizeof(char)); //                                              <NL><HT>                strcpy(retval%% hdrptr);<NL><HT>        }<NL><HT>}5%% L77<NL><HT>        }<NL><HT>}<NL><NL><HT>return retval;<NL>}<NL><NL>/* As long as str begins with a proper HTTP-Version followed by delim%% returns a                                                      <NL>   pointer to the start of the version number (e.g.%% 1.0). Returns NULL otherwise.                                                    <NL> */<NL>char *http_version_str(char *str%% char *delim) {<NL><HT>char *vstart = strstr(str%% "HTTP/");<NL><HT>char *vnumstart = str + 5;<NL><HT>char *vdot = strchr(str%% '.');<NL><HT>char *vend = strstr(str%% delim);<NL><HT>char *digits = "0123456789";<NL><HT>int majvlen = 0;<NL><HT>int minvlen = 0;<NL><NL><HT>if (!vstart || !vdot // something's missing                                                                                   <NL><HT><HT>|| vstart != str) // str doesn't start with "HTTP/"                                                                   <NL><HT>        return NULL;<NL>21%% L96<NL><HT><HT>|| vstart != str) // str doesn't start with "HTTP/"                                                                   <NL><HT>        return NULL;<NL><NL><HT>majvlen = strspn(vnumstart%% digits);<NL>        minvlen = strspn(vdot + 1%% digits);<NL><NL>        if (majvlen < 1 || (vnumstart + majvlen) != vdot // bad major version   <NL>                || minvlen < 1 || (vdot + minvlen + 1) != vend) // bad minor version<NL>                return NULL;<NL><NL><HT>return vnumstart;<NL>}<NL><NL>/* Fills req with the request data from datastr. Returns 0 on success.                                                                <NL> */<NL><NL>int parsereq(httpreq_t *req%% char *datastr) {<NL><HT>char *position;<NL><HT>char *last_position = datastr;<NL><HT>char *temp_position;<NL><HT>int matchlen;4%% L115<NL><HT>char *temp_position;<NL><HT>int matchlen;<NL><NL><HT>req->method = "";<NL><HT>req->uri = "";<NL><HT>req->version = "";<NL><HT>req->headers = "";<NL><NL><HT>if (!(position = strchr(last_position%% ' '))) {<NL><HT><HT>return 1;<NL><HT>}<NL>        matchlen = (int)(position - last_position);<NL><HT>req->method = (char *)malloc((matchlen + 1) * sizeof(char));<NL>        memcpy(req->method%% last_position%% matchlen);<NL>        req->method[matchlen] = '\0';<NL><HT>last_position = position + 1;<NL><NL><HT>if (!(position = strchr(last_position%% ' '))<NL><HT>        && !(position = strstr(last_position%% "<NL>"))) {<NL><HT>        return 1;<NL><HT>}8%% L134<NL><HT>        return 1;<NL><HT>}<NL><NL>// strip any query string out of the URI                                                                                      <NL><HT>if ((temp_position = strchr(last_position%% '?')) && temp_position < position)<NL><HT>        matchlen = (int)(temp_position - last_position);<NL><HT>else<NL><HT>matchlen = (int)(position - last_position);<NL><NL><HT>req->uri = (char *)malloc((matchlen + 1) * sizeof(char));<NL><HT>memcpy(req->uri%% last_position%% matchlen);<NL><HT>req->uri[matchlen] = '\0';<NL><HT>if (position[0] == '<NL>') {<NL><HT>        req->version = "0.9";<NL><HT>        req->headers = "";<NL><HT>        return 0; // simple req -- uri only                                                                                   <NL><HT>}<NL><NL><HT>// If we get here%% it's a full request%% get the HTTP version and headers                                                      <NL><HT>last_position = position + 1;<NL>32%% L153<NL><HT>last_position = position + 1;<NL><NL><HT>if (!(position = strstr(last_position%% "<NL>"))<NL><HT>        || !(last_position = http_version_str(last_position%% "<NL>"))) {<NL><HT>        return 1;<NL><HT>}<NL><NL><HT><NL>req->version = (char *)malloc((matchlen + 1) * sizeof(char));<NL><HT>memcpy(req->version%% last_position%% matchlen);<NL><HT>req->version[matchlen] = '\0';<NL><HT>last_position = position;<NL><NL><HT>req->headers = (char *)malloc(strlen(last_position) * sizeof(char));<NL><HT>strcpy(req->headers%% last_position);<NL><NL><HT>return 0;<NL>}<NL><NL>char *contype(char *ext) {<NL><HT>if (strcmp(ext%% "html") == 0) return "text/html";6%% L172<NL>char *contype(char *ext) {<NL><HT>if (strcmp(ext%% "html") == 0) return "text/html";<NL><HT>else if (strcmp(ext%% "htm") == 0) return "text/html";<NL><HT>else if (strcmp(ext%% "jpeg") == 0) return "image/jpeg";<NL><HT>else if (strcmp(ext%% "jpg") == 0) return "image/jpeg";<NL><HT>else if (strcmp(ext%% "gif") == 0) return "image/gif";<NL><HT>else if (strcmp(ext%% "txt") == 0) return "text/plain";<NL><HT>else return "application/octet-stream";<NL><NL>}<NL><NL>char *status(int statcode) {<NL><HT>if (statcode == 200)    return "200 OK";<NL><HT>else if (statcode == 304) return "304 Not Modified";<NL><HT>else if (statcode == 400) return "400 Bad Request";<NL><HT>else if (statcode == 403) return "403 Forbidden";<NL><HT>else if (statcode == 404) return "404 Not Found";<NL>        else if (statcode == 500) return "500 Internal Server Error";<NL><HT>else if (statcode == 501) return "501 Not Implemented";<NL>        else return "";<NL>}40%% L191<NL>        else return "";<NL>}<NL><NL>int send_response(int sockfd%% httpreq_t *req%% int statcode) {<NL><HT>int urifd;<NL><HT>const int BUFSIZE = 1024;<NL><HT>char sendmessage[BUFSIZE];<NL><HT>char *path = req->uri;<NL><NL>        if (req->uri == NULL || req->method == NULL ||<NL><HT><HT>req->headers == NULL || req->version == NULL) {<NL>                return 0;<NL><HT>}<NL><NL><NL><HT>if ((path[0] == '/') || ((strstr(path%% "http://") == path)<NL><HT>                                                 && (path = strchr(path + 7%%  '/')))) {<NL><HT>        path += 1; // remove leading slash                                                                                    <NL><HT>        if (path[0] == '\0') {  // substituting in index.html for a blank URL!                                                <NL><HT>                path = "index.html";<NL>                } else if (path[strlen(path) - 1] == '/') {6%% L210<NL><HT>                path = "index.html";<NL>                } else if (path[strlen(path) - 1] == '/') {<NL><HT><HT><HT>//concatenating index.html for a /-terminated URL!                                                            <NL>                        strcat(path%% "index.html");<NL><HT>        }<NL><HT>} else {<NL><HT>        statcode = 400;<NL><HT>}statcode == 200 && (urifd = open(path%% O_RDONLY%% 0)) < 0) {<NL><HT><HT>if (errno == ENOENT || errno == ENOTDIR) { // file or directory doesn't exist                                         <NL><HT><HT>        statcode = 404;<NL><HT>        } else if (errno == EACCES) { // access denied                                                                        <NL><HT><HT><HT>statcode = 403;<NL><HT><HT>} else {<NL><HT>                // some other file access problem                                                                             <NL><HT><HT><HT>statcode = 500;<NL><HT><HT>}<NL><HT>}<NL><NL><HT>if (strstr(path%% "..") != NULL) {50%% L229<NL><NL><HT>if (strstr(path%% "..") != NULL) {<NL><HT><HT>statcode = 500;<NL><HT>}<NL><NL><NL><HT>sendmessage[0] = '\0';<NL><HT>if (strcmp(req->version%% "0.9") != 0) { // full request                                                                       <NL><HT><HT>char *ext; // file extension                                                                                          <NL><HT>        time_t curtime;<NL><HT><HT>char *imstime;<NL><HT><HT>struct tm tm;<NL><HT><HT>struct stat stbuf;<NL><NL><NL><HT><HT>if (statcode == 200) {<NL><HT><HT><HT>if (ext = strrchr(path%% '.')) ext++; // skip the '.'                                                          <NL><HT><HT>        else ext = "";<NL><HT>        } else {<NL>// errors are always html messages                                                                            <NL><HT>                ext = "html";4%% L248<NL><HT><HT><HT>// errors are always html messages                                                                            <NL><HT>                ext = "html";<NL><HT><HT>}<NL><NL><HT><HT>// Conditional GET                                                                                                    <NL><HT><HT>if ((strcmp(req->method%% "GET") == 0)<NL><HT>                && (statcode == 200)<NL><HT>                && (imstime = get_header(req%% "If-Modified-Since"))) {<NL><NL><HT><HT>        // Get statistics about the requested URI from the local filesystem                                           <NL><HT><HT>        if (stat(path%% &stbuf) == -1) {<NL><HT><HT>                statcode = 500;<NL><HT><HT>        }<NL><NL>if (!strptime(imstime%% "%%a%% %%d %%b %%Y %%H:%%M:%%S GMT"%% &tm)<NL><HT><HT>                && !strptime(imstime%% "%%a%% %%d-%%b-%%y %%H:%%M:%%S GMT"%% &tm)<NL><HT><HT><HT>        && !strptime(imstime%% "%%a %%b %%d %%H:%%M:%%S %%Y"%% &tm)) {<NL><HT><HT><HT>        // badly formatted date                                                                               <NL><HT><HT>                statcode = 400;<NL><HT><HT><HT>}<NL>6%% L267<NL><HT><HT><HT>}<NL><NL><HT><HT>        if (stbuf.st_mtime <= my_timegm(&tm)) {<NL><HT><HT><HT><HT>// Not Modified                                                                                       <NL><HT><HT>                statcode = 304;<NL><HT><HT>        }<NL><HT><HT>}<NL><NL><HT><HT>time(&curtime); // time for Date: header                                                                              <NL><HT><HT>strcat(sendmessage%% "HTTP/1.0 ");<NL><HT><HT>strcat(sendmessage%% status(statcode));<NL><HT><HT>strcat(sendmessage%% "<NL>Date: ");<NL><HT><HT>strncat(sendmessage%% asctime(gmtime(&curtime))%% 24);<NL><HT><HT>strcat(sendmessage%% "<NL>Server: Frobozz Magic Software Company Webserver v.002");<NL><HT><HT>strcat(sendmessage%% "<NL>Connection: close");<NL><HT><HT>strcat(sendmessage%% "<NL>Content-Type: ");<NL><HT><HT>strcat(sendmessage%% contype(ext));<NL><HT><HT>strcat(sendmessage%% "<NL><NL>");<NL><NL><HT>61%% L286<NL><HT><NL><NL>if (statcode != 200) {<NL><HT><HT>strcat(sendmessage%% "<html><head><title>");<NL><HT><HT>strcat(sendmessage%% status(statcode));<NL><HT><HT>strcat(sendmessage%% "</title></head><body><h2>HTTP/1.0</h2><h1>");<NL><HT><HT>strcat(sendmessage%% status(statcode));<NL><HT><HT>strcat(sendmessage%% "</h1><h2>URI: ");<NL><HT><HT>strcat(sendmessage%% path);<NL></h2></body></html>");<NL><HT>}<NL><NL><HT>if (sendmessage[0] != '\0') {<NL><HT><HT>// send headers as long as there are headers to send                                                                  <NL><HT><HT>if (send(sockfd%% sendmessage%% strlen(sendmessage)%% 0) < 0) {<NL><HT><HT>        perror("send");<NL><HT><HT>        pthread_exit(NULL);<NL><HT><HT>}<NL><HT>}<NL><NL><HT>if (statcode == 200 && (strcmp(req->method%% "HEAD") != 0)) {5%% L305<NL><NL><HT>if (statcode == 200 && (strcmp(req->method%% "HEAD") != 0)) {<NL><HT>        // send the requested file as long as there's no error and the                                                        <NL><HT><HT>// request wasn't just for the headers                                                                                <NL><HT><HT>int readbytes;<NL><NL><HT><HT>while (readbytes = read(urifd%% sendmessage%% BUFSIZE)) {<NL><HT><HT>        if (readbytes < 0) {<NL><HT><HT>                perror("read");<NL><HT><HT>                pthread_exit(NULL);<NL><HT><NL><HT><HT>if (send(sockfd%% sendmessage%% readbytes%% 0) < 0) {<NL><HT>                        perror("send");<NL><HT><HT>                pthread_exit(NULL);<NL><HT><HT>        }<NL><HT><HT>}<NL><HT>}<NL><NL><NL>void *data_thread(void *sockfd_ptr) {<NL>9%% L324<NL>strcat(sendmessage%% path);<NL>                strcat(sendmessage%% "</h2></body></html>");<NL>        }<NL><NL>        if (sendmessage[0] != '\0') {<NL>                // send headers as long as there are headers to send                                                                  <NL><NL>                if (send(sockfd%% sendmessage%% strlen(sendmessage)%% 0) < 0) {<NL>                        perror("send");<NL>                        pthread_exit(NULL);<NL>                }<NL>        }<NL>7%% L32<NL><NL><HT><NL>019876543                strcat(sendmessage%% contype(ext));<NL>                strcat(sendmessage%% "<NL><NL>");<NL><NL>        }<NL><NL>        if (statcode != 200) {<NL>                strcat(sendmessage%% "<html><head><title>");<NL>                strcat(sendmessage%% status(statcode));<NL>                strcat(sendmessage%% "</title></head><body><h2>HTTP/1.0</h2><h1>");<NL>                strcat(sendmessage%% status(statcode));<NL>                strcat(sendmessage%% "</h1><h2>URI: ");4%% L31210098765432                        }<NL>                }<NL><NL>                time(&curtime); // time for Date: header                                                                              <NL><NL>                strcat(sendmessage%% "HTTP/1.0 ");<NL>                strcat(sendmessage%% status(statcode));<NL>                strcat(sendmessage%% "<NL>Date: ");<NL>                strncat(sendmessage%% asctime(gmtime(&curtime))%% 24);<NL>                strcat(sendmessage%% "<NL>Server: Frobozz Magic Software Company Webserver v.002");<NL>                strcat(sendmessage%% "<NL>Connection: close");<NL>                strcat(sendmessage%% "<NL>Content-Type: ");1%% L301029987654321<NL>                        if (!strptime(imstime%% "%%a%% %%d %%b %%Y %%H:%%M:%%S GMT"%% &tm)<NL>                                && !strptime(imstime%% "%%a%% %%d-%%b-%%y %%H:%%M:%%S GMT"%% &tm)<NL>                                && !strptime(imstime%% "%%a %%b %%d %%H:%%M:%%S %%Y"%% &tm)) {<NL>                                // badly formatted date                                                                               <NL><NL>                                statcode = 400;<NL>                        }<NL><NL>                        if (stbuf.st_mtime <= my_timegm(&tm)) {<NL>                                // Not Modified                                                                                       <NL><NL>                                statcode = 304;59%% L29089876543210<NL>}<NL><NL>                // Conditional GET                                                                                                    <NL><NL>                if ((strcmp(req->method%% "GET") == 0)<NL>                        && (statcode == 200)<NL>                        && (imstime = get_header(req%% "If-Modified-Since"))) {<NL><NL>                        // Get statistics about the requested URI from the local filesystem                                           <NL><NL>                        if (stat(path%% &stbuf) == -1) {<NL>                                statcode = 500;<NL>                        }<NL>7%% L279876543210<NL><NL>69                char *imstime;<NL>                struct tm tm;<NL>                struct stat stbuf;<NL><NL><NL>                if (statcode == 200) {<NL>                        if (ext = strrchr(path%% '.')) ext++; // skip the '.'                                                          <NL><NL>                        else ext = "";<NL>                } else {<NL>                        // errors are always html messages                                                                            <NL><NL>                        ext = "html";5%% L26876543210598        }<NL><NL>        if (strstr(path%% "..") != NULL) {<NL>                statcode = 500;<NL>        }<NL><NL><NL>        sendmessage[0] = '\0';<NL>        if (strcmp(req->version%% "0.9") != 0) { // full request                                                                       <NL><NL>                char *ext; // file extension                                                                                          <NL><NL>                time_t curtime;4%% L2576543210498<NL><NL>7        if (statcode == 200 && (urifd = open(path%% O_RDONLY%% 0)) < 0) {<NL>                if (errno == ENOENT || errno == ENOTDIR) { // file or directory doesn't exist                                         <NL><NL>                        statcode = 404;<NL>                } else if (errno == EACCES) { // access denied                                                                        <NL><NL>                        statcode = 403;<NL>                } else {<NL>                        // some other file access problem                                                                             <NL><NL>                        statcode = 500;<NL>                }<NL>        }<NL>1%% L2465432103987<NL><NL>6        if ((path[0] == '/') || ((strstr(path%% "http://") == path)<NL>                                                         && (path = strchr(path + 7%%  '/')))) {<NL>                path += 1; // remove leading slash                                                                                    <NL><NL>                if (path[0] == '\0') {  // substituting in index.html for a blank URL!                                                <NL><NL>                        path = "index.html";<NL>                } else if (path[strlen(path) - 1] == '/') {<NL>                        //concatenating index.html for a /-terminated URL!                                                            <NL><NL>                        strcat(path%% "index.html");<NL>                }<NL>        } else {<NL>                statcode = 400;48%% L23543210298765        int urifd;<NL>        const int BUFSIZE = 1024;<NL>        char sendmessage[BUFSIZE];<NL>        char *path = req->uri;<NL><NL>        if (req->uri == NULL || req->method == NULL ||<NL>                req->headers == NULL || req->version == NULL) {<NL>                return 0;<NL>        }<NL><NL>7%% L22432101987654        if (statcode == 200)    return "200 OK";<NL>        else if (statcode == 304) return "304 Not Modified";<NL>        else if (statcode == 400) return "400 Bad Request";<NL>        else if (statcode == 403) return "403 Forbidden";<NL>        else if (statcode == 404) return "404 Not Found";<NL>        else if (statcode == 500) return "500 Internal Server Error";<NL>        else if (statcode == 501) return "501 Not Implemented";<NL>        else return "";<NL>}<NL><NL>int send_response(int sockfd%% httpreq_t *req%% int statcode) {3%% L2132100987(No files need saving)>%,emacs webserver.c
CMBEGIN,Nov 21 12:32:04,/usr/src/fhttpd,sudo sudo emacs webserver.c,%=><NL>=-111:----F1  *scratch*      All L1     (Fundamental) ---------------------------------------------------------------------------------<NL>Loading 00debian-vars...done<NL>/etc/emacs/site-start.d/50autoconf.el (source)...<NL>done<NL>Loading /etc/emacs/site-start.d/50autoconf.el (source)...doneFile Edit Options Buffers Tools Lisp-Interaction Help                                                                                 <NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL>-111:----F1  *scratch*      All L1     (Lisp Interaction) ----------------------------------------------------------------------------<NL>For information about GNU Emacs and the GNU system%% type C-h C-a.<NL>For information about GNU Emacs and the GNU system%% type C-h C-a.File Edit Options Buffers Tools C Help                                                                                                <NL><NL>// webserver.c                                                                                                                        <NL><NL>// FrobozzCo Official Webserver                                                                                                       <NL><NL>// Barbazzo Fernap barbazzo@gue.com                                                                                                   <NL><NL>// Gustar Woomax gustar@gue.com                                                                                                       <NL><NL>// Wilbar Memboob wilbar@gue.com                                                                                                      <NL><NL><NL>// By the Frobozz Magic Webserver Company                                                                                             <NL><NL>// Released under the Grue Public License                                                                                             <NL><NL>// Frobruary 14th%% 1067 GUE                                                                                                           <NL><NL><NL>// THERE IS NO WARRANTY FOR THE PROGRAM%% TO THE EXTENT PERMITTED                                                                      <NL><NL>// BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE                                                                     <NL><NL>// COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \u201CAS IS\u201D                                                       <NL><NL>// WITHOUT WARRANTY OF ANY KIND%% EITHER EXPRESSED OR IMPLIED%% INCLUDING%%                                                              <NL><NL>// BUT NOT LIMITED TO%% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND                                                                  <NL><NL>// FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY                                                                <NL><NL>// AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE                                                               <NL><NL>// DEFECTIVE%% *AND IT WILL*%% YOU ASSUME THE COST OF ALL NECESSARY                                                                     <NL><NL>// SERVICING%% REPAIR OR CORRECTION.                                                                                                   <NL><NL><NL>#include <stdio.h><NL>-11U:----F1  webserver.c    Top L1     (C/l Abbrev) ----------------------------------------------------------------------------------<NL><NL>#include <stdio.h><NL>#include <errno.h><NL>#include <string.h><NL>#include <stdlib.h><NL>#include <netdb.h><NL>#include <sys/stat.h><NL>#include <sys/types.h><NL>#include <sys/socket.h><NL>#include <netinet/in.h><NL>#include <arpa/inet.h><NL>#include <unistd.h><NL>#include <fcntl.h><NL>#include <time.h><NL>#include <pthread.h><NL><NL>#define _XOPEN_SOURCE<NL><NL>typedef struct {<NL><HT>char *method;<NL>        char *uri; 7%% L20<NL><HT>char *method;<NL>        char *uri;<NL>        char *version;<NL>        char *headers;<NL>} httpreq_t;<NL><NL><NL>/* NOTE: this function is based on a function provided in the GNU "timegm" man                                                        <NL>   page. timegm is a GNU extension to time.h that returns the given tm struct as                                                      <NL>   a UNIX timestamp in GMT/UTC%% rather than local time. The man page suggests a                                                       <NL>   function similar to the one below as a portable equivalent.                                                                        <NL> */<NL>time_t my_timegm(struct tm *tm) {<NL>        time_t ret;<NL>        char *tz;<NL><NL>        tz = getenv("TZ");<NL><HT>putenv("TZ=GMT");<NL>        tzset();<NL><HT>ret = mktime(tm);<NL><HT>if (tz) {9%% L39<NL><HT>ret = mktime(tm);<NL><HT>if (tz) {<NL><HT>        char envstr[strlen(tz) + 4];<NL><HT>        envstr[0] = '\0';<NL>                strcat(envstr%% "TZ=");<NL><HT><HT>strcat(envstr%% tz);<NL><HT><HT>putenv(envstr);<NL>        } else {<NL>                putenv("TZ=");<NL>        }<NL><NL>        tzset();<NL><NL><HT>return ret<NL>}<NL><NL>char *get_header(const httpreq_t *req%% const char* headername) {<NL><HT>char *hdrptr;<NL><HT>char *hdrend;<NL><HT>char *retval = NULL;<NL>13%% L58<NL><HT>char *retval = NULL;<NL><NL><HT>char searchstr[strlen(headername) + 5];<NL><HT>strcpy(searchstr%% "<NL>");<NL><HT>strcat(searchstr%% headername);<NL><HT>strcat(searchstr%% ": ");<NL><NL><HT>if (hdrptr = strstr(req->headers%% searchstr)) {<NL><HT><HT>hdrptr += strlen(searchstr);<NL><HT>        if (hdrend = strstr(hdrptr%% "<NL>")) {<NL><HT><HT><HT>char hdrval[1024]; // temporary return value                                                                  <NL><HT>                memcpy((char *)hdrval%% hdrptr%% (hdrend - hdrptr));<NL><HT><HT><HT>hdrval[hdrend - hdrptr] = '\0'; // tack null onto end of header value                                         <NL><HT>                int hdrvallen = strlen(hdrval);<NL>                        retval = (char *)malloc((hdrvallen + 1) * sizeof(char)); // malloc a space for retval                         <NL><HT><HT><HT>strcpy(retval%% (char *)hdrval);<NL>                } else {<NL><HT>                retval = (char *)malloc((strlen(hdrptr) + 1) * sizeof(char)); //                                              <NL><HT>                strcpy(retval%% hdrptr);<NL><HT>        }<NL><HT>}5%% L77<NL><HT>        }<NL><HT>}<NL><NL><HT>return retval;<NL>}<NL><NL>/* As long as str begins with a proper HTTP-Version followed by delim%% returns a                                                      <NL>   pointer to the start of the version number (e.g.%% 1.0). Returns NULL otherwise.                                                    <NL> */<NL>char *http_version_str(char *str%% char *delim) {<NL><HT>char *vstart = strstr(str%% "HTTP/");<NL><HT>char *vnumstart = str + 5;<NL><HT>char *vdot = strchr(str%% '.');<NL><HT>char *vend = strstr(str%% delim);<NL><HT>char *digits = "0123456789";<NL><HT>int majvlen = 0;<NL><HT>int minvlen = 0;<NL><NL><HT>if (!vstart || !vdot // something's missing                                                                                   <NL><HT><HT>|| vstart != str) // str doesn't start with "HTTP/"                                                                   <NL><HT>        return NULL;<NL>21%% L96<NL><HT><HT>|| vstart != str) // str doesn't start with "HTTP/"                                                                   <NL><HT>        return NULL;<NL><NL><HT>majvlen = strspn(vnumstart%% digits);<NL>        minvlen = strspn(vdot + 1%% digits);<NL><NL>        if (majvlen < 1 || (vnumstart + majvlen) != vdot // bad major version   <NL>                || minvlen < 1 || (vdot + minvlen + 1) != vend) // bad minor version<NL>                return NULL;<NL><NL><HT>return vnumstart;<NL>}<NL><NL>/* Fills req with the request data from datastr. Returns 0 on success.                                                                <NL> */<NL><NL>int parsereq(httpreq_t *req%% char *datastr) {<NL><HT>char *position;<NL><HT>char *last_position = datastr;<NL><HT>char *temp_position;<NL><HT>int matchlen;4%% L115<NL><HT>char *temp_position;<NL><HT>int matchlen;<NL><NL><HT>req->method = "";<NL><HT>req->uri = "";<NL><HT>req->version = "";<NL><HT>req->headers = "";<NL><NL><HT>if (!(position = strchr(last_position%% ' '))) {<NL><HT><HT>return 1;<NL><HT>}<NL>        matchlen = (int)(position - last_position);<NL><HT>req->method = (char *)malloc((matchlen + 1) * sizeof(char));<NL>        memcpy(req->method%% last_position%% matchlen);<NL>        req->method[matchlen] = '\0';<NL><HT>last_position = position + 1;<NL><NL><HT>if (!(position = strchr(last_position%% ' '))<NL><HT>        && !(position = strstr(last_position%% "<NL>"))) {<NL><HT>        return 1;<NL><HT>}8%% L134<NL><HT>        return 1;<NL><HT>}<NL><NL>// strip any query string out of the URI                                                                                      <NL><HT>if ((temp_position = strchr(last_position%% '?')) && temp_position < position)<NL><HT>        matchlen = (int)(temp_position - last_position);<NL><HT>else<NL><HT>matchlen = (int)(position - last_position);<NL><NL><HT>req->uri = (char *)malloc((matchlen + 1) * sizeof(char));<NL><HT>memcpy(req->uri%% last_position%% matchlen);<NL><HT>req->uri[matchlen] = '\0';<NL><HT>if (position[0] == '<NL>') {<NL><HT>        req->version = "0.9";<NL><HT>        req->headers = "";<NL><HT>        return 0; // simple req -- uri only                                                                                   <NL><HT>}<NL><NL><HT>// If we get here%% it's a full request%% get the HTTP version and headers                                                      <NL><HT>last_position = position + 1;<NL>32%% L153<NL><HT>last_position = position + 1;<NL><NL><HT>if (!(position = strstr(last_position%% "<NL>"))<NL><HT>        || !(last_position = http_version_str(last_position%% "<NL>"))) {<NL><HT>        return 1;<NL><HT>}<NL><NL><HT><NL>req->version = (char *)malloc((matchlen + 1) * sizeof(char));<NL><HT>memcpy(req->version%% last_position%% matchlen);<NL><HT>req->version[matchlen] = '\0';<NL><HT>last_position = position;<NL><NL><HT>req->headers = (char *)malloc(strlen(last_position) * sizeof(char));<NL><HT>strcpy(req->headers%% last_position);<NL><NL><HT>return 0;<NL>}<NL><NL>char *contype(char *ext) {<NL><HT>if (strcmp(ext%% "html") == 0) return "text/html";6%% L172<NL>char *contype(char *ext) {<NL><HT>if (strcmp(ext%% "html") == 0) return "text/html";<NL><HT>else if (strcmp(ext%% "htm") == 0) return "text/html";<NL><HT>else if (strcmp(ext%% "jpeg") == 0) return "image/jpeg";<NL><HT>else if (strcmp(ext%% "jpg") == 0) return "image/jpeg";<NL><HT>else if (strcmp(ext%% "gif") == 0) return "image/gif";<NL><HT>else if (strcmp(ext%% "txt") == 0) return "text/plain";<NL><HT>else return "application/octet-stream";<NL><NL>}<NL><NL>char *status(int statcode) {<NL><HT>if (statcode == 200)    return "200 OK";<NL><HT>else if (statcode == 304) return "304 Not Modified";<NL><HT>else if (statcode == 400) return "400 Bad Request";<NL><HT>else if (statcode == 403) return "403 Forbidden";<NL><HT>else if (statcode == 404) return "404 Not Found";<NL>        else if (statcode == 500) return "500 Internal Server Error";<NL><HT>else if (statcode == 501) return "501 Not Implemented";<NL>        else return "";<NL>}40%% L191<NL>        else return "";<NL>}<NL><NL>int send_response(int sockfd%% httpreq_t *req%% int statcode) {<NL><HT>int urifd;<NL><HT>const int BUFSIZE = 1024;<NL><HT>char sendmessage[BUFSIZE];<NL><HT>char *path = req->uri;<NL><NL>        if (req->uri == NULL || req->method == NULL ||<NL><HT><HT>req->headers == NULL || req->version == NULL) {<NL>                return 0;<NL><HT>}<NL><NL><NL><HT>if ((path[0] == '/') || ((strstr(path%% "http://") == path)<NL><HT>                                                 && (path = strchr(path + 7%%  '/')))) {<NL><HT>        path += 1; // remove leading slash                                                                                    <NL><HT>        if (path[0] == '\0') {  // substituting in index.html for a blank URL!                                                <NL><HT>                path = "index.html";<NL>                } else if (path[strlen(path) - 1] == '/') {6%% L210<NL>1<NL><NL>234567**65676Mark set<HT>ch<NL><HT>6787Mark setconst int BUFSIZE = 1024;+strlen<NL>(path);89Saving file /usr/src/fhttpd/webserver.c...Wrote /usr/src/fhttpd/webserver.c--(No files need saving)>%,sudo sudo emacs webserver.c
