CMBEGIN,Nov 28 11:49:51,/users/lclarkez,ls -rtl,total 12<NL>drwxr-xr-x 2 lclarkez 31  512 Sep 24 12:27 top_secret<NL>-rw-r--r-- 1 lclarkez 31 5725 Nov 21 12:12 index.html,ls -rtl
CMBEGIN,,,cd /usr/src/fhttpd/,,
CMBEGIN,Nov 28 11:51:19,/usr/src/fhttpd,ls,frobnick  index.html  Makefile<HT>webserver  webserver.c,ls
CMBEGIN,Nov 28 11:51:28,/usr/src/fhttpd,cp,cp: missing file operand<NL>Try 'cp --help' for more information.,cp
CMBEGIN,Nov 28 11:51:37,/usr/src/fhttpd,cp --help,%Usage: cp [OPTION]... [-T] SOURCE DEST<NL>  or:  cp [OPTION]... SOURCE... DIRECTORY<NL>  or:  cp [OPTION]... -t DIRECTORY SOURCE...<NL>Copy SOURCE to DEST%% or multiple SOURCE(s) to DIRECTORY.<NL><NL>Mandatory arguments to long options are mandatory for short options too.<NL>  -a%% --archive                same as -dR --preserve=all<NL>      --attributes-only        don't copy the file data%% just the attributes<NL>      --backup[=CONTROL]       make a backup of each existing destination file<NL>  -b                           like --backup but does not accept an argument<NL>      --copy-contents          copy contents of special files when recursive<NL>  -d                           same as --no-dereference --preserve=links<NL>  -f%% --force                  if an existing destination file cannot be<NL>                                 opened%% remove it and try again (this option<NL>                                 is ignored when the -n option is also used)<NL>  -i%% --interactive            prompt before overwrite (overrides a previous -n<NL>                                  option)<NL>  -H                           follow command-line symbolic links in SOURCE<NL>  -l%% --link                   hard link files instead of copying<NL>  -L%% --dereference            always follow symbolic links in SOURCE<NL>  -n%% --no-clobber             do not overwrite an existing file (overrides<NL>                                 a previous -i option)<NL>  -P%% --no-dereference         never follow symbolic links in SOURCE<NL>  -p                           same as --preserve=mode%%ownership%%timestamps<NL>      --preserve[=ATTR_LIST]   preserve the specified attributes (default:<NL>                                 mode%%ownership%%timestamps)%% if possible<NL>                                 additional attributes: context%% links%% xattr%%<NL>                                 all<NL>      --no-preserve=ATTR_LIST  don't preserve the specified attributes<NL>      --parents                use full source file name under DIRECTORY<NL>  -R%% -r%% --recursive          copy directories recursively<NL>      --reflink[=WHEN]         control clone/CoW copies. See below<NL>      --remove-destination     remove each existing destination file before<NL>                                 attempting to open it (contrast with --force)<NL>      --sparse=WHEN            control creation of sparse files. See below<NL>      --strip-trailing-slashes  remove any trailing slashes from each SOURCE<NL>                                 argument<NL>  -s%% --symbolic-link          make symbolic links instead of copying<NL>  -S%% --suffix=SUFFIX          override the usual backup suffix<NL>  -t%% --target-directory=DIRECTORY  copy all SOURCE arguments into DIRECTORY<NL>  -T%% --no-target-directory    treat DEST as a normal file<NL>  -u%% --update                 copy only when the SOURCE file is newer<NL>                                 than the destination file or when the<NL>                                 destination file is missing<NL>  -v%% --verbose                explain what is being done<NL>  -x%% --one-file-system        stay on this file system<NL>  -Z                           set SELinux security context of destination<NL>                                 file to default type<NL>      --context[=CTX]          like -Z%% or if CTX is specified then set the<NL>                                 SELinux or SMACK security context to CTX<NL>      --help     display this help and exit<NL>      --version  output version information and exit<NL><NL>By default%% sparse SOURCE files are detected by a crude heuristic and the<NL>corresponding DEST file is made sparse as well.  That is the behavior<NL>selected by --sparse=auto.  Specify --sparse=always to create a sparse DEST<NL>file whenever the SOURCE file contains a long enough sequence of zero bytes.<NL>Use --sparse=never to inhibit creation of sparse files.<NL><NL>When --reflink[=always] is specified%% perform a lightweight copy%% where the<NL>data blocks are copied only when modified.  If this is not possible the copy<NL>fails%% or if --reflink=auto is specified%% fall back to a standard copy.<NL><NL>The backup suffix is '~'%% unless set with --suffix or SIMPLE_BACKUP_SUFFIX.<NL>The version control method may be selected via the --backup option or through<NL>the VERSION_CONTROL environment variable.  Here are the values:<NL><NL>  none%% off       never make backups (even if --backup is given)<NL>  numbered%% t     make numbered backups<NL>  existing%% nil   numbered if numbered backups exist%% simple otherwise<NL>  simple%% never   always make simple backups<NL><NL>As a special case%% cp makes a backup of SOURCE when the force and backup<NL>options are given and SOURCE and DEST are the same name for an existing%%<NL>regular file.<NL><NL>GNU coreutils online help: <http://www.gnu.org/software/coreutils/><NL>Full documentation at: <http://www.gnu.org/software/coreutils/cp><NL>or available locally via: info '(coreutils) cp invocation'%,cp --help
CMBEGIN,Nov 28 11:52:28,/usr/src/fhttpd,cp webserver.c webserver.orig.c,cp: cannot create regular file 'webserver.orig.c': Permission denied,cp webserver.c webserver.orig.c
CMBEGIN,Nov 28 11:52:43,/usr/src/fhttpd,./ webserver.c,bash: ./: Is a directory,./ webserver.c
CMBEGIN,Nov 28 11:53:49,/usr/src/fhttpd,./ webserver 8080,bash: ./: Is a directory,./ webserver 8080
CMBEGIN,,,./,GET<NL><NL> /<NL><NL>GET /<NL><NL>GET /<NL><NL><NL>GET /aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa<NL><NL><NL>send: Bad file descriptor<NL>GET / HTTP/1.1<NL><NL>User-Agent: Wget/1.17.1 (linux-gnu)<NL><NL>Accept: */*<NL><NL>Accept-Encoding: identity<NL><NL>Host: localhost:8080<NL><NL>Connection: Keep-Alive<NL><NL><NL>GET / HTTP/1.1<NL><NL>User-Agent: Wget/1.17.1 (linux-gnu)<NL><NL>Accept: */*<NL><NL>Accept-Encoding: identity<NL><NL>Host: localhost:8080<NL><NL>Connection: Keep-Alive<NL><NL><NL>GET /aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.html<NL><NL><NL>send: Bad file descriptor<NL>a<BS> <BS>GET / HTTP/1.1<NL><NL>User-Agent: Wget/1.17.1 (linux-gnu)<NL><NL>Accept: */*<NL><NL>Accept-Encoding: identity<NL><NL>Host: localhost:8080<NL><NL>Connection: Keep-Alive<NL><NL><NL>GET /aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa HTTP/1.1<NL><NL>User-Agent: Wget/1.17.1 (linux-gnu)<NL><NL>Accept: */*<NL><NL>Accept-Encoding: identity<NL><NL>Host: localhost:8080<NL><NL>Connection: Keep-Alive<NL><NL><NL>Segmentation fault (core dumped),
CMBEGIN,Nov 28 12:14:45,/usr/src/fhttpd,cp webserver.c,cp: missing destination file operand after 'webserver.c'<NL>Try 'cp --help' for more information.,cp webserver.c
CMBEGIN,,,cp webserver.c ~,,
CMBEGIN,Nov 28 12:14:57,/usr/src/fhttpd,ls,frobnick  index.html  Makefile<HT>webserver  webserver.c,ls
CMBEGIN,,,cp webserver.c ~ webserver.orig.c,cp: target 'webserver.orig.c' is not a directory,
CMBEGIN,Nov 28 11:58:43,/users/lclarkez,telnet localhost 8080,Trying 127.0.0.1...<NL>Connected to localhost.<NL>Escape character is '^]'.<NL>GET /aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa<NL><NL>GET /aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.HTML<NL><NL><NL><NL>^C^[^[^[^[^[^[^[^[^[^[<NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL>,telnet localhost 8080
CMBEGIN,Nov 28 12:04:31,/users/lclarkez,wget localhost 8080,--2018-11-28 12:04:31--  http://localhost/<NL>Resolving localhost (localhost)... 127.0.0.1<NL>Connecting to localhost (localhost)|127.0.0.1|:80... failed: Connection refused.<NL>--2018-11-28 12:04:31--  http://8080/<NL>Resolving 8080 (8080)... 0.0.31.144<NL>Connecting to 8080 (8080)|0.0.31.144|:80... failed: Invalid argument.,wget localhost 8080
CMBEGIN,,,wget localhost:,%--2018-11-28 12:07:16--  http://localhost:8080/<NL>Resolving localhost (localhost)... 127.0.0.1<NL>Connecting to localhost (localhost)|127.0.0.1|:8080... connected.<NL>HTTP request sent%% awaiting response... 200 OK<NL>Length: unspecified [text/html]<NL>Saving to: 'index.html.1'<NL><NL><NL>index.html.1            [<=>                 ]       0  --.-KB/s               <NL>index.html.1            [ <=>                ]   5.59K  --.-KB/s    in 0s      <NL><NL>2018-11-28 12:07:16 (237 MB/s) - 'index.html.1' saved [5725]<NL>%,
CMBEGIN,Nov 28 12:08:06,/users/lclarkez,ls,index.html  index.html.1  top_secret,ls
CMBEGIN,,,cd /usr/src/fhttpd/,,
CMBEGIN,Nov 28 12:08:20,/usr/src/fhttpd,ls,frobnick  index.html  Makefile<HT>webserver  webserver.c,ls
CMBEGIN,Nov 28 12:08:29,/usr/src/fhttpd,wget localhost:8080,%--2018-11-28 12:08:29--  http://localhost:8080/<NL>Resolving localhost (localhost)... 127.0.0.1<NL>Connecting to localhost (localhost)|127.0.0.1|:8080... connected.<NL>HTTP request sent%% awaiting response... 200 OK<NL>Length: unspecified [text/html]<NL>index.html.1: Permission denied<NL><NL>Cannot write to 'index.html.1' (Success).%,wget localhost:8080
CMBEGIN,Nov 28 12:09:25,/usr/src/fhttpd,telnet localhost 8080,Trying 127.0.0.1...<NL>Connected to localhost.<NL>Escape character is '^]'.<NL>GET /aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.html<NL><NL>^]<NL>^]<NL>^]<NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL>wget<NL>man telnet<NL>^[^[<NL>^[<NL>^[<NL>^[<NL>^[<NL>^[<NL>^[<NL>^[<NL><NL>^[<NL>^[<NL>^[<NL>^[<NL>^[<NL>^[<NL>^[<NL>^[<NL>^[<NL>^[<NL>^[<NL>^[<NL>^[<NL><NL>^[<NL>^[<NL><NL><NL>GET /a<NL>help why are you broken,telnet localhost 8080
CMBEGIN,,,cd /usr/src/fhttpd/,,
CMBEGIN,Nov 28 12:12:52,/usr/src/fhttpd,wget localhost:8080,%--2018-11-28 12:12:52--  http://localhost:8080/<NL>Resolving localhost (localhost)... 127.0.0.1<NL>Connecting to localhost (localhost)|127.0.0.1|:8080... connected.<NL>HTTP request sent%% awaiting response... 200 OK<NL>Length: unspecified [text/html]<NL>index.html.1: Permission denied<NL><NL>Cannot write to 'index.html.1' (Success).%,wget localhost:8080
CMBEGIN,Nov 28 12:13:21,/usr/src/fhttpd,cat index.html ,<html><NL><head><NL><title><NL><HT>Frobnick Production Reports<NL></title><NL></head><NL><body><NL><HT><h1>Frobnick Production Reports</h1><NL><HT><ul><NL><li><a href='frobnick/1.frob.txt'>1.frob.txt</a></li><NL><li><a href='frobnick/2.frob.txt'>2.frob.txt</a></li><NL><li><a href='frobnick/3.frob.txt'>3.frob.txt</a></li><NL><li><a href='frobnick/4.frob.txt'>4.frob.txt</a></li><NL><li><a href='frobnick/5.frob.txt'>5.frob.txt</a></li><NL><li><a href='frobnick/6.frob.txt'>6.frob.txt</a></li><NL><li><a href='frobnick/7.frob.txt'>7.frob.txt</a></li><NL><li><a href='frobnick/8.frob.txt'>8.frob.txt</a></li><NL><li><a href='frobnick/9.frob.txt'>9.frob.txt</a></li><NL><li><a href='frobnick/10.frob.txt'>10.frob.txt</a></li><NL><li><a href='frobnick/11.frob.txt'>11.frob.txt</a></li><NL><li><a href='frobnick/12.frob.txt'>12.frob.txt</a></li><NL><li><a href='frobnick/13.frob.txt'>13.frob.txt</a></li><NL><li><a href='frobnick/14.frob.txt'>14.frob.txt</a></li><NL><li><a href='frobnick/15.frob.txt'>15.frob.txt</a></li><NL><li><a href='frobnick/16.frob.txt'>16.frob.txt</a></li><NL><li><a href='frobnick/17.frob.txt'>17.frob.txt</a></li><NL><li><a href='frobnick/18.frob.txt'>18.frob.txt</a></li><NL><li><a href='frobnick/19.frob.txt'>19.frob.txt</a></li><NL><li><a href='frobnick/20.frob.txt'>20.frob.txt</a></li><NL><li><a href='frobnick/21.frob.txt'>21.frob.txt</a></li><NL><li><a href='frobnick/22.frob.txt'>22.frob.txt</a></li><NL><li><a href='frobnick/23.frob.txt'>23.frob.txt</a></li><NL><li><a href='frobnick/24.frob.txt'>24.frob.txt</a></li><NL><li><a href='frobnick/25.frob.txt'>25.frob.txt</a></li><NL><li><a href='frobnick/26.frob.txt'>26.frob.txt</a></li><NL><li><a href='frobnick/27.frob.txt'>27.frob.txt</a></li><NL><li><a href='frobnick/28.frob.txt'>28.frob.txt</a></li><NL><li><a href='frobnick/29.frob.txt'>29.frob.txt</a></li><NL><li><a href='frobnick/30.frob.txt'>30.frob.txt</a></li><NL><li><a href='frobnick/31.frob.txt'>31.frob.txt</a></li><NL><li><a href='frobnick/32.frob.txt'>32.frob.txt</a></li><NL><li><a href='frobnick/33.frob.txt'>33.frob.txt</a></li><NL><li><a href='frobnick/34.frob.txt'>34.frob.txt</a></li><NL><li><a href='frobnick/35.frob.txt'>35.frob.txt</a></li><NL><li><a href='frobnick/36.frob.txt'>36.frob.txt</a></li><NL><li><a href='frobnick/37.frob.txt'>37.frob.txt</a></li><NL><li><a href='frobnick/38.frob.txt'>38.frob.txt</a></li><NL><li><a href='frobnick/39.frob.txt'>39.frob.txt</a></li><NL><li><a href='frobnick/40.frob.txt'>40.frob.txt</a></li><NL><li><a href='frobnick/41.frob.txt'>41.frob.txt</a></li><NL><li><a href='frobnick/42.frob.txt'>42.frob.txt</a></li><NL><li><a href='frobnick/43.frob.txt'>43.frob.txt</a></li><NL><li><a href='frobnick/44.frob.txt'>44.frob.txt</a></li><NL><li><a href='frobnick/45.frob.txt'>45.frob.txt</a></li><NL><li><a href='frobnick/46.frob.txt'>46.frob.txt</a></li><NL><li><a href='frobnick/47.frob.txt'>47.frob.txt</a></li><NL><li><a href='frobnick/48.frob.txt'>48.frob.txt</a></li><NL><li><a href='frobnick/49.frob.txt'>49.frob.txt</a></li><NL><li><a href='frobnick/50.frob.txt'>50.frob.txt</a></li><NL><li><a href='frobnick/51.frob.txt'>51.frob.txt</a></li><NL><li><a href='frobnick/52.frob.txt'>52.frob.txt</a></li><NL><li><a href='frobnick/53.frob.txt'>53.frob.txt</a></li><NL><li><a href='frobnick/54.frob.txt'>54.frob.txt</a></li><NL><li><a href='frobnick/55.frob.txt'>55.frob.txt</a></li><NL><li><a href='frobnick/56.frob.txt'>56.frob.txt</a></li><NL><li><a href='frobnick/57.frob.txt'>57.frob.txt</a></li><NL><li><a href='frobnick/58.frob.txt'>58.frob.txt</a></li><NL><li><a href='frobnick/59.frob.txt'>59.frob.txt</a></li><NL><li><a href='frobnick/60.frob.txt'>60.frob.txt</a></li><NL><li><a href='frobnick/61.frob.txt'>61.frob.txt</a></li><NL><li><a href='frobnick/62.frob.txt'>62.frob.txt</a></li><NL><li><a href='frobnick/63.frob.txt'>63.frob.txt</a></li><NL><li><a href='frobnick/64.frob.txt'>64.frob.txt</a></li><NL><li><a href='frobnick/65.frob.txt'>65.frob.txt</a></li><NL><li><a href='frobnick/66.frob.txt'>66.frob.txt</a></li><NL><li><a href='frobnick/67.frob.txt'>67.frob.txt</a></li><NL><li><a href='frobnick/68.frob.txt'>68.frob.txt</a></li><NL><li><a href='frobnick/69.frob.txt'>69.frob.txt</a></li><NL><li><a href='frobnick/70.frob.txt'>70.frob.txt</a></li><NL><li><a href='frobnick/71.frob.txt'>71.frob.txt</a></li><NL><li><a href='frobnick/72.frob.txt'>72.frob.txt</a></li><NL><li><a href='frobnick/73.frob.txt'>73.frob.txt</a></li><NL><li><a href='frobnick/74.frob.txt'>74.frob.txt</a></li><NL><li><a href='frobnick/75.frob.txt'>75.frob.txt</a></li><NL><li><a href='frobnick/76.frob.txt'>76.frob.txt</a></li><NL><li><a href='frobnick/77.frob.txt'>77.frob.txt</a></li><NL><li><a href='frobnick/78.frob.txt'>78.frob.txt</a></li><NL><li><a href='frobnick/79.frob.txt'>79.frob.txt</a></li><NL><li><a href='frobnick/80.frob.txt'>80.frob.txt</a></li><NL><li><a href='frobnick/81.frob.txt'>81.frob.txt</a></li><NL><li><a href='frobnick/82.frob.txt'>82.frob.txt</a></li><NL><li><a href='frobnick/83.frob.txt'>83.frob.txt</a></li><NL><li><a href='frobnick/84.frob.txt'>84.frob.txt</a></li><NL><li><a href='frobnick/85.frob.txt'>85.frob.txt</a></li><NL><li><a href='frobnick/86.frob.txt'>86.frob.txt</a></li><NL><li><a href='frobnick/87.frob.txt'>87.frob.txt</a></li><NL><li><a href='frobnick/88.frob.txt'>88.frob.txt</a></li><NL><li><a href='frobnick/89.frob.txt'>89.frob.txt</a></li><NL><li><a href='frobnick/90.frob.txt'>90.frob.txt</a></li><NL><li><a href='frobnick/91.frob.txt'>91.frob.txt</a></li><NL><li><a href='frobnick/92.frob.txt'>92.frob.txt</a></li><NL><li><a href='frobnick/93.frob.txt'>93.frob.txt</a></li><NL><li><a href='frobnick/94.frob.txt'>94.frob.txt</a></li><NL><li><a href='frobnick/95.frob.txt'>95.frob.txt</a></li><NL><li><a href='frobnick/96.frob.txt'>96.frob.txt</a></li><NL><li><a href='frobnick/97.frob.txt'>97.frob.txt</a></li><NL><li><a href='frobnick/98.frob.txt'>98.frob.txt</a></li><NL><li><a href='frobnick/99.frob.txt'>99.frob.txt</a></li><NL><li><a href='frobnick/100.frob.txt'>100.frob.txt</a></li><NL></ul><NL></body><NL></html>,cat index.html
CMBEGIN,,,wget localhost:8080/aaaaaaaaaaaaaaaaaaaaaaaaaaa ,%aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa <NL>aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa <NL>aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa <NL>aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa <NL>aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa <NL>aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa <NL>aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa <NL>aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa <NL>aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa <NL>aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa <NL>aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa <NL>aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa <NL>aaaaaaaaaaaaa<NL>The name is too long%% 1000 chars total.<NL>Trying to shorten...<NL>New name is aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.<NL>--2018-11-28 12:13:55--  http://localhost:8080/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa<NL>Resolving localhost (localhost)... 127.0.0.1<NL>Connecting to localhost (localhost)|127.0.0.1|:8080... connected.<NL>HTTP request sent%% awaiting response... No data received.<NL>Retrying.<NL><NL>--2018-11-28 12:13:57--  (try: 2)  http://localhost:8080/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa<NL>Connecting to localhost (localhost)|127.0.0.1|:8080... failed: Connection refused.<NL>Resolving localhost (localhost)... 127.0.0.1<NL>Connecting to localhost (localhost)|127.0.0.1|:8080... failed: Connection refused.%,
CMBEGIN,,,cat index.html ,<NL><ESC>[K<NL><NL><ESC>[K<NL><NL><ESC>[K<NL><NL><ESC>[K<NL><NL><ESC>[K<NL><NL><ESC>[K<NL><NL><ESC>[K<NL><NL><ESC>[K<NL><NL><ESC>[K<NL><NL><ESC>[K<NL><NL><ESC>[K<NL>,
CMBEGIN,,,cd /usr/src/fhttpd/,,
CMBEGIN,Nov 28 12:18:11,/usr/src/fhttpd,cp web,cp: missing destination file operand after 'web'<NL>Try 'cp --help' for more information.,cp web
CMBEGIN,Nov 28 12:18:22,/usr/src/fhttpd,cp webserver.c webserver.orig.c,cp: cannot create regular file 'webserver.orig.c': Permission denied,cp webserver.c webserver.orig.c
CMBEGIN,Nov 28 12:18:40,/usr/src/fhttpd,sudo cp webserver.c webserver.orig.c,,sudo cp webserver.c webserver.orig.c
CMBEGIN,Nov 28 12:18:42,/usr/src/fhttpd,ls,frobnick  index.html  Makefile<HT>webserver  webserver.c<HT>webserver.orig.c,ls
CMBEGIN,Nov 28 12:19:10,/usr/src/fhttpd,emacs webserver.c,%=><NL>=-111:----F1  *scratch*      All L1     (Fundamental) ---------------------------<NL>Loading 00debian-vars...done<NL>/etc/emacs/site-start.d/50autoconf.el (source)...<NL>done<NL>Loading /etc/emacs/site-start.d/50autoconf.el (source)...doneFile Edit Options Buffers Tools Lisp-Interaction Help                           <NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL>-111:----F1  *scratch*      All L1     (Lisp Interaction) ----------------------<NL>For information about GNU Emacs and the GNU system%% type C-h C-a.<NL>Note: file is write protected<NL>Note: file is write protectedFile Edit Options Buffers Tools C Help                                          <NL><NL>// webserver.c                                                                  <NL><NL>// FrobozzCo Official Webserver                                                 <NL><NL>// Barbazzo Fernap barbazzo@gue.com                                             <NL><NL>// Gustar Woomax gustar@gue.com                                                 <NL><NL>// Wilbar Memboob wilbar@gue.com                                                <NL><NL><NL>// By the Frobozz Magic Webserver Company                                       <NL><NL>// Released under the Grue Public License                                       <NL><NL>// Frobruary 14th%% 1067 GUE                                                     <NL><NL><NL>// THERE IS NO WARRANTY FOR THE PROGRAM%% TO THE EXTENT PERMITTED                <NL><NL>// BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE               <NL><NL>// COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \u201CAS IS\u201D\<NL><NL>                                                                                <NL><NL>// WITHOUT WARRANTY OF ANY KIND%% EITHER EXPRESSED OR IMPLIED%% INCLUDING%%        <NL><NL>// BUT NOT LIMITED TO%% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND            <NL><NL>// FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY          <NL><NL>// AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE         <NL><NL>// DEFECTIVE%% *AND IT WILL*%% YOU ASSUME THE COST OF ALL NECESSARY               <NL><NL>// SERVICING%% REPAIR OR CORRECTION.                                             <NL><NL><NL>-11U:%%%%--F1  webserver.c    Top L1     (C/l Abbrev) ----------------------------<NL>2<NL><NL>1<NL>Beginning of buffer<NL>2<NL><NL>46917<NL>#include <stdio.h><NL>#include <errno.h><NL>#include <string.h><NL>#include <stdlib.h><NL>#include <netdb.h><NL>#include <sys/stat.h><NL>#include <sys/types.h><NL>#include <sys/socket.h><NL>#include <netinet/in.h><NL>#include <arpa/inet.h> 2%% L219#include <pthread.h><NL><NL>#define _XOPEN_SOURCE<NL><NL>typedef struct {<NL>        char *method;<NL>        char *uri;<NL>        char *version;<NL>        char *headers;<NL>} httpreq_t;<NL><NL><NL>/* NOTE: this function is based on a function provided in the GNU "timegm" man  <NL>   page. timegm is a GNU extension to time.h that returns the given tm struct a\<NL>s                                                                               <NL>   a UNIX timestamp in GMT/UTC%% rather than local time. The man page suggests a<NL>   function similar to the one below as a portable equivalent.                  <NL> */<NL>time_t my_timegm(struct tm *tm) {<NL>        time_t ret;<NL>        char *tz;9%% L44<NL>        tz = getenv("TZ");<NL>        putenv("TZ=GMT");<NL>        tzset();<NL>        ret = mktime(tm);<NL>        if (tz) {<NL>                char envstr[strlen(tz) + 4];<NL>                envstr[0] = '\0';<NL>                strcat(envstr%% "TZ=");<NL>                strcat(envstr%% tz);<NL>                putenv(envstr);<NL>        } else {10%% L56                strcat(envstr%% tz);<NL>                putenv(envstr);<NL>        } else {<NL>                putenv("TZ=");<NL>        }<NL><NL>        tzset();<NL><NL><HT>return ret;<NL>}<NL><NL>char *get_header(const httpreq_t *req%% const char* headername) {<NL><HT>char *hdrptr;<NL><HT>char *hdrend;<NL><HT>char *retval = NULL;<NL><NL><HT>char searchstr[strlen(headername) + 5];<NL><HT>strcpy(searchstr%% "<NL>");<NL><HT>strcat(searchstr%% headername);<NL><HT>strcat(searchstr%% ": ");<NL>4%% L7345782<NL>        if (hdrptr = strstr(req->headers%% searchstr)) {<NL>                hdrptr += strlen(searchstr);<NL>                if (hdrend = strstr(hdrptr%% "<NL>")) {<NL>                        char hdrval[1024]; // temporary return value            <NL><NL>                        memcpy((char *)hdrval%% hdrptr%% (hdrend - hdrptr));<NL>                        hdrval[hdrend - hdrptr] = '\0'; // tack null onto end o\<NL><NL>f header value                                                                  <NL><NL>                        int hdrvallen = strlen(hdrval);<NL>                        retval = (char *)malloc((hdrvallen + 1) * sizeof(char))\<NL><NL>; // malloc a space for retval                                                  <NL><NL><HT><HT><HT>strcpy(retval%% (char *)hdrval);5%% L84991                } else {<NL>                        retval = (char *)malloc((strlen(hdrptr) + 1) * sizeof(c\<NL><NL>har)); //                                                                       <NL><NL>                        strcpy(retval%% hdrptr);<NL>                }<NL>        }<NL><NL>        return retval;<NL>}<NL><NL>/* As long as str begins with a proper HTTP-Version followed by delim%% returns \<NL><NL>a                                                                               <NL><NL>   pointer to the start of the version number (e.g.%% 1.0). Returns NULL otherwi\<NL><NL>se.                                                                             <NL><NL> */8%% L979char *http_version_str(char *str%% char *delim) {<NL>        char *vstart = strstr(str%% "HTTP/");<NL>        char *vnumstart = str + 5;<NL>        char *vdot = strchr(str%% '.');<NL>        char *vend = strstr(str%% delim);<NL>        char *digits = "0123456789";<NL>        int majvlen = 0;<NL>        int minvlen = 0;<NL><NL>        if (!vstart || !vdot // something's missing                             <NL>21%% L105                || vstart != str) // str doesn't start with "HTTP/"             <NL><NL>                return NULL;<NL><NL>        majvlen = strspn(vnumstart%% digits);<NL>        minvlen = strspn(vdot + 1%% digits);<NL><NL>        if (majvlen < 1 || (vnumstart + majvlen) != vdot // bad major version   <NL><NL>                || minvlen < 1 || (vdot + minvlen + 1) != vend) // bad minor ve\<NL><NL>rsion                                                                           <NL><NL>                return NULL;<NL>2%% L1167821<NL>        return vnumstart;<NL>}<NL><NL>/* Fills req with the request data from datastr. Returns 0 on success.          <NL><NL> */<NL><NL>int parsereq(httpreq_t *req%% char *datastr) {<NL>        char *position;<NL>        char *last_position = datastr;<NL>        char *temp_position;<NL>        int matchlen;<NL><NL>        req->method = "";<NL><HT>req->uri = "";5%% L129int parsereq(httpreq_t *req%% char *datastr) {<NL><HT>char *position;<NL><HT>char *last_position = datastr;<NL><HT>char *temp_position;<NL>        int matchlen;<NL><NL><HT>req->method = "";<NL><HT>req->uri = "";<NL>        req->version = "";<NL><HT>req->headers = "";<NL><NL>        if (!(position = strchr(last_position%% ' '))) {<NL><HT><HT>return 1;<NL>        }<NL>matchlen = (int)(position - last_position);<NL><HT>req->method = (char *)malloc((matchlen + 1) * sizeof(char));<NL><HT>memcpy(req->method%% last_position%% matchlen);<NL><HT>req->method[matchlen] = '\0';<NL><HT>last_position = position + 1;<NL><NL><HT>if (!(position = strchr(last_position%% ' '))8%% L14126End of buffer<NL>                        pthread_t *thread = (pthread_t *) malloc(sizeof(pthread\<NL>_t));<NL><HT>                int *sockfd_ptr = (int *) malloc(sizeof(int));<NL><NL><HT>                *sockfd_ptr = acc;<NL><HT><HT><HT>pthread_create(thread%% NULL%% data_thread%% sockfd_ptr);<NL><HT>        }<NL><HT>}<NL><NL><HT>return 0;<NL>}<NL><NL><NL><NL><NL><NL><NL><NL><NL><NL>Bot L52019876543210<NL><NL><NL>        /* Infinite loop for receiving and processing client requests */<NL>        for(;;) {<NL>                clen=sizeof(caddr);<NL><NL>                /* Wait for a connection for a client process */<NL>                acc=accept(sockfd%%(struct sockaddr *) &caddr%%(socklen_t*)&clen)\<NL><NL>;<NL>                if(acc < 0) {<NL>                        perror("accept");<NL>                        exit(1);<NL>                } else {97%% L509876543210<NL><NL>499<NL>        /* Bind our local address so that the client can send to us */<NL>        if(bind(sockfd%%(struct sockaddr *) &saddr%%sizeof(saddr)) == -1) {<NL>                perror("bind");<NL>                exit(1);<NL>        }<NL><NL>        if(listen(sockfd%%5) < 0) {<NL>                perror("listen");<NL>                exit(1);<NL>        }<NL>5%% L4987654321089<NL><NL>8<NL>                perror("socket");<NL>                exit(1);<NL><NL>        }<NL><NL>        /* Create socket address structure for the local host */<NL>        memset((char *) &saddr%% '\0'%% sizeof(saddr));<NL>        saddr.sin_family=AF_INET;<NL>        saddr.sin_port=htons(port);<NL>        saddr.sin_addr.s_addr=htonl(INADDR_ANY);<NL>3%% L4876543210798<NL><NL>7<NL>        /* Obtain name and address for the local host */<NL>        if((he=gethostbyname("localhost"))==NULL) {<NL><NL>                herror("gethostbyname");<NL>                exit(1);<NL><NL>        }<NL><NL>        /* Open a TCP (Internet Stream) socket */<NL>        if((sockfd=socket(AF_INET%%SOCK_STREAM%%0)) == -1) {<NL>1%% L4765432106987<NL><NL>6<NL>struct hostent *he;<NL>        struct sockaddr_in caddr%% saddr;<NL><NL>        if(argc <= 1) {<NL><NL>                fprintf(stderr%% "No port specified. Exiting!<NL>");<NL>                exit(1);<NL><NL>        }<NL><NL>        port = atoi(argv[1]);<NL>0%% L4654321059876<NL><NL>5<NL><HT>}<NL><NL><HT>send_response(sockfd%% &req%% statcode);<NL><HT>close(sockfd);<NL><NL><HT>return NULL;<NL><NL>}<NL><NL>int main(int argc%% char *argv[]) {<NL><HT>int acc%% sockfd%% clen%% port;<NL><HT>struct hostent *he;<NL><HT>struct sockaddr_in caddr%% saddr;<NL><NL><HT>if(argc <= 1) {<NL><NL><HT><HT>fprintf(stderr%% "No port specified. Exiting!<NL>");<NL><HT><HT>exit(1);<NL><NL><HT>}<NL>89%% L4543210498765<NL><NL>4<NL><HT><NL><NL>                        }<NL><HT>                } // end of "if (header)end)"                           <NL><HT><HT>}<NL><HT>} // end of recv while loop                                             <NL><NL>        // used to deref a NULL pointer here... :(                              <NL><HT>if (headerstr != NULL) {<NL>                printf("%%s<NL>"%% headerstr);<NL><HT>        free(headerstr);<NL><HT>}<NL><NL><HT>send_response(sockfd%% &req%% statcode);<NL><HT>close(sockfd);<NL><NL><HT>return NULL;<NL><NL>}<NL><NL>int main(int argc%% char *argv[]) {<NL>8%% L4432103987654<NL><NL>3<NL>                                } else {<NL><NL>                                        // This isn't a POST%% so there's no ent\<NL><NL>ity body                                                                        <NL><NL>                                        done = 1;<NL><NL>                                        if (strcmp(req.method%% "GET") != 0<NL>                                                && strcmp(req.method%% "HEAD") !\<NL><NL>= 0) {<NL><NL>                                                statcode = 501; // unknown requ\<NL><NL>est method                                                                      <NL>6%% L43210298765<NL><NL>4<NL>                                                        done = 1;<NL>                                                }<NL><NL>                                                free(clenstr);<NL><NL>                                        } else {<NL><NL>                                                statcode = 400; // bad request \<NL><NL>-- no content length                                                            <NL><NL>                                                done = 1;<NL>                                        }<NL>5%% L4232101987654<NL><NL>3<NL><HT><HT><HT><HT>if (strcmp(req.method%% "POST") == 0) {<NL><NL><HT><HT><HT><HT><HT>// grab the body length                 <NL><HT><HT><HT><HT><HT>char *clenstr = get_header(&req%% "Conte\<NL>nt-Length");<NL><NL><HT><HT><HT><HT><HT>if (clenstr) {<NL><NL>                                                content_length = atoi(clenstr) \<NL>- ((headerstr + totalheadlen) - header_end - 4);<NL><NL><HT><HT><HT><HT><HT><HT>if (content_length <= 0) {<NL><HT><HT><HT><HT>                        done = 1;}<NL><NL>                                                free(clenstr);<NL><NL><HT><HT><HT><HT><HT>} else {<NL><NL><HT><HT><HT><HT><HT><HT>statcode = 400; // bad request <NL>-- no content length                                                            <NL>3%% L412100987654<NL><NL>3<NL><NL>                        header_end = strstr(headerstr%% "<NL><NL>");<NL><NL>                        if (header_end) {<NL>                                seen_header = 1;<NL>                                header_end[2] = '\0';<NL><NL>                                if (parsereq(&req%% headerstr) != 0) {<NL>                                        statcode = 400;<NL>                                }<NL>1%% L40210399876543<NL><NL>2<NL>s + 1) * sizeof(char));<NL>                        newheaderstr[totalheadlen + recvbytes] = '\0';<NL>                        memcpy(newheaderstr%% headerstr%% totalheadlen);<NL>                        memcpy(newheaderstr + totalheadlen%% recvmessage%% recvby\<NL><NL>tes);<NL><NL>                        if (headerstr != NULL) {<NL>                                free(headerstr);<NL>                        }<NL><NL>                        headerstr = newheaderstr;<NL>                        totalheadlen += recvbytes;<NL>79%% L3910898765432<NL><NL>1<NL><NL>                recvmessage[recvbytes] = '\0';<NL><NL>                if (seen_header) {<NL>                        // getting the entity body                              <NL><NL>                        content_length -= recvbytes;<NL>                        if (content_length <= 0) done = 1;<NL><NL>                } else {<NL><NL>                        newheaderstr = (char *) malloc((totalheadlen + recvbyte\<NL>70798765432<NL><NL>1<NL>        free(sockfd_ptr); // we have the int value out of this now              <NL><NL>        recvmessage[BUFSIZE - 1] = '\0'; // mark end of "string"                <NL><NL><NL>        /* Read incoming client message from the socket */<NL>        while(!done && (recvbytes = recv(sockfd%% recvmessage%% BUFSIZE - 1%% 0)))\<NL><NL> {<NL>                if (recvbytes < 0) {<NL>                        perror("recv");<NL>                        pthread_exit(NULL);<NL>                }<NL><NL>5%% L3706987654321<NL><NL>0<NL>char *newheaderstr = NULL;<NL>        int recvbytes = 0;<NL>        int curheadlen = 0;<NL>        int totalheadlen = 0;<NL>        httpreq_t req;<NL>        int statcode = 200;<NL>        int done = 0;<NL>        int seen_header = 0;<NL>        char *header_end;<NL>        int content_length = 0;<NL>        char *qstr;<NL>3%% L359876543210<NL><NL>49<NL>                        }<NL>                }<NL>        }<NL>}<NL><NL>void *data_thread(void *sockfd_ptr) {<NL><NL>        int sockfd = *(int *) sockfd_ptr;<NL>        const int BUFSIZE = 5;<NL>        char recvmessage[BUFSIZE];<NL>        char *headerstr = NULL;2%% L3487654321039<NL><NL>8<NL><HT><HT>// request wasn't just for the headers                          <NL><HT><HT>int readbytes;<NL><NL>                while (readbytes = read(urifd%% sendmessage%% BUFSIZE)) {<NL><HT><HT><HT>if (readbytes < 0) {<NL>                                perror("read");<NL><HT><HT><HT><HT>pthread_exit(NULL);<NL><HT>                }<NL><HT>                if (send(sockfd%% sendmessage%% readbytes%% 0) < 0) {<NL><HT>                        perror("send");<NL><HT>                        pthread_exit(NULL);<NL><HT>                }<NL><HT>        }<NL><HT>}<NL>}<NL><NL>void *data_thread(void *sockfd_ptr) {<NL>ockfd = *(int *) sockfd_ptr;<NL><HT>const int BUFSIZE = 5;<NL><HT>char recvmessage[BUFSIZE];<NL>0%% L3376543210298<NL><NL>7<NL><NL>        if (sendmessage[0] != '\0') {<NL>                // send headers as long as there are headers to send            <NL><NL>                if (send(sockfd%% sendmessage%% strlen(sendmessage)%% 0) < 0) {<NL>                        perror("send");<NL>                        pthread_exit(NULL);<NL>                }<NL>        }<NL><NL>        if (statcode == 200 && (strcmp(req->method%% "HEAD") != 0)) {<NL>                // send the requested file as long as there's no error and the  <NL>67%% L3265432101987<NL><NL>6<NL>}<NL><NL>        if (statcode != 200) {<NL>                strcat(sendmessage%% "<html><head><title>");<NL>                strcat(sendmessage%% status(statcode));<NL>                strcat(sendmessage%% "</title></head><body><h2>HTTP/1.0</h2><h1>\<NL><NL>");<NL>                strcat(sendmessage%% status(statcode));<NL>                strcat(sendmessage%% "</h1><h2>URI: ");<NL>                strcat(sendmessage%% path);<NL>                strcat(sendmessage%% "</h2></body></html>");<NL>        }<NL>5%% L3154321009876<NL><NL>5<NL>                time(&curtime); // time for Date: header                        <NL><NL>                strcat(sendmessage%% "HTTP/1.0 ");<NL>                strcat(sendmessage%% status(statcode));<NL>                strcat(sendmessage%% "<NL>Date: ");<NL>                strncat(sendmessage%% asctime(gmtime(&curtime))%% 24);<NL>                strcat(sendmessage%% "<NL>Server: Frobozz Magic Software Company\<NL><NL> Webserver v.002");<NL>                strcat(sendmessage%% "<NL>Connection: close");<NL>                strcat(sendmessage%% "<NL>Content-Type: ");<NL>                strcat(sendmessage%% contype(ext));<NL>                strcat(sendmessage%% "<NL><NL>");<NL>1%% L30432102998765<NL><NL>4<NL>                                && !strptime(imstime%% "%%a %%b %%d %%H:%%M:%%S %%Y"%% &\<NL><NL>tm)) {<NL>                                // badly formatted date                         <NL><NL>                                statcode = 400;<NL>                        }<NL><NL>                        if (stbuf.st_mtime <= my_timegm(&tm)) {<NL>                                // Not Modified                                 <NL><NL>                                statcode = 304;<NL>                        }<NL>                }<NL>0%% L29321089876543<NL><NL>                        && (imstime = get_header(req%% "If-Modified-Since"))) {<NL><NL>                        // Get statistics about the requested URI from the loca\<NL><NL>l filesystem                                                                    <NL><NL>                        if (stat(path%% &stbuf) == -1) {<NL>                                statcode = 500;<NL>                        }<NL><NL>                        if (!strptime(imstime%% "%%a%% %%d %%b %%Y %%H:%%M:%%S GMT"%% &tm\<NL><NL>)<NL>                                && !strptime(imstime%% "%%a%% %%d-%%b-%%y %%H:%%M:%%S GM\<NL><NL>T"%% &tm)57%% L28210798765<NL><NL>4<NL>                if (statcode == 200) {<NL>                        if (ext = strrchr(path%% '.')) ext++; // skip the '.'    <NL><NL>                        else ext = "";<NL>                } else {<NL>                        // errors are always html messages                      <NL><NL>                        ext = "html";<NL>                }<NL><NL>                // Conditional GET                                              <NL><NL>                if ((strcmp(req->method%% "GET") == 0)<NL>                        && (statcode == 200)5%% L273210698764<NL><NL>3<NL><NL><NL>        sendmessage[0] = '\0';<NL>        if (strcmp(req->version%% "0.9") != 0) { // full request                 <NL><NL>                char *ext; // file extension                                    <NL><NL>                time_t curtime;<NL>                char *imstime;<NL>                struct tm tm;<NL>                struct stat stbuf;<NL><NL>4%% L2621059876543<NL><NL>2<NL>} else if (errno == EACCES) { // access denied                  <NL><HT><HT><HT>statcode = 403;<NL>                } else {<NL>                        // some other file access problem                       <NL><NL>                        statcode = 500;<NL>                }<NL>        }<NL><NL>        if (strstr(path%% "..") != NULL) {<NL>                statcode = 500;<NL>        }<NL><NL>3%% L2510498765432<NL><NL>1<NL>                } else if (path[strlen(path) - 1] == '/') {<NL>                        //concatenating index.html for a /-terminated URL!      <NL><NL>                        strcat(path%% "index.html");<NL>                }<NL>        } else {<NL>                statcode = 400;<NL>        }<NL><NL>        if (statcode == 200 && (urifd = open(path%% O_RDONLY%% 0)) < 0) {<NL>                if (errno == ENOENT || errno == ENOTDIR) { // file or directory\<NL><NL> doesn't exist                                                                  <NL><NL>                        statcode = 404;0%% L2403987654321<NL><NL>0<NL>                req->headers == NULL || req->version == NULL) {<NL>                return 0;<NL>        }<NL><NL><NL>        if ((path[0] == '/') || ((strstr(path%% "http://") == path)<NL>                                                         && (path = strchr(path\<NL><NL> + 7%%  '/')))) {<NL>                path += 1; // remove leading slash                              <NL><NL>                if (path[0] == '\0') {  // substituting in index.html for a bla\<NL><NL>nk URL!                                                                         <NL><NL>                        path = "index.html";48%% L22987654321<NL><NL>0<NL>        else if (statcode == 501) return "501 Not Implemented";<NL>        else return "";<NL>}<NL><NL>int send_response(int sockfd%% httpreq_t *req%% int statcode) {<NL>        int urifd;<NL>        const int BUFSIZE = 1024;<NL>        char sendmessage[BUFSIZE];<NL>        char *path = req->uri;<NL><NL>        if (req->uri == NULL || req->method == NULL ||6%% L219876543210<NL><NL>1234567Buffer is read-only: #<buffer webserver.c>825<NL><HT>send_response(sockfd%% &req%% statcode);<NL>        close(sockfd);<NL><NL>        return NULL;<NL><NL>}<NL><NL>int main(int argc%% char *argv[]) {<NL><HT>int acc%% sockfd%% clen%% port;<NL><HT>struct hostent *he;<NL><HT>struct sockaddr_in caddr%% saddr;<NL><NL><HT>if(argc <= 1) {<NL><NL><HT><HT>fprintf(stderr%% "No port specified. Exiting!<NL>");<NL><HT>        exit(1);<NL><NL>       }<NL><NL><HT>port = atoi(argv[1]);<NL>89%% L4568perror("accept");<NL><HT>                exit(1);<NL><HT>        } else {<NL>pthread_t *thread = (pthread_t *) malloc(sizeof(pthread\<NL>_t));<NL><HT><HT><HT>int *sockfd_ptr = (int *) malloc(sizeof(int));<NL><NL><HT><HT><HT>*sockfd_ptr = acc;<NL>                        pthread_create(thread%% NULL%% data_thread%% sockfd_ptr);<NL><HT>        }<NL><HT>}<NL><NL><HT>return 0;<NL>}<NL><NL><NL><NL><NL><NL><NL>Bot L517Buffer is read-only: #<buffer webserver.c>820End of bufferBuffer is read-only: #<buffer webserver.c>19753<NL><HT><HT><HT>socke<NL><HT><HT><NL><NL><HT>}<NL><NL><HT>/* Create socket address structure for the local host */<NL><HT>memset((char *) &saddr%% '\0'%% sizeof(saddr));<NL><HT>saddr.sin_family=AF_INET;<NL><HT>saddr.sin_port=htons(port);<NL><HT>saddr.sin_addr.s_addr=htonl(INADDR_ANY);<NL><NL><HT>/* Bind our local address so that the client can send to us */<NL><HT>if(bind(sockfd%%(struct sockaddr *) &saddr%%sizeof(saddr)) == -1) {<NL>                perror("bind");<NL><HT><HT>exit(1);<NL><HT>}<NL><NL>if(listen(sockfd%%5) < 0) {<NL><HT><HT>perror("listen");<NL><HT><HT>exit(1);<NL><HT>}93%% L4886<NL><HT>struct hostent *he;<NL><HT>struct sockaddr_in caddr%% saddr;<NL><NL><HT>if(argc <= 1) {<NL><NL><HT>        fprintf(stderr%% "No port specified. Exiting!<NL>");<NL><HT>        exit(1);<NL><NL><HT>}<NL><NL><HT>port = atoi(argv[1]);<NL><NL><HT>/* Obtain name and address for the local host */<NL><HT>if((he=gethostbyname("localhost"))==NULL) {<NL><NL><HT>        herror("gethostbyname");<NL><HT><HT>exit(1);<NL><NL><HT>}<NL><NL><HT>/* Open a TCP (Internet Stream) socket */0%% L465<NL><HT>                                        && strcmp(req.method%% "HEAD") !\<NL>= 0) {<NL><NL><HT>                                        statcode = 501; // unknown requ\<NL>est method                                                                      <NL><HT><HT>                        }<NL><NL><HT><HT><HT><HT>}<NL><HT>                } // end of "if (header)end)"                           <NL><HT><HT>}<NL><HT>} // end of recv while loop                                             <NL>/ used to deref a NULL pointer here... :(                              <NL> (headerstr != NULL) {<NL><HT><HT>printf("%%s<NL>"%% headerstr);<NL><HT><HT>free(headerstr);<NL><HT>}<NL><NL>send_response(sockfd%% &req%% statcode);<NL><HT>close(sockfd);<NL>87%% L439char *clenstr = get_header(&req%% "Conte<NL>nt-Length");<NL><NL><HT><HT><HT><HT>if (clenstr) {<NL><NL><HT><HT><HT><HT><HT>        content_length = atoi(clenstr) \<NL>- ((headerstr + totalheadlen) - header_end - 4);<NL><NL><HT><HT><HT>                        if (content_length <= 0) {<NL><HT><HT>                                        done = 1;<NL><HT>                                        }<NL><NL><HT>                                        free(clenstr);<NL><NL><HT><HT>                        } else {<NL><NL><HT>                                        statcode = 400; // bad request \<NL>-- no content length                                                            <NL><HT>                                        done = 1;<NL><HT>                                }3%% L415if (content_length <= 0) done = 1;<NL><NL><HT><HT>} else {<NL><NL><HT><HT><HT>newheaderstr = (char *) malloc((totalheadlen + recvbyte\<NL>s + 1) * sizeof(char));<NL>                        newheaderstr[totalheadlen + recvbytes] = '\0';<NL><HT><HT><HT>memcpy(newheaderstr%% headerstr%% totalheadlen);<NL><HT><HT><HT>memcpy(newheaderstr + totalheadlen%% recvmessage%% recvby\<NL>tes);<NL><NL><HT><HT><HT>if (headerstr != NULL) {<NL><HT><HT><HT><HT>free(headerstr);<NL><HT><HT><HT>}<NL><NL><HT><HT><HT>headerstr = newheaderstr;<NL><HT><HT><HT>totalheadlen += recvbytes;<NL><NL><HT><HT><HT>header_end = strstr(headerstr%% "<NL><NL>");<NL><NL><HT><HT><HT>if (header_end) {78%% L3864&& (statcode == 200)<NL><HT><HT><HT>&& (imstime = get_header(req%% "If-Modified-Since"))) {<NL><NL><HT><HT><HT>// Get statistics about the requested URI from the loca\<NL>l filesystem                                                                    <NL>                        if (stat(path%% &stbuf) == -1) {<NL><HT><HT><HT>        statcode = 500;<NL><HT><HT><HT>}<NL><NL>                        if (!strptime(imstime%% "%%a%% %%d %%b %%Y %%H:%%M:%%S GMT"%% &tm\<NL>)<NL><HT><HT><HT>        && !strptime(imstime%% "%%a%% %%d-%%b-%%y %%H:%%M:%%S GM\<NL>T"%% &tm)<NL><HT><HT>        && !strptime(imstime%% "%%a %%b %%d %%H:%%M:%%S %%Y"%% &\<NL>tm)) {<NL><HT><HT><HT>        // badly formatted date                         <NL><HT><HT><HT>        statcode = 400;<NL><HT><HT><HT>}<NL><NL><HT><HT><HT>if (stbuf.st_mtime <= my_timegm(&tm)) {<NL><HT><HT><HT>        // Not Modified                                 <NL>57%% L282<NL><HT>if (statcode == 200 && (urifd = open(path%% O_RDONLY%% 0)) < 0) {<NL><HT><HT>if (errno == ENOENT || errno == ENOTDIR) { // file or directory\<NL> doesn't exist                                                                  <NL><HT><HT><HT>statcode = 404;<NL>                } else if (errno == EACCES) { // access denied<NL><HT><HT><HT>statcode = 403;<NL><HT><HT>} else {<NL>// some other file access problem                       <NL><HT><HT><HT>statcode = 500;<NL><HT><HT>}<NL>        }<NL><NL>        if (strstr(path%% "..") != NULL) {<NL><HT><HT>statcode = 500;<NL>        }<NL><NL><NL><HT>sendmessage[0] = '\0';<NL><HT>if (strcmp(req->version%% "0.9") != 0) { // full request                 <NL><HT><HT>char *ext; // file extension                                    <NL><HT><HT>time_t curtime;<NL>1%% L248<NL><HT>else if (statcode == 403) return "403 Forbidden";<NL><HT>else if (statcode == 404) return "404 Not Found";<NL>        else if (statcode == 500) return "500 Internal Server Error";<NL><HT>else if (statcode == 501) return "501 Not Implemented";<NL><HT>else return "";<NL>}<NL><NL>int send_response(int sockfd%% httpreq_t *req%% int statcode) {<NL><HT>int urifd;<NL><HT>const int BUFSIZE = 1024;<NL><HT>char sendmessage[BUFSIZE];<NL><HT>char *path = req->uri;<NL><NL><HT>if (req->uri == NULL || req->method == NULL ||<NL><HT>        req->headers == NULL || req->version == NULL) {<NL><HT><HT>return 0;<NL><HT>}<NL><NL><NL><HT>if ((path[0] == '/') || ((strstr(path%% "http://") == path)<NL><HT><HT>                                         && (path = strchr(path\<NL>44%% L2165109Beginning of buffer<NL>// webserver.c                                                                  <NL>// FrobozzCo Official Webserver                                                 <NL>// Barbazzo Fernap barbazzo@gue.com                                             <NL>// Gustar Woomax gustar@gue.com                                                 <NL>// Wilbar Memboob wilbar@gue.com                                                <NL><NL>// By the Frobozz Magic Webserver Company                                       <NL>// Released under the Grue Public License                                       <NL>// Frobruary 14th%% 1067 GUE                                                     <NL><NL>// THERE IS NO WARRANTY FOR THE PROGRAM%% TO THE EXTENT PERMITTED                <NL>// BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE               <NL>// COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \u201CAS IS\u201D\<NL>                                                                                <NL>// WITHOUT WARRANTY OF ANY KIND%% EITHER EXPRESSED OR IMPLIED%% INCLUDING%%        <NL>// BUT NOT LIMITED TO%% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND            <NL>// FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY          <NL>// AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE         <NL>// DEFECTIVE%% *AND IT WILL*%% YOU ASSUME THE COST OF ALL NECESSARY               <NL>// SERVICING%% REPAIR OR CORRECTION.                                             <NL>Top L1  <NL>2<NL><NL>5713        req->version = "";<NL>        req->headers = "";<NL><NL>        if (!(position = strchr(last_position%% ' '))) {<NL>                return 1;<NL><HT>}<NL>        matchlen = (int)(position - last_position);<NL>        req->method = (char *)malloc((matchlen + 1) * sizeof(char));<NL>        memcpy(req->method%% last_position%% matchlen);<NL><HT>req->method[matchlen] = '\0';<NL>        last_position = position + 1;<NL><NL>        if (!(position = strchr(last_position%% ' '))<NL>                && !(position = strstr(last_position%% "<NL>"))) {<NL>                return 1;<NL>        }<NL><NL>strip any query string out of the URI                       <NL>        if ((temp_position = strchr(last_position%% '?')) && temp_position < pos\<NL>ition)<NL><HT><HT>matchlen = (int)(temp_position - last_position);29%% L149865Beginning of buffer<NL>// webserver.c                                                                  <NL>// FrobozzCo Official Webserver                                                 <NL>// Barbazzo Fernap barbazzo@gue.com                                             <NL>// Gustar Woomax gustar@gue.com                                                 <NL>// Wilbar Memboob wilbar@gue.com                                                <NL><NL>// By the Frobozz Magic Webserver Company                                       <NL>// Released under the Grue Public License                                       <NL>// Frobruary 14th%% 1067 GUE                                                     <NL><NL>// THERE IS NO WARRANTY FOR THE PROGRAM%% TO THE EXTENT PERMITTED                <NL>// BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE               <NL>// COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \u201CAS IS\u201D\<NL>                                                                                <NL>// WITHOUT WARRANTY OF ANY KIND%% EITHER EXPRESSED OR IMPLIED%% INCLUDING%%        <NL>// BUT NOT LIMITED TO%% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND            <NL>// FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY          <NL>AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE<NL>// DEFECTIVE%% *AND IT WILL*%% YOU ASSUME THE COST OF ALL NECESSARY               <NL>// SERVICING%% REPAIR OR CORRECTION.                                             <NL>Top L1  <NL>2<NL><NL>34578910267820<NL><NL>#include <stdio.h><NL>#include <errno.h><NL>#include <string.h><NL>#include <stdlib.h><NL>#include <netdb.h><NL>#include <sys/stat.h><NL>#include <sys/types.h><NL>#include <sys/socket.h><NL>#include <netinet/in.h><NL>#include <arpa/inet.h><NL>#include <unistd.h> 3%% L2243456830#include <fcntl.h><NL>#include <time.h><NL>#include <pthread.h><NL><NL>#define _XOPEN_SOURCE<NL><NL>typedef struct {<NL>        char *method;<NL>        char *uri;<NL>        char *version;<NL>        char *headers;7%% L3247840define _XOPEN_SOURCE<NL><NL>typedef struct {<NL>        char *method;<NL>        char *uri;<NL>        char *version;<NL>        char *headers;<NL>} httpreq_t;<NL><NL><NL>/* NOTE: this function is based on a function provided in the GNU "timegm" man  <NL>   page. timegm is a GNU extension to time.h that returns the given tm struct a\<NL>s                                                                               <NL>   a UNIX timestamp in GMT/UTC%% rather than local time. The man page suggests a<NL>   function similar to the one below as a portable equivalent.                  <NL> */<NL>time_t my_timegm(struct tm *tm) {<NL><HT>time_t ret;<NL>tz;<NL><NL><HT>tz = getenv("TZ");9%% L4679        putenv("TZ=GMT");<NL>        tzset();<NL>        ret = mktime(tm);<NL>        if (tz) {<NL>                char envstr[strlen(tz) + 4];<NL>                envstr[0] = '\0';<NL>                strcat(envstr%% "TZ=");<NL>                strcat(envstr%% tz);<NL>                putenv(envstr);<NL>        } else {<NL>                putenv("TZ=");<NL>        }<NL>11%% L589613                putenv("TZ=");<NL>        }<NL><NL>        tzset();<NL><NL><HT>return ret;<NL>}<NL><NL>char *get_header(const httpreq_t *req%% const char* headername) {<NL><HT>char *hdrptr;<NL><HT>char *hdrend;<NL><HT>char *retval = NULL;<NL><NL><HT>char searchstr[strlen(headername) + 5];<NL><HT>strcpy(searchstr%% "<NL>");<NL><HT>strcat(searchstr%% headername);<NL><HT>strcat(searchstr%% ": ");<NL><NL><HT>if (hdrptr = strstr(req->headers%% searchstr)) {<NL><HT>        hdrptr += strlen(searchstr);<NL><HT><HT>if (hdrend = strstr(hdrptr%% "<NL>")) {4%% L768<NL><HT>if (hdrptr = strstr(req->headers%% searchstr)) {<NL><HT><HT>hdrptr += strlen(searchstr);<NL><HT>        if (hdrend = strstr(hdrptr%% "<NL>")) {<NL><HT><HT><HT>char hdrval[1024]; // temporary return value            <NL><HT>                memcpy((char *)hdrval%% hdrptr%% (hdrend - hdrptr));<NL>                        hdrval[hdrend - hdrptr] = '\0'; // tack null onto end o\<NL>f header value                                                                  <NL>                        int hdrvallen = strlen(hdrval);<NL><HT>                retval = (char *)malloc((hdrvallen + 1) * sizeof(char))\<NL>; // malloc a space for retval                                                  <NL><HT>                strcpy(retval%% (char *)hdrval);<NL><HT><HT>} else {<NL><HT>                retval = (char *)malloc((strlen(hdrptr) + 1) * sizeof(c\<NL>har)); //                                                                       <NL><HT>                strcpy(retval%% hdrptr);<NL><HT>        }<NL><HT>}<NL><NL><HT>return retval;<NL>}7%% L9236   pointer to the start of the version number (e.g.%% 1.0). Returns NULL otherwi\<NL>se.                                                                             <NL> */<NL>char *http_version_str(char *str%% char *delim) {<NL><HT>char *vstart = strstr(str%% "HTTP/");<NL><HT>char *vnumstart = str + 5;<NL><HT>char *vdot = strchr(str%% '.');<NL>        char *vend = strstr(str%% delim);<NL><HT>char *digits = "0123456789";<NL><HT>int majvlen = 0;<NL>        int minvlen = 0;<NL><NL><HT>if (!vstart || !vdot // something's missing                             <NL><HT><HT>|| vstart != str) // str doesn't start with "HTTP/"             <NL>                return NULL;<NL><NL><HT>majvlen = strspn(vnumstart%% digits);<NL><HT>minvlen = strspn(vdot + 1%% digits);<NL><NL><HT>if (majvlen < 1 || (vnumstart + majvlen) != vdot // bad major version   <NL>                || minvlen < 1 || (vdot + minvlen + 1) != vend) // bad minor ve\<NL>22%% L113<NL>        return vnumstart;<NL>}<NL><NL>/* Fills req with the request data from datastr. Returns 0 on success.          <NL> */<NL><NL>int parsereq(httpreq_t *req%% char *datastr) {position;<NL><HT>char *last_position = datastr;<NL><HT>char *temp_position;<NL><HT>int matchlen;<NL><NL><HT>req->method = "";<NL><HT>req->uri = "";<NL><HT>req->version = "";<NL><HT>req->headers = "";<NL><NL><HT>if (!(position = strchr(last_position%% ' '))) {<NL><HT>        return 1;<NL><HT>}7%% L13442<NL><HT><HT>|| !(last_position = http_version_str(last_position%% "<NL>"))) \<NL>{<NL>                return 1;<NL><HT>}<NL><NL>        matchlen = (int)(position - last_position);<NL><HT>req->version = (char *)malloc((matchlen + 1) * sizeof(char));<NL>        memcpy(req->version%% last_position%% matchlen);<NL><HT>req->version[matchlen] = '\0';<NL><HT>last_position = position;<NL><NL><HT>req->headers = (char *)malloc(strlen(last_position) * sizeof(char));<NL><HT>strcpy(req->headers%% last_position);<NL><NL><HT>return 0;<NL>}<NL><NL>char *contype(char *ext) {strcmp(ext%% "html") == 0) return "text/html";<NL><HT>else if (strcmp(ext%% "htm") == 0) return "text/html";<NL><HT>else if (strcmp(ext%% "jpeg") == 0) return "image/jpeg";37%% L185<NL>char *status(int statcode) {<NL><HT>if (statcode == 200)    return "200 OK";<NL><HT>else if (statcode == 304) return "304 Not Modified";<NL><HT>else if (statcode == 400) return "400 Bad Request";<NL><HT>else if (statcode == 403) return "403 Forbidden";<NL><HT>else if (statcode == 404) return "404 Not Found";<NL><HT>else if (statcode == 500) return "500 Internal Server Error";<NL><HT>else if (statcode == 501) return "501 Not Implemented";<NL><HT>else return "";<NL>}<NL><NL>int send_response(int sockfd%% httpreq_t *req%% int statcode) {<NL><HT>int urifd;<NL><HT>const int BUFSIZE = 1024;<NL>        char sendmessage[BUFSIZE];<NL><HT>char *path = req->uri;<NL>req->uri == NULL || req->method == NULL ||<NL><HT>        req->headers == NULL || req->version == NULL) {<NL><HT>        return 0;43%% L2114<NL><HT><HT>path += 1; // remove leading slash                              <NL>                if (path[0] == '\0') {  // substituting in index.html for a bla\<NL>nk URL!                                                                         <NL><HT>                path = "index.html";<NL><HT>        } else if (path[strlen(path) - 1] == '/') {<NL><HT>                //concatenating index.html for a /-terminated URL!      <NL><HT>                strcat(path%% "index.html");<NL><HT>        }<NL><HT>} else {<NL><HT>        statcode = 400;<NL><NL><NL>        if (statcode == 200 && (urifd = open(path%% O_RDONLY%% 0)) < 0) {<NL><HT>        if (errno == ENOENT || errno == ENOTDIR) { // file or directory\<NL> doesn't exist                                                                  <NL><HT>                statcode = 404;<NL><HT>        } else if (errno == EACCES) { // access denied                  <NL><HT><HT><HT>statcode = 403;<NL><HT>        } else {<NL><HT><HT>        // some other file access problem                       <NL><HT><HT>        statcode = 500;9%% L237844<NL><HT><HT>if (seen_header) {<NL><HT><HT>        // getting the entity body                              <NL>                        content_length -= recvbytes;<NL><HT><HT><HT>if (content_length <= 0) done = 1;<NL><NL><HT><HT>} else {<NL><NL><HT><HT>        newheaderstr = (char *) malloc((totalheadlen + recvbyte\<NL>s + 1) * sizeof(char));<NL><HT><HT>        newheaderstr[totalheadlen + recvbytes] = '\0';<NL><HT>                memcpy(newheaderstr%% headerstr%% totalheadlen);<NL><HT><HT><HT>memcpy(newheaderstr + totalheadlen%% recvmessage%% recvby\<NL>tes);<NL><NL>                        if (headerstr != NULL) {<NL><HT><HT><HT>        free(headerstr);<NL><HT><HT>        }<NL><NL><HT><HT>        headerstr = newheaderstr;<NL><HT><HT><HT>totalheadlen += recvbytes;<NL>78%% L38<NL>8<NL><HT><HT>        totalheadlen += recvbytes;<NL><NL><HT><HT><HT>header_end = strstr(headerstr%% "<NL><NL>");<NL><NL><HT><HT><HT>if (header_end) {<NL><HT><HT>                seen_header = 1;<NL><HT><HT><HT><HT>header_end[2] = '\0';<NL><NL>                                if (parsereq(&req%% headerstr) != 0) {<NL><HT><HT><HT>                statcode = 400;<NL><HT><HT><HT>        }<NL><NL>                                if (strcmp(req.method%% "POST") == 0) {<NL><NL><HT><HT><HT>                // grab the body length                 <NL><HT><HT><HT><HT>        char *clenstr = get_header(&req%% "Conte\<NL>nt-Length");<NL><NL><HT><HT>                if (clenstr) {<NL><NL><HT><HT><HT><HT><HT><HT>content_length = atoi(clenstr) \<NL>81%% L401<NL><HT><HT>printf("%%s<NL>"%% headerstr);<NL><HT><HT>free(headerstr);<NL><HT>}<NL><NL>send_response(sockfd%% &req%% statcode);<NL><HT>close(sockfd);<NL><NL><HT>return NULL;<NL><NL>}<NL><NL>int main(int argc%% char *argv[]) {<NL><HT>int acc%% sockfd%% clen%% port;<NL><HT>struct hostent *he;<NL><HT>struct sockaddr_in caddr%% saddr;<NL><NL>        if(argc <= 1) {<NL><NL><HT><HT>fprintf(stderr%% "No port specified. Exiting!<NL>");<NL><HT><HT>exit(1);<NL>9%% L452<NL><HT>if((sockfd=socket(AF_INET%%SOCK_STREAM%%0)) == -1) {<NL><NL><HT>        perror("socket");<NL><HT><HT>exit(1);<NL><NL><HT>}<NL><NL>/* Create socket address structure for the local host */<NL><HT>memset((char *) &saddr%% '\0'%% sizeof(saddr));<NL>        saddr.sin_family=AF_INET;<NL><HT>saddr.sin_port=htons(port);<NL>        saddr.sin_addr.s_addr=htonl(INADDR_ANY);<NL><NL><HT>/* Bind our local address so that the client can send to us */<NL><HT>if(bind(sockfd%%(struct sockaddr *) &saddr%%sizeof(saddr)) == -1) {<NL><HT><HT>perror("bind");<NL><HT>        exit(1);<NL><HT>}<NL><NL><HT>if(listen(sockfd%%5) < 0) {<NL><HT><HT>perror("listen");<NL>93%% L486<NL><HT>                pthread_t *thread = (pthread_t *) malloc(sizeof(pthread\<NL>_t));<NL><HT><HT>        int *sockfd_ptr = (int *) malloc(sizeof(int));<NL><NL><HT><HT><HT>*sockfd_ptr = acc;<NL><HT>                pthread_create(thread%% NULL%% data_thread%% sockfd_ptr);<NL><HT><HT>}<NL><HT>}<NL><NL><HT>return 0;<NL>}<NL><NL><NL><NL><NL><NL><NL><NL><NL><NL>Bot L520End of buffer<NL>7<NL><NL><HT><NL>5678920End of bufferESCESC- ESCESC M-RET is undefinedBuffer is read-only: #<buffer webserver.c>M-RET is undefinedBuffer is read-only: #<buffer webserver.c>M-RET is undefinedM-RET is undefinedM-RET is undefinedM-RET is undefinedM-RET is undefinedM-RET is undefinedM-RET is undefinedESC- qBuffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>                                                                                <NL>        return 0;                                                               <NL>}                                                                               <NL>17ESC M-h is undefinedM-g M-h is undefinedBuffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>C-c- ESC- O- A- up-<up> is undefined        }                                                                       <NL>6                }                                                               <NL>5                        pthread_create(thread%% NULL%% data_thread%% sockfd_ptr);  <NL>4                        *sockfd_ptr = acc;                                      <NL>3                                                                                <NL>2                        int *sockfd_ptr = (int *) malloc(sizeof(int));          <NL>1                        int *sockfd_ptr = (int *) malloc(sizeof(int));23                        *sockfd_ptr = acc;4                        pthread_create(thread%% NULL%% data_thread%% sockfd_ptr);5                }6        }78        return 0;9}20End of buffer}                                                                               <NL>19}20}                                                                               <NL>19        return 0;                                                               <NL>8        return 0;9}20End of bufferBuffer is read-only: #<buffer webserver.c>}                                                                               <NL>19        return 0;                                                               <NL>8                                                                                <NL>7        }                                                                       <NL>6Buffer is read-only: #<buffer webserver.c>        }78        return 0;9Buffer is read-only: #<buffer webserver.c>}20Buffer is read-only: #<buffer webserver.c>}                                                                               <NL>19Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>C-c- C-cBuffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>Buffer is read-only: #<buffer webserver.c>C-h (Type ? for further options)- ESC- O- A- up-<up> is undefined        return 0;                                                               <NL>8                                                                                <NL>7        }                                                                       <NL>6                }                                                               <NL>5                        pthread_create(thread%% NULL%% data_thread%% sockfd_ptr);  <NL>4                        *sockfd_ptr = acc;                                      <NL>3                                                                                <NL>2                        int *sockfd_ptr = (int *) malloc(sizeof(int));          <NL>1_t));                                                                           <NL>0<NL><NL>_t));1                        int *sockfd_ptr = (int *) malloc(sizeof(int));23                        *sockfd_ptr = acc;4                        pthread_create(thread%% NULL%% data_thread%% sockfd_ptr);5                }6        }78        return 0;9Buffer is read-only: #<buffer webserver.c>}20Buffer is read-only: #<buffer webserver.c>%,emacs webserver.c
CMBEGIN,,,cd /usr/src/fhttpd/,,
CMBEGIN,Nov 21 12:04:37,/usr/src/fhttpd,sudo make,make: Nothing to be done for 'project'.,sudo make
CMBEGIN,Nov 21 12:05:01,/usr/src/fhttpd,ls,frobnick  index.html  Makefile<HT>webserver  webserver.c,ls
CMBEGIN,Nov 21 12:06:29,/usr/src/fhttpd,sudo ./webserver 9876,GET / HTTP/1.0<NL><NL><NL>GET /<NL><NL><NL>GET /index.html HTTP/1.1<NL><NL>User-Agent: Wget/1.17.1 (linux-gnu)<NL><NL>Accept: */*<NL><NL>Accept-Encoding: identity<NL><NL>Host: localhost:9876<NL><NL>Connection: Keep-Alive<NL><NL><NL>GET /jens HTTP/1.1<NL><NL>User-Agent: Wget/1.17.1 (linux-gnu)<NL><NL>Accept: */*<NL><NL>Accept-Encoding: identity<NL><NL>Host: localhost:9876<NL><NL>Connection: Keep-Alive<NL><NL><NL>GET /jensjensjensjensjensjensjensjensjensjensjensjensjensjens HTTP/1.1<NL><NL>User-Agent: Wget/1.17.1 (linux-gnu)<NL><NL>Accept: */*<NL><NL>Accept-Encoding: identity<NL><NL>Host: localhost:9876<NL><NL>Connection: Keep-Alive<NL><NL><NL>GET /12345678901234567890 HTTP/1.1<NL><NL>User-Agent: Wget/1.17.1 (linux-gnu)<NL><NL>Accept: */*<NL><NL>Accept-Encoding: identity<NL><NL>Host: localhost:9876<NL><NL>Connection: Keep-Alive<NL><NL><NL>GET /12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890 HTTP/1.1<NL><NL>User-Agent: Wget/1.17.1 (linux-gnu)<NL><NL>Accept: */*<NL><NL>Accept-Encoding: identity<NL><NL>Host: localhost:9876<NL><NL>Connection: Keep-Alive<NL><NL><NL>Segmentation fault (core dumped),sudo ./webserver 9876
CMBEGIN,Nov 21 12:17:04,/usr/src/fhttpd,sudo ./webserver 8080,^C,sudo ./webserver 8080
CMBEGIN,Nov 21 12:18:05,/usr/src/fhttpd,sudo ./webserver 8080,,sudo ./webserver 8080
CMBEGIN,Nov 21 12:08:24,/users/lclarkez,telnet locahost portnumber,telnet: could not resolve locahost/portnumber: Servname not supported for ai_socktype,telnet locahost portnumber
CMBEGIN,,,telnet local,telnet: could not resolve localhost/portnumber: Servname not supported for ai_socktype,
CMBEGIN,Nov 21 12:08:51,/users/lclarkez,telnet localhost 9876,Trying 127.0.0.1...<NL>Connected to localhost.<NL>Escape character is '^]'.<NL>GET / HTTP/1.0<NL><NL>HTTP/1.0 200 OK<NL>Date: Wed Nov 21 20:09:35 2018<NL>Server: Frobozz Magic Software Company Webserver v.002<NL>Connection: close<NL>Content-Type: text/html<NL><NL><html><NL><head><NL><title><NL><HT>Frobnick Production Reports<NL></title><NL></head><NL><body><NL><HT><h1>Frobnick Production Reports</h1><NL><HT><ul><NL><li><a href='frobnick/1.frob.txt'>1.frob.txt</a></li><NL><li><a href='frobnick/2.frob.txt'>2.frob.txt</a></li><NL><li><a href='frobnick/3.frob.txt'>3.frob.txt</a></li><NL><li><a href='frobnick/4.frob.txt'>4.frob.txt</a></li><NL><li><a href='frobnick/5.frob.txt'>5.frob.txt</a></li><NL><li><a href='frobnick/6.frob.txt'>6.frob.txt</a></li><NL><li><a href='frobnick/7.frob.txt'>7.frob.txt</a></li><NL><li><a href='frobnick/8.frob.txt'>8.frob.txt</a></li><NL><li><a href='frobnick/9.frob.txt'>9.frob.txt</a></li><NL><li><a href='frobnick/10.frob.txt'>10.frob.txt</a></li><NL><li><a href='frobnick/11.frob.txt'>11.frob.txt</a></li><NL><li><a href='frobnick/12.frob.txt'>12.frob.txt</a></li><NL><li><a href='frobnick/13.frob.txt'>13.frob.txt</a></li><NL><li><a href='frobnick/14.frob.txt'>14.frob.txt</a></li><NL><li><a href='frobnick/15.frob.txt'>15.frob.txt</a></li><NL><li><a href='frobnick/16.frob.txt'>16.frob.txt</a></li><NL><li><a href='frobnick/17.frob.txt'>17.frob.txt</a></li><NL><li><a href='frobnick/18.frob.txt'>18.frob.txt</a></li><NL><li><a href='frobnick/19.frob.txt'>19.frob.txt</a></li><NL><li><a href='frobnick/20.frob.txt'>20.frob.txt</a></li><NL><li><a href='frobnick/21.frob.txt'>21.frob.txt</a></li><NL><li><a href='frobnick/22.frob.txt'>22.frob.txt</a></li><NL><li><a href='frobnick/23.frob.txt'>23.frob.txt</a></li><NL><li><a href='frobnick/24.frob.txt'>24.frob.txt</a></li><NL><li><a href='frobnick/25.frob.txt'>25.frob.txt</a></li><NL><li><a href='frobnick/26.frob.txt'>26.frob.txt</a></li><NL><li><a href='frobnick/27.frob.txt'>27.frob.txt</a></li><NL><li><a href='frobnick/28.frob.txt'>28.frob.txt</a></li><NL><li><a href='frobnick/29.frob.txt'>29.frob.txt</a></li><NL><li><a href='frobnick/30.frob.txt'>30.frob.txt</a></li><NL><li><a href='frobnick/31.frob.txt'>31.frob.txt</a></li><NL><li><a href='frobnick/32.frob.txt'>32.frob.txt</a></li><NL><li><a href='frobnick/33.frob.txt'>33.frob.txt</a></li><NL><li><a href='frobnick/34.frob.txt'>34.frob.txt</a></li><NL><li><a href='frobnick/35.frob.txt'>35.frob.txt</a></li><NL><li><a href='frobnick/36.frob.txt'>36.frob.txt</a></li><NL><li><a href='frobnick/37.frob.txt'>37.frob.txt</a></li><NL><li><a href='frobnick/38.frob.txt'>38.frob.txt</a></li><NL><li><a href='frobnick/39.frob.txt'>39.frob.txt</a></li><NL><li><a href='frobnick/40.frob.txt'>40.frob.txt</a></li><NL><li><a href='frobnick/41.frob.txt'>41.frob.txt</a></li><NL><li><a href='frobnick/42.frob.txt'>42.frob.txt</a></li><NL><li><a href='frobnick/43.frob.txt'>43.frob.txt</a></li><NL><li><a href='frobnick/44.frob.txt'>44.frob.txt</a></li><NL><li><a href='frobnick/45.frob.txt'>45.frob.txt</a></li><NL><li><a href='frobnick/46.frob.txt'>46.frob.txt</a></li><NL><li><a href='frobnick/47.frob.txt'>47.frob.txt</a></li><NL><li><a href='frobnick/48.frob.txt'>48.frob.txt</a></li><NL><li><a href='frobnick/49.frob.txt'>49.frob.txt</a></li><NL><li><a href='frobnick/50.frob.txt'>50.frob.txt</a></li><NL><li><a href='frobnick/51.frob.txt'>51.frob.txt</a></li><NL><li><a href='frobnick/52.frob.txt'>52.frob.txt</a></li><NL><li><a href='frobnick/53.frob.txt'>53.frob.txt</a></li><NL><li><a href='frobnick/54.frob.txt'>54.frob.txt</a></li><NL><li><a href='frobnick/55.frob.txt'>55.frob.txt</a></li><NL><li><a href='frobnick/56.frob.txt'>56.frob.txt</a></li><NL><li><a href='frobnick/57.frob.txt'>57.frob.txt</a></li><NL><li><a href='frobnick/58.frob.txt'>58.frob.txt</a></li><NL><li><a href='frobnick/59.frob.txt'>59.frob.txt</a></li><NL><li><a href='frobnick/60.frob.txt'>60.frob.txt</a></li><NL><li><a href='frobnick/61.frob.txt'>61.frob.txt</a></li><NL><li><a href='frobnick/62.frob.txt'>62.frob.txt</a></li><NL><li><a href='frobnick/63.frob.txt'>63.frob.txt</a></li><NL><li><a href='frobnick/64.frob.txt'>64.frob.txt</a></li><NL><li><a href='frobnick/65.frob.txt'>65.frob.txt</a></li><NL><li><a href='frobnick/66.frob.txt'>66.frob.txt</a></li><NL><li><a href='frobnick/67.frob.txt'>67.frob.txt</a></li><NL><li><a href='frobnick/68.frob.txt'>68.frob.txt</a></li><NL><li><a href='frobnick/69.frob.txt'>69.frob.txt</a></li><NL><li><a href='frobnick/70.frob.txt'>70.frob.txt</a></li><NL><li><a href='frobnick/71.frob.txt'>71.frob.txt</a></li><NL><li><a href='frobnick/72.frob.txt'>72.frob.txt</a></li><NL><li><a href='frobnick/73.frob.txt'>73.frob.txt</a></li><NL><li><a href='frobnick/74.frob.txt'>74.frob.txt</a></li><NL><li><a href='frobnick/75.frob.txt'>75.frob.txt</a></li><NL><li><a href='frobnick/76.frob.txt'>76.frob.txt</a></li><NL><li><a href='frobnick/77.frob.txt'>77.frob.txt</a></li><NL><li><a href='frobnick/78.frob.txt'>78.frob.txt</a></li><NL><li><a href='frobnick/79.frob.txt'>79.frob.txt</a></li><NL><li><a href='frobnick/80.frob.txt'>80.frob.txt</a></li><NL><li><a href='frobnick/81.frob.txt'>81.frob.txt</a></li><NL><li><a href='frobnick/82.frob.txt'>82.frob.txt</a></li><NL><li><a href='frobnick/83.frob.txt'>83.frob.txt</a></li><NL><li><a href='frobnick/84.frob.txt'>84.frob.txt</a></li><NL><li><a href='frobnick/85.frob.txt'>85.frob.txt</a></li><NL><li><a href='frobnick/86.frob.txt'>86.frob.txt</a></li><NL><li><a href='frobnick/87.frob.txt'>87.frob.txt</a></li><NL><li><a href='frobnick/88.frob.txt'>88.frob.txt</a></li><NL><li><a href='frobnick/89.frob.txt'>89.frob.txt</a></li><NL><li><a href='frobnick/90.frob.txt'>90.frob.txt</a></li><NL><li><a href='frobnick/91.frob.txt'>91.frob.txt</a></li><NL><li><a href='frobnick/92.frob.txt'>92.frob.txt</a></li><NL><li><a href='frobnick/93.frob.txt'>93.frob.txt</a></li><NL><li><a href='frobnick/94.frob.txt'>94.frob.txt</a></li><NL><li><a href='frobnick/95.frob.txt'>95.frob.txt</a></li><NL><li><a href='frobnick/96.frob.txt'>96.frob.txt</a></li><NL><li><a href='frobnick/97.frob.txt'>97.frob.txt</a></li><NL><li><a href='frobnick/98.frob.txt'>98.frob.txt</a></li><NL><li><a href='frobnick/99.frob.txt'>99.frob.txt</a></li><NL><li><a href='frobnick/100.frob.txt'>100.frob.txt</a></li><NL></ul><NL></body><NL></html><NL>Connection closed by foreign host.,telnet localhost 9876
CMBEGIN,,,GET /,<NL>The program 'GET' is currently not installed. To run 'GET' please ask your administrator to install the package 'libwww-perl',
CMBEGIN,Nov 21 12:12:08,/users/lclarkez,telnet localhost 9876,Trying 127.0.0.1...<NL>Connected to localhost.<NL>Escape character is '^]'.<NL>GET /<NL><NL><html><NL><head><NL><title><NL><HT>Frobnick Production Reports<NL></title><NL></head><NL><body><NL><HT><h1>Frobnick Production Reports</h1><NL><HT><ul><NL><li><a href='frobnick/1.frob.txt'>1.frob.txt</a></li><NL><li><a href='frobnick/2.frob.txt'>2.frob.txt</a></li><NL><li><a href='frobnick/3.frob.txt'>3.frob.txt</a></li><NL><li><a href='frobnick/4.frob.txt'>4.frob.txt</a></li><NL><li><a href='frobnick/5.frob.txt'>5.frob.txt</a></li><NL><li><a href='frobnick/6.frob.txt'>6.frob.txt</a></li><NL><li><a href='frobnick/7.frob.txt'>7.frob.txt</a></li><NL><li><a href='frobnick/8.frob.txt'>8.frob.txt</a></li><NL><li><a href='frobnick/9.frob.txt'>9.frob.txt</a></li><NL><li><a href='frobnick/10.frob.txt'>10.frob.txt</a></li><NL><li><a href='frobnick/11.frob.txt'>11.frob.txt</a></li><NL><li><a href='frobnick/12.frob.txt'>12.frob.txt</a></li><NL><li><a href='frobnick/13.frob.txt'>13.frob.txt</a></li><NL><li><a href='frobnick/14.frob.txt'>14.frob.txt</a></li><NL><li><a href='frobnick/15.frob.txt'>15.frob.txt</a></li><NL><li><a href='frobnick/16.frob.txt'>16.frob.txt</a></li><NL><li><a href='frobnick/17.frob.txt'>17.frob.txt</a></li><NL><li><a href='frobnick/18.frob.txt'>18.frob.txt</a></li><NL><li><a href='frobnick/19.frob.txt'>19.frob.txt</a></li><NL><li><a href='frobnick/20.frob.txt'>20.frob.txt</a></li><NL><li><a href='frobnick/21.frob.txt'>21.frob.txt</a></li><NL><li><a href='frobnick/22.frob.txt'>22.frob.txt</a></li><NL><li><a href='frobnick/23.frob.txt'>23.frob.txt</a></li><NL><li><a href='frobnick/24.frob.txt'>24.frob.txt</a></li><NL><li><a href='frobnick/25.frob.txt'>25.frob.txt</a></li><NL><li><a href='frobnick/26.frob.txt'>26.frob.txt</a></li><NL><li><a href='frobnick/27.frob.txt'>27.frob.txt</a></li><NL><li><a href='frobnick/28.frob.txt'>28.frob.txt</a></li><NL><li><a href='frobnick/29.frob.txt'>29.frob.txt</a></li><NL><li><a href='frobnick/30.frob.txt'>30.frob.txt</a></li><NL><li><a href='frobnick/31.frob.txt'>31.frob.txt</a></li><NL><li><a href='frobnick/32.frob.txt'>32.frob.txt</a></li><NL><li><a href='frobnick/33.frob.txt'>33.frob.txt</a></li><NL><li><a href='frobnick/34.frob.txt'>34.frob.txt</a></li><NL><li><a href='frobnick/35.frob.txt'>35.frob.txt</a></li><NL><li><a href='frobnick/36.frob.txt'>36.frob.txt</a></li><NL><li><a href='frobnick/37.frob.txt'>37.frob.txt</a></li><NL><li><a href='frobnick/38.frob.txt'>38.frob.txt</a></li><NL><li><a href='frobnick/39.frob.txt'>39.frob.txt</a></li><NL><li><a href='frobnick/40.frob.txt'>40.frob.txt</a></li><NL><li><a href='frobnick/41.frob.txt'>41.frob.txt</a></li><NL><li><a href='frobnick/42.frob.txt'>42.frob.txt</a></li><NL><li><a href='frobnick/43.frob.txt'>43.frob.txt</a></li><NL><li><a href='frobnick/44.frob.txt'>44.frob.txt</a></li><NL><li><a href='frobnick/45.frob.txt'>45.frob.txt</a></li><NL><li><a href='frobnick/46.frob.txt'>46.frob.txt</a></li><NL><li><a href='frobnick/47.frob.txt'>47.frob.txt</a></li><NL><li><a href='frobnick/48.frob.txt'>48.frob.txt</a></li><NL><li><a href='frobnick/49.frob.txt'>49.frob.txt</a></li><NL><li><a href='frobnick/50.frob.txt'>50.frob.txt</a></li><NL><li><a href='frobnick/51.frob.txt'>51.frob.txt</a></li><NL><li><a href='frobnick/52.frob.txt'>52.frob.txt</a></li><NL><li><a href='frobnick/53.frob.txt'>53.frob.txt</a></li><NL><li><a href='frobnick/54.frob.txt'>54.frob.txt</a></li><NL><li><a href='frobnick/55.frob.txt'>55.frob.txt</a></li><NL><li><a href='frobnick/56.frob.txt'>56.frob.txt</a></li><NL><li><a href='frobnick/57.frob.txt'>57.frob.txt</a></li><NL><li><a href='frobnick/58.frob.txt'>58.frob.txt</a></li><NL><li><a href='frobnick/59.frob.txt'>59.frob.txt</a></li><NL><li><a href='frobnick/60.frob.txt'>60.frob.txt</a></li><NL><li><a href='frobnick/61.frob.txt'>61.frob.txt</a></li><NL><li><a href='frobnick/62.frob.txt'>62.frob.txt</a></li><NL><li><a href='frobnick/63.frob.txt'>63.frob.txt</a></li><NL><li><a href='frobnick/64.frob.txt'>64.frob.txt</a></li><NL><li><a href='frobnick/65.frob.txt'>65.frob.txt</a></li><NL><li><a href='frobnick/66.frob.txt'>66.frob.txt</a></li><NL><li><a href='frobnick/67.frob.txt'>67.frob.txt</a></li><NL><li><a href='frobnick/68.frob.txt'>68.frob.txt</a></li><NL><li><a href='frobnick/69.frob.txt'>69.frob.txt</a></li><NL><li><a href='frobnick/70.frob.txt'>70.frob.txt</a></li><NL><li><a href='frobnick/71.frob.txt'>71.frob.txt</a></li><NL><li><a href='frobnick/72.frob.txt'>72.frob.txt</a></li><NL><li><a href='frobnick/73.frob.txt'>73.frob.txt</a></li><NL><li><a href='frobnick/74.frob.txt'>74.frob.txt</a></li><NL><li><a href='frobnick/75.frob.txt'>75.frob.txt</a></li><NL><li><a href='frobnick/76.frob.txt'>76.frob.txt</a></li><NL><li><a href='frobnick/77.frob.txt'>77.frob.txt</a></li><NL><li><a href='frobnick/78.frob.txt'>78.frob.txt</a></li><NL><li><a href='frobnick/79.frob.txt'>79.frob.txt</a></li><NL><li><a href='frobnick/80.frob.txt'>80.frob.txt</a></li><NL><li><a href='frobnick/81.frob.txt'>81.frob.txt</a></li><NL><li><a href='frobnick/82.frob.txt'>82.frob.txt</a></li><NL><li><a href='frobnick/83.frob.txt'>83.frob.txt</a></li><NL><li><a href='frobnick/84.frob.txt'>84.frob.txt</a></li><NL><li><a href='frobnick/85.frob.txt'>85.frob.txt</a></li><NL><li><a href='frobnick/86.frob.txt'>86.frob.txt</a></li><NL><li><a href='frobnick/87.frob.txt'>87.frob.txt</a></li><NL><li><a href='frobnick/88.frob.txt'>88.frob.txt</a></li><NL><li><a href='frobnick/89.frob.txt'>89.frob.txt</a></li><NL><li><a href='frobnick/90.frob.txt'>90.frob.txt</a></li><NL><li><a href='frobnick/91.frob.txt'>91.frob.txt</a></li><NL><li><a href='frobnick/92.frob.txt'>92.frob.txt</a></li><NL><li><a href='frobnick/93.frob.txt'>93.frob.txt</a></li><NL><li><a href='frobnick/94.frob.txt'>94.frob.txt</a></li><NL><li><a href='frobnick/95.frob.txt'>95.frob.txt</a></li><NL><li><a href='frobnick/96.frob.txt'>96.frob.txt</a></li><NL><li><a href='frobnick/97.frob.txt'>97.frob.txt</a></li><NL><li><a href='frobnick/98.frob.txt'>98.frob.txt</a></li><NL><li><a href='frobnick/99.frob.txt'>99.frob.txt</a></li><NL><li><a href='frobnick/100.frob.txt'>100.frob.txt</a></li><NL></ul><NL></body><NL></html><NL>Connection closed by foreign host.,telnet localhost 9876
CMBEGIN,Nov 21 12:12:39,/users/lclarkez,wget http://localhost:9876/index.html,%--2018-11-21 12:12:39--  http://localhost:9876/index.html<NL>Resolving localhost (localhost)... 127.0.0.1<NL>Connecting to localhost (localhost)|127.0.0.1|:9876... connected.<NL>HTTP request sent%% awaiting response... 200 OK<NL>Length: unspecified [text/html]<NL>Saving to: 'index.html'<NL><NL><NL>index.html                    [<=>                                ]       0  --.-KB/s               <NL>index.html                    [ <=>                               ]   5.59K  --.-KB/s    in 0s      <NL><NL>2018-11-21 12:12:39 (212 MB/s) - 'index.html' saved [5725]<NL>%,wget http://localhost:9876/index.html
CMBEGIN,Nov 21 12:14:20,/users/lclarkez,wget http://localhost:9876/jens,%--2018-11-21 12:14:20--  http://localhost:9876/jens<NL>Resolving localhost (localhost)... 127.0.0.1<NL>Connecting to localhost (localhost)|127.0.0.1|:9876... connected.<NL>HTTP request sent%% awaiting response... 404 Not Found<NL>2018-11-21 12:14:20 ERROR 404: Not Found.<NL>%,wget http://localhost:9876/jens
CMBEGIN,,,wget http://localhost:9876/jensjensjensjensjensjensjensjensjensjensjensjensjensjen ,%s<NL>--2018-11-21 12:14:45--  http://localhost:9876/jensjensjensjensjensjensjensjensjensjensjensjensjensjens<NL>Resolving localhost (localhost)... 127.0.0.1<NL>Connecting to localhost (localhost)|127.0.0.1|:9876... connected.<NL>HTTP request sent%% awaiting response... 404 Not Found<NL>2018-11-21 12:14:45 ERROR 404: Not Found.<NL>%,
CMBEGIN,Nov 21 12:14:45,/users/lclarkez,wget http://localhost:9876/jensjensjensjensjensjensjensjensjensjensjensjensjensjens,,wget http://localhost:9876/jensjensjensjensjensjensjensjensjensjensjensjensjensjens
CMBEGIN,,,wget http://localhost:9876/jensjensjensjensjensjensjensjensjensjensjensjensjensjen ,,
CMBEGIN,,,wget http://localhost:9876/jensjensjensjensjensjensjensjensjensjensjensjensjensje,,
CMBEGIN,Nov 21 12:15:09,/users/lclarkez,wget http://localhost:9876/12345678901234567890,%--2018-11-21 12:15:09--  http://localhost:9876/12345678901234567890<NL>Resolving localhost (localhost)... 127.0.0.1<NL>Connecting to localhost (localhost)|127.0.0.1|:9876... connected.<NL>HTTP request sent%% awaiting response... 404 Not Found<NL>2018-11-21 12:15:09 ERROR 404: Not Found.<NL>%,wget http://localhost:9876/12345678901234567890
CMBEGIN,,,wget http://localhost:9876/1234567890123456789012345678901234567890123456789012345 ,%67890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456 <NL>78901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567 <NL>89012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678 <NL>90123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789 <NL>01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890 <NL>12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901 <NL>23456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012 <NL>34567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123 <NL>45678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234 <NL>56789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345 <NL>67890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456 <NL>78901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567 <NL>89012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678 <NL>90123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789 <NL>01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890 <NL>12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901 <NL>23456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012 <NL>34567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123 <NL>4567890<NL>The name is too long%% 1880 chars total.<NL>Trying to shorten...<NL>New name is 12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456.<NL>--2018-11-21 12:15:58--  http://localhost:9876/12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890<NL>Resolving localhost (localhost)... 127.0.0.1<NL>Connecting to localhost (localhost)|127.0.0.1|:9876... connected.<NL>HTTP request sent%% awaiting response... No data received.<NL>Retrying.<NL><NL>--2018-11-21 12:16:00--  (try: 2)  http://localhost:9876/12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890<NL>Connecting to localhost (localhost)|127.0.0.1|:9876... failed: Connection refused.<NL>Resolving localhost (localhost)... 127.0.0.1<NL>Connecting to localhost (localhost)|127.0.0.1|:9876... failed: Connection refused.%,
CMBEGIN,Nov 21 12:17:09,/users/lclarkez,clear,,clear
CMBEGIN,,,cd /usr/src/fhttpd/,,
CMBEGIN,Nov 21 12:18:39,/usr/src/fhttpd,emacs webserver.c,%=><NL>=-111:----F1  *scratch*      All L1     (Fundamental) ------------------------------------------------<NL>Loading 00debian-vars...done<NL>/etc/emacs/site-start.d/50autoconf.el (source)...<NL>done<NL>Loading /etc/emacs/site-start.d/50autoconf.el (source)...doneFile Edit Options Buffers Tools Lisp-Interaction Help                                                <NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL>-111:----F1  *scratch*      All L1     (Lisp Interaction) -------------------------------------------<NL>For information about GNU Emacs and the GNU system%% type C-h C-a.<NL>Note: file is write protected<NL>Note: file is write protectedFile Edit Options Buffers Tools C Help                                                               <NL><NL>// webserver.c                                                                                       <NL><NL>// FrobozzCo Official Webserver                                                                      <NL><NL>// Barbazzo Fernap barbazzo@gue.com                                                                  <NL><NL>// Gustar Woomax gustar@gue.com                                                                      <NL><NL>// Wilbar Memboob wilbar@gue.com                                                                     <NL><NL><NL>// By the Frobozz Magic Webserver Company                                                            <NL><NL>// Released under the Grue Public License                                                            <NL><NL>// Frobruary 14th%% 1067 GUE                                                                          <NL><NL><NL>// THERE IS NO WARRANTY FOR THE PROGRAM%% TO THE EXTENT PERMITTED                                     <NL><NL>// BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE                                    <NL><NL>// COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \u201CAS IS\u201D                      <NL><NL>// WITHOUT WARRANTY OF ANY KIND%% EITHER EXPRESSED OR IMPLIED%% INCLUDING%%                             <NL><NL>// BUT NOT LIMITED TO%% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND                                 <NL><NL>// FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY                               <NL><NL>// AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE                              <NL><NL>// DEFECTIVE%% *AND IT WILL*%% YOU ASSUME THE COST OF ALL NECESSARY                                    <NL><NL>// SERVICING%% REPAIR OR CORRECTION.                                                                  <NL><NL><NL>#include <stdio.h><NL>#include <errno.h><NL>#include <string.h><NL>#include <stdlib.h><NL>#include <netdb.h><NL>#include <sys/stat.h><NL>#include <sys/types.h><NL>#include <sys/socket.h><NL>#include <netinet/in.h><NL>#include <arpa/inet.h><NL>#include <unistd.h><NL>#include <fcntl.h><NL>#include <time.h><NL>#include <pthread.h><NL><NL>-11U:%%%%--F1  webserver.c    Top L1     (C/l Abbrev) -------------------------------------------------<NL>Beginning of buffer<NL>2<NL><NL>35811782130<NL>#define _XOPEN_SOURCE<NL><NL>typedef struct {<NL>        char *method;<NL>        char *uri;<NL>        char *version;<NL>        char *headers;<NL>} httpreq_t;<NL><NL><NL>/* NOTE: this function is based on a function provided in the GNU "timegm" man                       <NL><NL>   page. timegm is a GNU extension to time.h that returns the given tm struct as                     <NL><NL>   a UNIX timestamp in GMT/UTC%% rather than local time. The man page suggests a                      <NL><NL>   function similar to the one below as a portable equivalent.                                       <NL><NL> */<NL>time_t my_timegm(struct tm *tm) {<NL>        time_t ret;<NL>        char *tz;<NL><NL>        tz = getenv("TZ");<NL>        putenv("TZ=GMT");<NL>        tzset();<NL>        ret = mktime(tm);<NL><HT>if (tz) { 8%% L4254 */<NL>time_t my_timegm(struct tm *tm) {<NL>        time_t ret;<NL>        char *tz;<NL><NL>        tz = getenv("TZ");<NL>        putenv("TZ=GMT");<NL>        tzset();<NL>        ret = mktime(tm);<NL>        if (tz) {<NL>char envstr[strlen(tz) + 4];<NL>                envstr[0] = '\0';<NL><HT><HT>strcat(envstr%% "TZ=");<NL>                strcat(envstr%% tz);<NL><HT>        putenv(envstr);<NL><HT>} else {<NL><HT>        putenv("TZ=");<NL><HT>}<NL><NL><HT>tzset();<NL><NL>        return ret;<NL>}<NL><NL>char *get_header(const httpreq_t *req%% const char* headername) {<NL>        char *hdrptr;<NL>        char *hdrend;<NL><HT>char *retval = NULL;<NL><NL><HT>char searchstr[strlen(headername) + 5];<NL><HT>strcpy(searchstr%% "<NL>");<NL><HT>strcat(searchstr%% headername);<NL><HT>strcat(searchstr%% ": ");<NL>hdrptr = strstr(req->headers%% searchstr)) {12%% L6787653059741<NL><NL>#include <unistd.h><NL>#include <fcntl.h><NL>#include <time.h><NL>#include <pthread.h><NL><NL>#define _XOPEN_SOURCE<NL><NL>typedef struct {<NL>        char *method;<NL>        char *uri;<NL>        char *version;<NL>        char *headers;<NL>} httpreq_t;<NL><NL><NL>/* NOTE: this function is based on a function provided in the GNU "timegm" man                       <NL><NL>   page. timegm is a GNU extension to time.h that returns the given tm struct as                     <NL><NL>   a UNIX timestamp in GMT/UTC%% rather than local time. The man page suggests a                      <NL><NL>   function similar to the one below as a portable equivalent.                                       <NL> 9%% L48952763                putenv("TZ=");<NL>        }<NL><NL>        tzset();<NL><NL>        return ret;<NL>}<NL><NL>char *get_header(const httpreq_t *req%% const char* headername) {<NL>        char *hdrptr;<NL>        char *hdrend;<NL>        char *retval = NULL;<NL><NL>        char searchstr[strlen(headername) + 5];<NL>        strcpy(searchstr%% "<NL>");<NL>        strcat(searchstr%% headername);<NL>        strcat(searchstr%% ": ");<NL><NL>        if (hdrptr = strstr(req->headers%% searchstr)) {<NL>                hdrptr += strlen(searchstr);<NL>                if (hdrend = strstr(hdrptr%% "<NL>")) {<NL>                        char hdrval[1024]; // temporary return value                                 <NL><NL>                        memcpy((char *)hdrval%% hdrptr%% (hdrend - hdrptr));13%% L71985678<NL>                        hdrval[hdrend - hdrptr] = '\0'; // tack null onto end of header value        <NL><NL>                        int hdrvallen = strlen(hdrval);<NL>                        retval = (char *)malloc((hdrvallen + 1) * sizeof(char)); // malloc a space f\<NL><NL>or retval                                                                                            <NL><NL>                        strcpy(retval%% (char *)hdrval);<NL>                } else {<NL>                        retval = (char *)malloc((strlen(hdrptr) + 1) * sizeof(char)); //             <NL><NL>                        strcpy(retval%% hdrptr);<NL>                }<NL>        }<NL><NL>        return retval;<NL>}<NL><NL>/* As long as str begins with a proper HTTP-Version followed by delim%% returns a                     <NL><NL>   pointer to the start of the version number (e.g.%% 1.0). Returns NULL otherwise.                   <NL><NL> */<NL>char *http_version_str(char *str%% char *delim) {<NL>        char *vstart = strstr(str%% "HTTP/");5%% L901<NL>47910024        char *vnumstart = str + 5;<NL>        char *vdot = strchr(str%% '.');<NL>        char *vend = strstr(str%% delim);<NL>        char *digits = "0123456789";<NL>        int majvlen = 0;<NL>        int minvlen = 0;<NL><NL>        if (!vstart || !vdot // something's missing                                                  <NL><NL>                || vstart != str) // str doesn't start with "HTTP/"                                  <NL><NL>                return NULL;<NL><NL>        majvlen = strspn(vnumstart%% digits);<NL>        minvlen = strspn(vdot + 1%% digits);<NL><NL>        if (majvlen < 1 || (vnumstart + majvlen) != vdot // bad major version                        <NL><NL>                || minvlen < 1 || (vdot + minvlen + 1) != vend) // bad minor version                 <NL><NL>                return NULL;<NL>9%% L10875095 <NL>char *get_header(const httpreq_t *req%% const char* headername) {<NL>        char *hdrptr;<NL>        char *hdrend;<NL>        char *retval = NULL;<NL><NL>        char searchstr[strlen(headername) + 5];<NL>        strcpy(searchstr%% "<NL>");<NL>        strcat(searchstr%% headername);<NL>        strcat(searchstr%% ": ");<NL><NL>        if (hdrptr = strstr(req->headers%% searchstr)) {<NL>                hdrptr += strlen(searchstr);<NL>                if (hdrend = strstr(hdrptr%% "<NL>")) {<NL>                        char hdrval[1024]; // temporary return value                                 <NL><NL>                        memcpy((char *)hdrval%% hdrptr%% (hdrend - hdrptr));<NL>                        hdrval[hdrend - hdrptr] = '\0'; // tack null onto end of header value        <NL><NL>                        int hdrvallen = strlen(hdrval);5%% L90843217984<NL><NL>time_t ret;<NL>        char *tz;<NL><NL>        tz = getenv("TZ");<NL>        putenv("TZ=GMT");<NL>        tzset();<NL>        ret = mktime(tm);<NL>        if (tz) {<NL>                char envstr[strlen(tz) + 4];<NL>                envstr[0] = '\0';<NL>                strcat(envstr%% "TZ=");<NL>                strcat(envstr%% tz);<NL>                putenv(envstr);<NL>        } else {<NL>                putenv("TZ=");<NL>        }<NL><NL>        tzset();<NL><NL>        return ret;<NL>}<NL>3%% L698321594#include <fcntl.h><NL>#include <time.h><NL>#include <pthread.h><NL><NL>#define _XOPEN_SOURCE<NL><NL>typedef struct {<NL>        char *method;<NL>        char *uri;<NL>        char *version;<NL>        char *headers;<NL>} httpreq_t;<NL><NL><NL>/* NOTE: this function is based on a function provided in the GNU "timegm" man                       <NL><NL>   page. timegm is a GNU extension to time.h that returns the given tm struct as                     <NL><NL>   a UNIX timestamp in GMT/UTC%% rather than local time. The man page suggests a                      <NL><NL>   function similar to the one below as a portable equivalent.                                       <NL><NL> */<NL>time_t my_timegm(struct tm *tm) { 9%% L49513764// WITHOUT WARRANTY OF ANY KIND%% EITHER EXPRESSED OR IMPLIED%% INCLUDING%%                             <NL><NL>// BUT NOT LIMITED TO%% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND                                 <NL><NL>// FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY                               <NL><NL>// AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE                              <NL><NL>// DEFECTIVE%% *AND IT WILL*%% YOU ASSUME THE COST OF ALL NECESSARY                                    <NL><NL>// SERVICING%% REPAIR OR CORRECTION.                                                                  <NL><NL><NL>#include <stdio.h><NL>#include <errno.h><NL>#include <string.h><NL>#include <stdlib.h><NL>#include <netdb.h><NL>#include <sys/stat.h><NL>#include <sys/types.h><NL>#include <sys/socket.h><NL>#include <netinet/in.h><NL>#include <arpa/inet.h><NL>#include <unistd.h>4%% L3127654117// webserver.c                                                                                       <NL><NL>// FrobozzCo Official Webserver                                                                      <NL><NL>// Barbazzo Fernap barbazzo@gue.com                                                                  <NL><NL>// Gustar Woomax gustar@gue.com                                                                      <NL><NL>// Wilbar Memboob wilbar@gue.com                                                                     <NL><NL><NL>// By the Frobozz Magic Webserver Company                                                            <NL><NL>// Released under the Grue Public License                                                            <NL><NL>// Frobruary 14th%% 1067 GUE                                                                          <NL><NL><NL>// THERE IS NO WARRANTY FOR THE PROGRAM%% TO THE EXTENT PERMITTED                                     <NL><NL>// BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE                                    <NL><NL>// COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \u201CAS IS\u201D                      <NL>Top L9 875Beginning of buffer1<NL>2<NL><NL>3579162331<NL>#define _XOPEN_SOURCE<NL><NL>typedef struct {<NL>        char *method;<NL>        char *uri;<NL>        char *version;<NL>        char *headers;<NL>} httpreq_t;<NL><NL><NL>/* NOTE: this function is based on a function provided in the GNU "timegm" man                       <NL><NL>   page. timegm is a GNU extension to time.h that returns the given tm struct as                     <NL><NL>   a UNIX timestamp in GMT/UTC%% rather than local time. The man page suggests a                      <NL><NL>   function similar to the one below as a portable equivalent.                                       <NL><NL> */<NL>time_t my_timegm(struct tm *tm) {<NL>        time_t ret;<NL>        char *tz; 7%% L3794123456789534<NL><NL>        tz = getenv("TZ");<NL>        putenv("TZ=GMT");<NL>        tzset();<NL>        ret = mktime(tm);<NL>        if (tz) {<NL>                char envstr[strlen(tz) + 4];<NL>                envstr[0] = '\0';<NL>                strcat(envstr%% "TZ=");<NL>                strcat(envstr%% tz);<NL>                putenv(envstr);<NL>        } else {<NL>                putenv("TZ=");<NL>        }<NL><NL>        tzset();<NL><NL>        return ret;<NL>}9%% L55678960123456789712<NL><NL>char *get_header(const httpreq_t *req%% const char* headername) {<NL>        char *hdrptr;<NL>        char *hdrend;<NL>        char *retval = NULL;<NL><NL>        char searchstr[strlen(headername) + 5];<NL>        strcpy(searchstr%% "<NL>");<NL>        strcat(searchstr%% headername);<NL>        strcat(searchstr%% ": ");<NL><NL>        if (hdrptr = strstr(req->headers%% searchstr)) {<NL>                hdrptr += strlen(searchstr);<NL>                if (hdrend = strstr(hdrptr%% "<NL>")) {<NL>                        char hdrval[1024]; // temporary return value                                 <NL><NL>                        memcpy((char *)hdrval%% hdrptr%% (hdrend - hdrptr));<NL>                        hdrval[hdrend - hdrptr] = '\0'; // tack null onto end of header value        <NL><NL>                        int hdrvallen = strlen(hdrval);13%% L734568803790<NL>                        retval = (char *)malloc((hdrvallen + 1) * sizeof(char)); // malloc a space f\<NL><NL>or retval                                                                                            <NL><NL>                        strcpy(retval%% (char *)hdrval);<NL>                } else {<NL>                        retval = (char *)malloc((strlen(hdrptr) + 1) * sizeof(char)); //             <NL><NL>                        strcpy(retval%% hdrptr);<NL>                }<NL>        }<NL><NL>        return retval;<NL>}<NL><NL>/* As long as str begins with a proper HTTP-Version followed by delim%% returns a                     <NL><NL>   pointer to the start of the version number (e.g.%% 1.0). Returns NULL otherwise.                   <NL><NL> */<NL>char *http_version_str(char *str%% char *delim) {<NL>        char *vstart = strstr(str%% "HTTP/");<NL>        char *vnumstart = str + 5;<NL>        char *vdot = strchr(str%% '.');<NL>        char *vend = strstr(str%% delim);5%% L93456789101454191         ret = mktime(tm);<NL>        if (tz) {<NL>                char envstr[strlen(tz) + 4];<NL>                envstr[0] = '\0';<NL>                strcat(envstr%% "TZ=");<NL>                strcat(envstr%% tz);<NL>                putenv(envstr);<NL>        } else {<NL>                putenv("TZ=");<NL>        }<NL><NL>        tzset();<NL><NL>        return ret;<NL>}<NL><NL>char *get_header(const httpreq_t *req%% const char* headername) {<NL>        char *hdrptr;3%% L75<NL>typedef struct {<NL>        char *method;<NL>        char *uri;<NL>        char *version;<NL>        char *headers;<NL>} httpreq_t;<NL><NL><NL>/* NOTE: this function is based on a function provided in the GNU "timegm" man                       <NL><NL>   page. timegm is a GNU extension to time.h that returns the given tm struct as                     <NL><NL>   a UNIX timestamp in GMT/UTC%% rather than local time. The man page suggests a                      <NL><NL>   function similar to the one below as a portable equivalent.                                       <NL><NL> */<NL>time_t my_timegm(struct tm *tm) {<NL>        time_t ret;<NL>        char *tz;<NL><NL>        tz = getenv("TZ");<NL>        putenv("TZ=GMT");<NL>        tzset(); 9%% L54// WITHOUT WARRANTY OF ANY KIND%% EITHER EXPRESSED OR IMPLIED%% INCLUDING%%                             <NL>// BUT NOT LIMITED TO%% THE IMPLIED WARRANTIES OF MERCHANTABILITY AND                                 <NL><NL>// FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY                               <NL><NL>// AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE                              <NL><NL>// DEFECTIVE%% *AND IT WILL*%% YOU ASSUME THE COST OF ALL NECESSARY                                    <NL><NL>// SERVICING%% REPAIR OR CORRECTION.                                                                  <NL><NL><NL>#include <stdio.h><NL>#include <errno.h><NL>#include <string.h><NL>#include <stdlib.h><NL>#include <netdb.h><NL>#include <sys/stat.h><NL>#include <sys/types.h><NL>#include <sys/socket.h><NL>#include <netinet/in.h><NL>#include <arpa/inet.h><NL>#include <unistd.h><NL>#include <fcntl.h><NL>#include <time.h><NL>#include <pthread.h><NL><NL>#define _XOPEN_SOURCE<NL>4%% L31// webserver.c                                                                                       <NL><NL>// FrobozzCo Official Webserver                                                                      <NL><NL>// Barbazzo Fernap barbazzo@gue.com                                                                  <NL><NL>// Gustar Woomax gustar@gue.com                                                                      <NL><NL>// Wilbar Memboob wilbar@gue.com                                                                     <NL><NL><NL>// By the Frobozz Magic Webserver Company                                                            <NL><NL>// Released under the Grue Public License                                                            <NL><NL>// Frobruary 14th%% 1067 GUE                                                                          <NL><NL><NL>// THERE IS NO WARRANTY FOR THE PROGRAM%% TO THE EXTENT PERMITTED                                     <NL><NL>// BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE                                    <NL><NL>// COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \u201CAS IS\u201D                      <NL>Top L7 Beginning of buffer1<NL>2<NL><NL>481142334#include <fcntl.h><NL>#include <time.h><NL>#include <pthread.h><NL><NL>#define _XOPEN_SOURCE<NL><NL>typedef struct {<NL>        char *method;<NL>        char *uri;<NL><HT>char *version;<NL>        char *headers;<NL>} httpreq_t;<NL><NL><NL>* NOTE: this function is based on a function provided in the GNU "timegm" man<NL>   page. timegm is a GNU extension to time.h that returns the given tm struct as<NL>   a UNIX timestamp in GMT/UTC%% rather than local time. The man page suggests a<NL>   function similar to the one below as a portable equivalent.   <NL> */<NL>time_t my_timegm(struct tm *tm) {<NL>        time_t ret;<NL>        char *tz;<NL><NL>        tz = getenv("TZ");<NL>        putenv("TZ=GMT");<NL>        tzset();<NL>        ret = mktime(tm);<NL>        if (tz) {<NL>                char envstr[strlen(tz) + 4];<NL>                envstr[0] = '\0';<NL>                strcat(envstr%% "TZ=");<NL>                strcat(envstr%% tz);<NL>                putenv(envstr);<NL>        } else {<NL>putenv("TZ=");<NL> 9%% L49        }<NL><NL>        tzset();<NL><NL>        return ret;<NL>}<NL><NL>char *get_header(const httpreq_t *req%% const char* headername) {<NL>        char *hdrptr;<NL>        char *hdrend;<NL>        char *retval = NULL;<NL><NL>        char searchstr[strlen(headername) + 5];<NL>        strcpy(searchstr%% "<NL>");<NL>        strcat(searchstr%% headername);<NL>        strcat(searchstr%% ": ");<NL><NL>        if (hdrptr = strstr(req->headers%% searchstr)) {<NL>                hdrptr += strlen(searchstr);<NL>                if (hdrend = strstr(hdrptr%% "<NL>")) {<NL>                        char hdrval[1024]; // temporary return value                                 <NL><NL>                        memcpy((char *)hdrval%% hdrptr%% (hdrend - hdrptr));13%% L71069764054<NL>#include <fcntl.h><NL>#include <time.h><NL>#include <pthread.h><NL><NL>#define _XOPEN_SOURCE<NL><NL>typedef struct {<NL>        char *method;<NL>        char *uri;<NL>        char *version;<NL>        char *headers;<NL>} httpreq_t;<NL><NL><NL>/* NOTE: this function is based on a function provided in the GNU "timegm" man                       <NL><NL>   page. timegm is a GNU extension to time.h that returns the given tm struct as                     <NL><NL>   a UNIX timestamp in GMT/UTC%% rather than local time. The man page suggests a                      <NL><NL>   function similar to the one below as a portable equivalent.                                       <NL><NL> */<NL>time_t my_timegm(struct tm *tm) {<NL>        time_t ret;<NL>        char *tz;<NL> 9%% L498679526860123456<NL>        }<NL><NL>        tzset();<NL><NL>        return ret;<NL>}<NL><NL>char *get_header(const httpreq_t *req%% const char* headername) {<NL>        char *hdrptr;<NL>        char *hdrend;<NL>        char *retval = NULL;<NL><NL>        char searchstr[strlen(headername) + 5];<NL>        strcpy(searchstr%% "<NL>");<NL>        strcat(searchstr%% headername);<NL>        strcat(searchstr%% ": ");<NL><NL>        if (hdrptr = strstr(req->headers%% searchstr)) {12%% L67897013680123                hdrptr += strlen(searchstr);<NL>                if (hdrend = strstr(hdrptr%% "<NL>")) {<NL>                        char hdrval[1024]; // temporary return value                                 <NL><NL>                        memcpy((char *)hdrval%% hdrptr%% (hdrend - hdrptr));<NL>                        hdrval[hdrend - hdrptr] = '\0'; // tack null onto end of header value        <NL><NL>                        int hdrvallen = strlen(hdrval);<NL>                        retval = (char *)malloc((hdrvallen + 1) * sizeof(char)); // malloc a space f\<NL><NL>or retval                                                                                            <NL><NL>                        strcpy(retval%% (char *)hdrval);<NL>                } else {<NL>                        retval = (char *)malloc((strlen(hdrptr) + 1) * sizeof(char)); //             <NL><NL>                        strcpy(retval%% hdrptr);<NL>                }<NL>        }<NL><NL>        return retval;<NL>}<NL>4%% L8567907<NL>/* As long as str begins with a proper HTTP-Version followed by delim%% returns a                     <NL><NL>   pointer to the start of the version number (e.g.%% 1.0). Returns NULL otherwise.                   <NL><NL> */<NL>char *http_version_str(char *str%% char *delim) {<NL>        char *vstart = strstr(str%% "HTTP/");<NL>        char *vnumstart = str + 5;<NL>        char *vdot = strchr(str%% '.');<NL>        char *vend = strstr(str%% delim);<NL>        char *digits = "0123456789";<NL>        int majvlen = 0;<NL>        int minvlen = 0;<NL><NL>        if (!vstart || !vdot // something's missing                                                  <NL><NL>                || vstart != str) // str doesn't start with "HTTP/"                                  <NL><NL>                return NULL;<NL><NL>        majvlen = strspn(vnumstart%% digits);<NL>        minvlen = strspn(vdot + 1%% digits);<NL><NL>        if (majvlen < 1 || (vnumstart + majvlen) != vdot // bad major version                        <NL><NL><HT><HT>|| minvlen < 1 || (vdot + minvlen + 1) != vend) // bad minor version                 <NL>8%% L10617892012<NL>                return NULL;<NL><NL>        return vnumstart;<NL>}<NL><NL>/* Fills req with the request data from datastr. Returns 0 on success.                               <NL><NL> */<NL><NL>int parsereq(httpreq_t *req%% char *datastr) {<NL>        char *position;<NL>        char *last_position = datastr;<NL>        char *temp_position;<NL>        int matchlen;<NL><NL>        req->method = "";<NL>        req->uri = "";<NL>        req->version = "";<NL>        req->headers = "";23%% L1234567893012358940<NL><NL>        if (!(position = strchr(last_position%% ' '))) {<NL>                return 1;<NL>        }<NL>        matchlen = (int)(position - last_position);<NL>        req->method = (char *)malloc((matchlen + 1) * sizeof(char));<NL>        memcpy(req->method%% last_position%% matchlen);<NL>        req->method[matchlen] = '\0';<NL>        last_position = position + 1;<NL><NL>        if (!(position = strchr(last_position%% ' '))<NL>                && !(position = strstr(last_position%% "<NL>"))) {<NL>                return 1;<NL>        }<NL><NL>        // strip any query string out of the URI                                                     <NL><NL>        if ((temp_position = strchr(last_position%% '?')) && temp_position < position)<NL>                matchlen = (int)(temp_position - last_position);7%% L14123458950247        else<NL>                matchlen = (int)(position - last_position);<NL><NL>        req->uri = (char *)malloc((matchlen + 1) * sizeof(char));<NL>        memcpy(req->uri%% last_position%% matchlen);<NL>        req->uri[matchlen] = '\0';<NL>        if (position[0] == '<NL>') {<NL>                req->version = "0.9";<NL>                req->headers = "";<NL>                return 0; // simple req -- uri only                                                  <NL><NL>        }<NL><NL>        // If we get here%% it's a full request%% get the HTTP version and headers                     <NL><NL>        last_position = position + 1;<NL><NL>        if (!(position = strstr(last_position%% "<NL>"))<NL>                || !(last_position = http_version_str(last_position%% "<NL>"))) {<NL>                return 1;<NL>        }<NL>30%% L161235974<NL>        matchlen = (int)(position - last_position);<NL>        req->version = (char *)malloc((matchlen + 1) * sizeof(char));<NL>        memcpy(req->version%% last_position%% matchlen);<NL>        req->version[matchlen] = '\0';<NL>        last_position = position;<NL><NL>        req->headers = (char *)malloc(strlen(last_position) * sizeof(char));<NL>        strcpy(req->headers%% last_position);<NL><NL>        return 0;<NL>}<NL><NL>char *contype(char *ext) {<NL>        if (strcmp(ext%% "html") == 0) return "text/html";<NL>        else if (strcmp(ext%% "htm") == 0) return "text/html";<NL>        else if (strcmp(ext%% "jpeg") == 0) return "image/jpeg";<NL>        else if (strcmp(ext%% "jpg") == 0) return "image/jpeg";<NL><HT>else if (strcmp(ext%% "gif") == 0) return "image/gif";4%% L1798013690136<NL>        else if (strcmp(ext%% "txt") == 0) return "text/plain";<NL>        else return "application/octet-stream";<NL><NL>}<NL><NL>char *status(int statcode) {<NL>        if (statcode == 200)    return "200 OK";<NL>        else if (statcode == 304) return "304 Not Modified";<NL>        else if (statcode == 400) return "400 Bad Request";<NL>        else if (statcode == 403) return "403 Forbidden";<NL>        else if (statcode == 404) return "404 Not Found";<NL>        else if (statcode == 500) return "500 Internal Server Error";<NL>        else if (statcode == 501) return "501 Not Implemented";<NL>        else return "";<NL>}<NL><NL>int send_response(int sockfd%% httpreq_t *req%% int statcode) {<NL>        int urifd;8%% L1978920012345678910123        const int BUFSIZE = 1024;<NL>        char sendmessage[BUFSIZE];<NL>        char *path = req->uri;<NL><NL>        if (req->uri == NULL || req->method == NULL ||<NL>                req->headers == NULL || req->version == NULL) {<NL>                return 0;<NL>        }<NL><NL><NL>        if ((path[0] == '/') || ((strstr(path%% "http://") == path)<NL>                                                         && (path = strchr(path + 7%%  '/')))) {<NL>                path += 1; // remove leading slash                                                   <NL><NL>                if (path[0] == '\0') {  // substituting in index.html for a blank URL!               <NL><NL>                        path = "index.html";<NL>                } else if (path[strlen(path) - 1] == '/') {<NL>                        //concatenating index.html for a /-terminated URL!                           <NL><NL>                        strcat(path%% "index.html");<NL>                }43%% L2167892123456893123<NL>        } else {<NL>                statcode = 400;<NL>        }<NL><NL>        if (statcode == 200 && (urifd = open(path%% O_RDONLY%% 0)) < 0) {<NL>                if (errno == ENOENT || errno == ENOTDIR) { // file or directory doesn't exist        <NL><NL>                        statcode = 404;<NL>                } else if (errno == EACCES) { // access denied                                       <NL><NL>                        statcode = 403;<NL>                } else {<NL>                        // some other file access problem                                            <NL><NL>                        statcode = 500;<NL>                }<NL>        }<NL><NL>        if (strstr(path%% "..") != NULL) {<NL>                statcode = 500;<NL>        }7%% L234568412489501<NL><NL><NL>        sendmessage[0] = '\0';<NL>        if (strcmp(req->version%% "0.9") != 0) { // full request                                      <NL><NL>                char *ext; // file extension                                                         <NL><NL>                time_t curtime;<NL>                char *imstime;<NL>                struct tm tm;<NL>                struct stat stbuf;<NL><NL><NL>                if (statcode == 200) {<NL>                        if (ext = strrchr(path%% '.')) ext++; // skip the '.'                         <NL><NL>                        else ext = "";<NL>                } else {<NL>                        // errors are always html messages                                           <NL><NL>                        ext = "html";<NL>                }51%% L252345760345679<NL><NL>                // Conditional GET                                                                   <NL><NL>                if ((strcmp(req->method%% "GET") == 0)<NL>                        && (statcode == 200)<NL>                        && (imstime = get_header(req%% "If-Modified-Since"))) {<NL><NL>                        // Get statistics about the requested URI from the local filesystem          <NL><NL>                        if (stat(path%% &stbuf) == -1) {<NL>                                statcode = 500;<NL>                        }<NL><NL>                        if (!strptime(imstime%% "%%a%% %%d %%b %%Y %%H:%%M:%%S GMT"%% &tm)<NL>                                && !strptime(imstime%% "%%a%% %%d-%%b-%%y %%H:%%M:%%S GMT"%% &tm)<NL>                                && !strptime(imstime%% "%%a %%b %%d %%H:%%M:%%S %%Y"%% &tm)) {<NL>                                // badly formatted date                                              <NL><NL>                                statcode = 400;<NL>                        }<NL><NL>                        if (stbuf.st_mtime <= my_timegm(&tm)) {<NL>                                // Not Modified                                                      <NL><NL>                                statcode = 304;<NL>                        }5%% L27482491<NL>                }<NL><NL>                time(&curtime); // time for Date: header                                             <NL><NL>                strcat(sendmessage%% "HTTP/1.0 ");<NL>                strcat(sendmessage%% status(statcode));<NL>                strcat(sendmessage%% "<NL>Date: ");<NL>                strncat(sendmessage%% asctime(gmtime(&curtime))%% 24);<NL>                strcat(sendmessage%% "<NL>Server: Frobozz Magic Software Company Webserver v.002");<NL>                strcat(sendmessage%% "<NL>Connection: close");<NL>                strcat(sendmessage%% "<NL>Content-Type: ");<NL>                strcat(sendmessage%% contype(ext));<NL>                strcat(sendmessage%% "<NL><NL>");<NL><NL>        }<NL><NL>        if (statcode != 200) {<NL>                strcat(sendmessage%% "<html><head><title>");<NL>                strcat(sendmessage%% status(statcode));8%% L29235678930359<NL>                strcat(sendmessage%% "</title></head><body><h2>HTTP/1.0</h2><h1>");<NL>                strcat(sendmessage%% status(statcode));<NL>                strcat(sendmessage%% "</h1><h2>URI: ");<NL>                strcat(sendmessage%% path);<NL>                strcat(sendmessage%% "</h2></body></html>");<NL>        }<NL><NL>        if (sendmessage[0] != '\0') {<NL>                // send headers as long as there are headers to send                                 <NL><NL>                if (send(sockfd%% sendmessage%% strlen(sendmessage)%% 0) < 0) {<NL>                        perror("send");<NL>                        pthread_exit(NULL);<NL>                }<NL>        }<NL><NL>        if (statcode == 200 && (strcmp(req->method%% "HEAD") != 0)) {<NL>                // send the requested file as long as there's no error and the                       <NL><NL>                // request wasn't just for the headers                                               <NL>61%% L31012567920101860298if (ext = strrchr(path%% '.')) ext++; // skip the '.'                         <NL>                        else ext = "";<NL>                } else {<NL>                        // errors are always html messages                                           <NL><NL>                        ext = "html";<NL>                }<NL><NL>                // Conditional GET                                                                   <NL><NL>                if ((strcmp(req->method%% "GET") == 0)<NL>                        && (statcode == 200)<NL>                        && (imstime = get_header(req%% "If-Modified-Since"))) {<NL><NL>                        // Get statistics about the requested URI from the local filesystem          <NL><NL>                        if (stat(path%% &stbuf) == -1) {<NL>                                statcode = 500;<NL>                        }<NL><NL>                        if (!strptime(imstime%% "%%a%% %%d %%b %%Y %%H:%%M:%%S GMT"%% &tm)<NL>                                && !strptime(imstime%% "%%a%% %%d-%%b-%%y %%H:%%M:%%S GMT"%% &tm)<NL>                                && !strptime(imstime%% "%%a %%b %%d %%H:%%M:%%S %%Y"%% &tm)) {<NL>                                // badly formatted date                                              <NL><NL>                                statcode = 400;<NL>                        }<NL><NL>                        if (stbuf.st_mtime <= my_timegm(&tm)) {<NL>                                // Not Modified                                                      <NL><NL>                                statcode = 304;<NL>                        }<NL>                }<NL>56%% L281079802479946                strcat(sendmessage%% "<NL>Server: Frobozz Magic Software Company Webserver v.002");<NL>                strcat(sendmessage%% "<NL>Connection: close");<NL>                strcat(sendmessage%% "<NL>Content-Type: ");<NL>                strcat(sendmessage%% contype(ext));<NL>                strcat(sendmessage%% "<NL><NL>");<NL><NL>        }<NL><NL>        if (statcode != 200) {<NL>                strcat(sendmessage%% "<html><head><title>");<NL>                strcat(sendmessage%% status(statcode));<NL>                strcat(sendmessage%% "</title></head><body><h2>HTTP/1.0</h2><h1>");<NL>                strcat(sendmessage%% status(statcode));<NL>                strcat(sendmessage%% "</h1><h2>URI: ");<NL>                strcat(sendmessage%% path);<NL>                strcat(sendmessage%% "</h2></body></html>");<NL>        }<NL><NL>        if (sendmessage[0] != '\0') {<NL>                // send headers as long as there are headers to send                                 <NL>60%% L3018911234578<NL>                if (send(sockfd%% sendmessage%% strlen(sendmessage)%% 0) < 0) {<NL>                        perror("send");<NL>                        pthread_exit(NULL);<NL>                }<NL>        }<NL><NL>        if (statcode == 200 && (strcmp(req->method%% "HEAD") != 0)) {<NL>                // send the requested file as long as there's no error and the                       <NL><NL>                // request wasn't just for the headers                                               <NL><NL>                int readbytes;<NL><NL>                while (readbytes = read(urifd%% sendmessage%% BUFSIZE)) {<NL>                        if (readbytes < 0) {<NL>                                perror("read");<NL>                                pthread_exit(NULL);<NL>                        }<NL>                        if (send(sockfd%% sendmessage%% readbytes%% 0) < 0) {<NL>                                perror("send");4%% L31920146834                                pthread_exit(NULL);<NL>                        }<NL>                }<NL>        }<NL>}<NL><NL>void *data_thread(void *sockfd_ptr) {<NL><NL>        int sockfd = *(int *) sockfd_ptr;<NL>        const int BUFSIZE = 5;<NL>        char recvmessage[BUFSIZE];<NL>        char *headerstr = NULL;<NL>        char *newheaderstr = NULL;<NL>        int recvbytes = 0;<NL>        int curheadlen = 0;<NL>        int totalheadlen = 0;<NL>        httpreq_t req;<NL>        int statcode = 200;<NL>        int done = 0;<NL>        int seen_header = 0;<NL>        char *header_end;9%% L34075567<NL>        int content_length = 0;<NL>        char *qstr;<NL><NL>        free(sockfd_ptr); // we have the int value out of this now                                   <NL><NL>        recvmessage[BUFSIZE - 1] = '\0'; // mark end of "string"                                     <NL><NL><NL>        /* Read incoming client message from the socket */<NL>        while(!done && (recvbytes = recv(sockfd%% recvmessage%% BUFSIZE - 1%% 0))) {<NL>                if (recvbytes < 0) {<NL>                        perror("recv");<NL>                        pthread_exit(NULL);<NL>                }<NL><NL><NL>                recvmessage[recvbytes] = '\0';<NL><NL>                if (seen_header) {<NL>                        // getting the entity body                                                   <NL>72%% L35896012357703                        content_length -= recvbytes;<NL>                        if (content_length <= 0) done = 1;<NL><NL>                } else {<NL><NL>                        newheaderstr = (char *) malloc((totalheadlen + recvbytes + 1) * sizeof(char)\<NL><NL>);<NL>                        newheaderstr[totalheadlen + recvbytes] = '\0';<NL>                        memcpy(newheaderstr%% headerstr%% totalheadlen);<NL>                        memcpy(newheaderstr + totalheadlen%% recvmessage%% recvbytes);<NL><NL>                        if (headerstr != NULL) {<NL>                                free(headerstr);<NL>                        }<NL><NL>                        headerstr = newheaderstr;<NL>                        totalheadlen += recvbytes;<NL><NL>                        header_end = strstr(headerstr%% "<NL><NL>");5%% L37798149901<NL>                        if (header_end) {<NL>                                seen_header = 1;<NL>                                header_end[2] = '\0';<NL><NL>                                if (parsereq(&req%% headerstr) != 0) {<NL>                                        statcode = 400;<NL>                                }<NL><NL>                                if (strcmp(req.method%% "POST") == 0) {<NL><NL>                                        // grab the body length                                      <NL><NL>                                        char *clenstr = get_header(&req%% "Content-Length");<NL><NL>                                        if (clenstr) {<NL><NL>                                                content_length = atoi(clenstr) - ((headerstr + total\<NL>8%% L3948402345678910<NL>headlen) - header_end - 4);<NL><NL>                                                if (content_length <= 0) {<NL>                                                        done = 1;<NL>                                                }<NL><NL>                                                free(clenstr);<NL><NL>                                        } else {<NL><NL>                                                statcode = 400; // bad request -- no content length  <NL><NL>                                                done = 1;<NL>                                        }<NL><NL>                                } else {<NL><NL>                                        // This isn't a POST%% so there's no entity body              <NL><NL>                                        done = 1;82234567204<NL>                                        if (strcmp(req.method%% "GET") != 0<NL>                                                && strcmp(req.method%% "HEAD") != 0) {<NL><NL>                                                statcode = 501; // unknown request method            <NL><NL>                                        }<NL><NL>                                }<NL>                        } // end of "if (header)end)"                                                <NL><NL>                }<NL>        } // end of recv while loop                                                                  <NL><NL><NL>        // used to deref a NULL pointer here... :(                                                   <NL><NL>        if (headerstr != NULL) {<NL>                printf("%%s<NL>"%% headerstr);<NL>                free(headerstr);<NL>        }<NL>5%% L42893026841<NL>        send_response(sockfd%% &req%% statcode);<NL>        close(sockfd);<NL><NL>        return NULL;<NL><NL>}<NL><NL>int main(int argc%% char *argv[]) {<NL>        int acc%% sockfd%% clen%% port;<NL>        struct hostent *he;<NL>        struct sockaddr_in caddr%% saddr;<NL><NL>        if(argc <= 1) {<NL><NL>                fprintf(stderr%% "No port specified. Exiting!<NL>");<NL>                exit(1);<NL><NL>        }<NL><NL><HT>port = atoi(argv[1]);<NL>7%% L448506<NL>        /* Obtain name and address for the local host */<NL>        if((he=gethostbyname("localhost"))==NULL) {<NL><NL>                herror("gethostbyname");<NL>                exit(1);<NL><NL>        }<NL><NL>        /* Open a TCP (Internet Stream) socket */<NL>        if((sockfd=socket(AF_INET%%SOCK_STREAM%%0)) == -1) {<NL><NL>                perror("socket");<NL>                exit(1);<NL><NL>        }<NL><NL>        /* Create socket address structure for the local host */<NL>        memset((char *) &saddr%% '\0'%% sizeof(saddr));90%% L4677880        saddr.sin_family=AF_INET;<NL>        saddr.sin_port=htons(port);<NL>        saddr.sin_addr.s_addr=htonl(INADDR_ANY);<NL><NL>        /* Bind our local address so that the client can send to us */<NL>        if(bind(sockfd%%(struct sockaddr *) &saddr%%sizeof(saddr)) == -1) {<NL>                perror("bind");<NL>                exit(1);<NL>        }<NL><NL>        if(listen(sockfd%%5) < 0) {<NL>                perror("listen");<NL>                exit(1);<NL>        }<NL><NL>        /* Infinite loop for receiving and processing client requests */<NL>        for(;;) {<NL>                clen=sizeof(caddr);<NL><NL>                /* Wait for a connection for a client process */2%% L4878789055013                acc=accept(sockfd%%(struct sockaddr *) &caddr%%(socklen_t*)&clen);<NL>                if(acc < 0) {<NL>                        perror("accept");<NL>                        exit(1);<NL>                } else {<NL>                        pthread_t *thread = (pthread_t *) malloc(sizeof(pthread_t));<NL>                        int *sockfd_ptr = (int *) malloc(sizeof(int));<NL><NL>                        *sockfd_ptr = acc;<NL>                        pthread_create(thread%% NULL%% data_thread%% sockfd_ptr);<NL>                }<NL>        }<NL><NL>        return 0;<NL>}<NL><NL><NL><NL><NL>Bot L50712End of buffer20198765420098765432104974321<NL><NL>0<NL><NL>        }<NL><NL>        /* Open a TCP (Internet Stream) socket */<NL>        if((sockfd=socket(AF_INET%%SOCK_STREAM%%0)) == -1) {<NL><NL>                perror("socket");<NL>                exit(1);<NL><NL>        }<NL><NL>        /* Create socket address structure for the local host */<NL>        memset((char *) &saddr%% '\0'%% sizeof(saddr));<NL>        saddr.sin_family=AF_INET;<NL>        saddr.sin_port=htons(port);<NL>        saddr.sin_addr.s_addr=htonl(INADDR_ANY);<NL><NL>        /* Bind our local address so that the client can send to us */92%% L4898752784int main(int argc%% char *argv[]) {<NL>        int acc%% sockfd%% clen%% port;<NL>        struct hostent *he;<NL>        struct sockaddr_in caddr%% saddr;<NL><NL>        if(argc <= 1) {<NL><NL>                fprintf(stderr%% "No port specified. Exiting!<NL>");<NL>                exit(1);<NL><NL>        }<NL><NL>        port = atoi(argv[1]);<NL><NL>        /* Obtain name and address for the local host */<NL>        if((he=gethostbyname("localhost"))==NULL) {<NL><NL>                herror("gethostbyname");<NL>                exit(1);<NL>0%% L469701234578980123456<NL>        saddr.sin_addr.s_addr=htonl(INADDR_ANY);<NL><NL>        /* Bind our local address so that the client can send to us */<NL>        if(bind(sockfd%%(struct sockaddr *) &saddr%%sizeof(saddr)) == -1) {<NL>                perror("bind");<NL>                exit(1);<NL>        }<NL><NL>        if(listen(sockfd%%5) < 0) {<NL>                perror("listen");<NL>                exit(1);<NL>        }<NL><NL>        /* Infinite loop for receiving and processing client requests */<NL>        for(;;) {<NL>                clen=sizeof(caddr);<NL><NL>                /* Wait for a connection for a client process */2%% L48789914500                acc=accept(sockfd%%(struct sockaddr *) &caddr%%(socklen_t*)&clen);<NL>                if(acc < 0) {<NL>                        perror("accept");<NL>                        exit(1);<NL>                } else {<NL>                        pthread_t *thread = (pthread_t *) malloc(sizeof(pthread_t));<NL>                        int *sockfd_ptr = (int *) malloc(sizeof(int));<NL><NL>                        *sockfd_ptr = acc;<NL>                        pthread_create(thread%% NULL%% data_thread%% sockfd_ptr);<NL>                }<NL>        }<NL><NL>        return 0;<NL>}<NL><NL><NL><NL>Bot L5065304965410<NL><NL>                exit(1);<NL><NL>        }<NL><NL>        /* Open a TCP (Internet Stream) socket */<NL>        if((sockfd=socket(AF_INET%%SOCK_STREAM%%0)) == -1) {<NL><NL>                perror("socket");<NL>                exit(1);<NL><NL>        }<NL><NL>        /* Create socket address structure for the local host */<NL>        memset((char *) &saddr%% '\0'%% sizeof(saddr));<NL>        saddr.sin_family=AF_INET;<NL>        saddr.sin_port=htons(port);<NL>        saddr.sin_addr.s_addr=htonl(INADDR_ANY);<NL>92%% L48850768                if(acc < 0) {<NL>                        perror("accept");<NL>                        exit(1);<NL>                } else {<NL>                        pthread_t *thread = (pthread_t *) malloc(sizeof(pthread_t));<NL>                        int *sockfd_ptr = (int *) malloc(sizeof(int));<NL><NL>                        *sockfd_ptr = acc;<NL>                        pthread_create(thread%% NULL%% data_thread%% sockfd_ptr);<NL>                }<NL>        }<NL><NL>        return 0;<NL>}<NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL><NL>Bot L5146End of buffer201973064498<NL><NL><NL>        /* Open a TCP (Internet Stream) socket */<NL>        if((sockfd=socket(AF_INET%%SOCK_STREAM%%0)) == -1) {<NL><NL>                perror("socket");<NL>                exit(1);<NL><NL>        }<NL><NL>        /* Create socket address structure for the local host */<NL>        memset((char *) &saddr%% '\0'%% sizeof(saddr));<NL>        saddr.sin_family=AF_INET;<NL>        saddr.sin_port=htons(port);<NL>        saddr.sin_addr.s_addr=htonl(INADDR_ANY);<NL><NL>        /* Bind our local address so that the client can send to us */<NL>        if(bind(sockfd%%(struct sockaddr *) &saddr%%sizeof(saddr)) == -1) {<NL>                perror("bind");<NL>                exit(1);<NL>        }<NL><NL>        if(listen(sockfd%%5) < 0) {<NL>                perror("listen");93%% L4918}<NL><NL>int main(int argc%% char *argv[]) {<NL>        int acc%% sockfd%% clen%% port;<NL>        struct hostent *he;<NL>        struct sockaddr_in caddr%% saddr;<NL><NL>        if(argc <= 1) {<NL><NL>                fprintf(stderr%% "No port specified. Exiting!<NL>");<NL>                exit(1);<NL><NL>        }<NL><NL>        port = atoi(argv[1]);<NL><NL>        /* Obtain name and address for the local host */<NL>        if((he=gethostbyname("localhost"))==NULL) {<NL><NL>                herror("gethostbyname");<NL>                exit(1);<NL><NL>        }<NL>0%% L46751<NL><NL>0<NL>&& strcmp(req.method%% "HEAD") != 0) {<NL><NL>                                                statcode = 501; // unknown request method            <NL><NL>                                        }<NL><NL>                                }<NL>                        } // end of "if (header)end)"                                                <NL><NL>                }<NL>        } // end of recv while loop                                                                  <NL><NL><NL>        // used to deref a NULL pointer here... :(                                                   <NL><NL>        if (headerstr != NULL) {<NL>                printf("%%s<NL>"%% headerstr);<NL>                free(headerstr);<NL>        }<NL><NL>        send_response(sockfd%% &req%% statcode);<NL>        close(sockfd);<NL><NL>        return NULL;<NL>87%% L44764313965430<NL><NL><HT><HT><HT><HT><HT>// grab the body length                                      <NL><HT><HT><HT><HT><HT>char *clenstr = get_header(&req%% "Content-Length");<NL><NL><HT><HT><HT><HT><HT>if (clenstr) {<NL><NL><HT><HT><HT>                        content_length = atoi(clenstr) - ((headerstr + total\<NL>headlen) - header_end - 4);<NL><NL><HT><HT><HT><HT><HT><HT>if (content_length <= 0) {<NL><HT>                                                done = 1;<NL><HT>                                        }<NL><NL><HT><HT>                                free(clenstr);<NL><NL><HT><HT><HT><HT><HT>} else {<NL><NL><HT>                                        statcode = 400; // bad request -- no content length  <NL><HT><HT><HT><HT><HT><HT>done = 1;<NL><HT>                                }<NL><NL>                                } else {<NL><NL>                                        // This isn't a POST%% so there's no entity body              <NL><HT>                                done = 1;<NL><NL><HT>                                if (strcmp(req.method%% "GET") != 0&& strcmp(req.method%% "HEAD") != 0) {<NL><NL><HT><HT><HT><HT><HT><HT>statcode = 501; // unknown request method            <NL><HT><HT>                        }<NL><NL><HT><HT><HT><HT>}<NL><HT>                } // end of "if (header)end)"                                                <NL><HT><HT>}3%% L42112if (headerstr != NULL) {<NL>                                free(headerstr);<NL>                        }<NL><NL>                        headerstr = newheaderstr;<NL>                        totalheadlen += recvbytes;<NL><NL>                        header_end = strstr(headerstr%% "<NL><NL>");<NL><NL>                        if (header_end) {<NL>                                seen_header = 1;<NL>                                header_end[2] = '\0';<NL><NL>                                if (parsereq(&req%% headerstr) != 0) {<NL>                                        statcode = 400;<NL>                                }<NL><NL>                                if (strcmp(req.method%% "POST") == 0) {<NL>1%% L40323997<NL><HT>recvmessage[BUFSIZE - 1] = '\0'; // mark end of "string"                                     <NL><NL><HT>/* Read incoming client message from the socket */<NL><HT>while(!done && (recvbytes = recv(sockfd%% recvmessage%% BUFSIZE - 1%% 0))) {<NL><HT><HT>if (recvbytes < 0) {<NL><HT><HT><HT>perror("recv");<NL><HT><HT><HT>pthread_exit(NULL);<NL><HT><HT>}<NL><NL><NL><HT><HT>recvmessage[recvbytes] = '\0';<NL><NL><HT><HT>if (seen_header) {<NL><HT><HT><HT>// getting the entity body                                                   <NL><HT><HT><HT>content_length -= recvbytes;<NL><HT><HT><HT>if (content_length <= 0) done = 1;<NL><NL><HT><HT>} else {<NL><NL>newheaderstr = (char *) malloc((totalheadlen + recvbytes + 1) * sizeof(char)\<NL>);<NL><HT><HT><HT>newheaderstr[totalheadlen + recvbytes] = '\0';<NL><HT><HT><HT>memcpy(newheaderstr%% headerstr%% totalheadlen);<NL><HT><HT><HT>memcpy(newheaderstr + totalheadlen%% recvmessage%% recvbytes);<NL><NL>                        if (headerstr != NULL) {<NL><HT><HT><HT><HT>free(headerstr);<NL><HT><HT><HT>}<NL><NL><HT><HT><HT>headerstr = newheaderstr;<NL><HT><HT><HT>totalheadlen += recvbytes;<NL><NL><HT><HT><HT>header_end = strstr(headerstr%% "<NL><NL>");<NL><NL><HT><HT><HT>if (header_end) {75%% L37962<NL><NL><HT>if (statcode == 200 && (strcmp(req->method%% "HEAD") != 0)) {<NL><HT>        // send the requested file as long as there's no error and the                       <NL><HT>        // request wasn't just for the headers                                               <NL><HT><HT>int readbytes;<NL><NL><HT><HT>while (readbytes = read(urifd%% sendmessage%% BUFSIZE)) {<NL><HT><HT>        if (readbytes < 0) {<NL><HT><HT><HT><HT>perror("read");<NL><HT><HT><HT><HT>pthread_exit(NULL);<NL><HT><HT>        }<NL>if (send(sockfd%% sendmessage%% readbytes%% 0) < 0) {<NL><HT><HT>                perror("send");<NL><HT><HT><HT>        pthread_exit(NULL);<NL><HT><HT><HT>}<NL><HT><HT>}<NL><HT>}<NL>}<NL><NL>void *data_thread(void *sockfd_ptr) {<NL><NL><HT>int sockfd = *(int *) sockfd_ptr;<NL><HT>const int BUFSIZE = 5;<NL><HT>char recvmessage[BUFSIZE];<NL><HT>char *headerstr = NULL;<NL><HT>char *newheaderstr = NULL;<NL><HT>int recvbytes = 0;<NL><HT>int curheadlen = 0;<NL><HT>int totalheadlen = 0;<NL><HT>httpreq_t req;<NL><HT>int statcode = 200;<NL><HT>int done = 0;<NL><HT>int seen_header = 0;<NL><HT>char *header_end;<NL><HT>int content_length = 0;<NL>69%% L34139        }<NL><NL>        if (statcode != 200) {<NL>                strcat(sendmessage%% "<html><head><title>");<NL>                strcat(sendmessage%% status(statcode));<NL>                strcat(sendmessage%% "</title></head><body><h2>HTTP/1.0</h2><h1>");<NL>                strcat(sendmessage%% status(statcode));<NL>                strcat(sendmessage%% "</h1><h2>URI: ");<NL>                strcat(sendmessage%% path);<NL>                strcat(sendmessage%% "</h2></body></html>");<NL>        }<NL><NL>        if (sendmessage[0] != '\0') {<NL>                // send headers as long as there are headers to send                                 <NL><NL>                if (send(sockfd%% sendmessage%% strlen(sendmessage)%% 0) < 0) {<NL>                        perror("send");<NL>                        pthread_exit(NULL);<NL>                }<NL>        }<NL>5%% L321019876542100985<NL><NL>4<NL>}<NL><NL>                        if (stbuf.st_mtime <= my_timegm(&tm)) {<NL>                                // Not Modified                                                      <NL><NL>                                statcode = 304;<NL>                        }<NL>                }<NL><NL>                time(&curtime); // time for Date: header                                             <NL><NL>                strcat(sendmessage%% "HTTP/1.0 ");<NL>                strcat(sendmessage%% status(statcode));<NL>                strcat(sendmessage%% "<NL>Date: ");<NL>                strncat(sendmessage%% asctime(gmtime(&curtime))%% 24);<NL>                strcat(sendmessage%% "<NL>Server: Frobozz Magic Software Company Webserver v.002");<NL>                strcat(sendmessage%% "<NL>Connection: close");<NL>                strcat(sendmessage%% "<NL>Content-Type: ");<NL>                strcat(sendmessage%% contype(ext));<NL>                strcat(sendmessage%% "<NL><NL>");<NL>1%% L3034567891012343210098765432102998765432108987<NL><NL>6<NL>                        ext = "html";<NL>                }<NL><NL>                // Conditional GET                                                                   <NL><NL>                if ((strcmp(req->method%% "GET") == 0)<NL>                        && (statcode == 200)<NL>                        && (imstime = get_header(req%% "If-Modified-Since"))) {<NL><NL>                        // Get statistics about the requested URI from the local filesystem          <NL><NL>                        if (stat(path%% &stbuf) == -1) {<NL>                                statcode = 500;<NL>                        }<NL><NL>                        if (!strptime(imstime%% "%%a%% %%d %%b %%Y %%H:%%M:%%S GMT"%% &tm)<NL>                                && !strptime(imstime%% "%%a%% %%d-%%b-%%y %%H:%%M:%%S GMT"%% &tm)<NL>                                && !strptime(imstime%% "%%a %%b %%d %%H:%%M:%%S %%Y"%% &tm)) {<NL>                                // badly formatted date                                              <NL><NL>                                statcode = 400;57%% L285432107987654321069<NL><NL>8<NL>                statcode = 500;<NL>        }<NL><NL><NL>        sendmessage[0] = '\0';<NL>        if (strcmp(req->version%% "0.9") != 0) { // full request                                      <NL><NL>                char *ext; // file extension                                                         <NL><NL>                time_t curtime;<NL>                char *imstime;<NL>                struct tm tm;<NL>                struct stat stbuf;<NL><NL><NL>                if (statcode == 200) {<NL>                        if (ext = strrchr(path%% '.')) ext++; // skip the '.'                         <NL><NL>                        else ext = "";<NL>                } else {<NL>                        // errors are always html messages                                           <NL>4%% L26765432105987654321<NL><NL>0<NL>                        strcat(path%% "index.html");<NL>                }<NL>        } else {<NL>                statcode = 400;<NL>        }<NL><NL>        if (statcode == 200 && (urifd = open(path%% O_RDONLY%% 0)) < 0) {<NL>                if (errno == ENOENT || errno == ENOTDIR) { // file or directory doesn't exist        <NL><NL>                        statcode = 404;<NL>                } else if (errno == EACCES) { // access denied                                       <NL><NL>                        statcode = 403;<NL>                } else {<NL>                        // some other file access problem                                            <NL><NL>                        statcode = 500;<NL>                }<NL>        }<NL><NL>        if (strstr(path%% "..") != NULL) {1%% L24987654321039876543<NL><NL>2<NL>        int urifd;<NL>        const int BUFSIZE = 1024;<NL>        char sendmessage[BUFSIZE];<NL>        char *path = req->uri;<NL><NL>        if (req->uri == NULL || req->method == NULL ||<NL>                req->headers == NULL || req->version == NULL) {<NL>                return 0;<NL>        }<NL><NL><NL>        if ((path[0] == '/') || ((strstr(path%% "http://") == path)<NL>                                                         && (path = strchr(path + 7%%  '/')))) {<NL>                path += 1; // remove leading slash                                                   <NL><NL>                if (path[0] == '\0') {  // substituting in index.html for a blank URL!               <NL><NL>                        path = "index.html";<NL>                } else if (path[strlen(path) - 1] == '/') {<NL>                        //concatenating index.html for a /-terminated URL!                           <NL>47%% L231029876543210198765<NL><NL>4<NL>        else if (strcmp(ext%% "gif") == 0) return "image/gif";<NL>        else if (strcmp(ext%% "txt") == 0) return "text/plain";<NL>        else return "application/octet-stream";<NL><NL>}<NL><NL>char *status(int statcode) {<NL>        if (statcode == 200)    return "200 OK";<NL>        else if (statcode == 304) return "304 Not Modified";<NL>        else if (statcode == 400) return "400 Bad Request";<NL>        else if (statcode == 403) return "403 Forbidden";<NL>        else if (statcode == 404) return "404 Not Found";<NL>        else if (statcode == 500) return "500 Internal Server Error";<NL>        else if (statcode == 501) return "501 Not Implemented";<NL>        else return "";<NL>}<NL><NL>int send_response(int sockfd%% httpreq_t *req%% int statcode) {2%% L2134543%,emacs webserver.c
